{
  "Sessions": [
    {
      "Type": "Registration",
      "Time": "08:00 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-26",
      "ChairsString": "",
      "Key": 596,
      "Items": [
        862
      ],
      "URL": null,
      "Title": "Saturday"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "Parsing @ SLE",
      "Location": "Cosmopolitan C (Third Level)",
      "Day": "2013-10-26",
      "ChairsString": "",
      "Key": 433,
      "Items": [
        706
      ],
      "URL": "http://www.planet-sl.org/parsing-at-sle2013",
      "Title": "Parsing @ SLE"
    },
    {
      "Type": "Keynotes",
      "Time": "09:00 - 10:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-26",
      "ChairsString": "",
      "Key": 644,
      "Items": [
        944
      ],
      "URL": "http://www.fosd.de/2013/",
      "Title": "FOSD — Can Features Have Interfaces?"
    },
    {
      "Type": "Workshops",
      "Time": "09:00 - 17:40",
      "ShortTitle": "FOSD",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-26",
      "ChairsString": "",
      "Key": 425,
      "Items": [
        698
      ],
      "URL": "http://www.fosd.de/2013/",
      "Title": "FOSD — Fifth International Workshop on Feature-Oriented Software Development"
    },
    {
      "Type": "Registration",
      "Time": "08:00 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 598,
      "Items": [
        863
      ],
      "URL": null,
      "Title": "Sunday"
    },
    {
      "Type": "Keynotes",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Regency D (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 645,
      "Items": [
        945
      ],
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Toward the future of personal computing system construction"
    },
    {
      "Type": "Keynotes",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 655,
      "Items": [
        955
      ],
      "URL": "http://program-transformation.org/GPCE13",
      "Title": "SLE/GPCE — Dark Knowledge and Graph Grammars in Automated Software Design"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 688,
      "Items": [
        705
      ],
      "URL": "http://fool2013.cs.brown.edu/",
      "Title": "FOOL — 20th International Workshop on Foundations of Object-Oriented Languages"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "AGERE! (1/2)",
      "Location": "Regency D (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 428,
      "Items": [
        701
      ],
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Programming based on Actors, Agents, and Decentralized Control (Day 1)"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "DSM",
      "Location": "Regency C (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 426,
      "Items": [
        699
      ],
      "URL": "http://www.dsmforum.org/events/DSM13/",
      "Title": "DSM — Domain-Specific Modeling"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency B (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 689,
      "Items": [
        709
      ],
      "URL": "http://refactoring.info/WRT13/",
      "Title": "WRT — Workshop on Refactoring Tools"
    },
    {
      "Type": "Workshops",
      "Time": "08:45 - 15:30",
      "ShortTitle": "WOSC",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "Saman Amarasinghe",
      "Key": 552,
      "Items": [
        757
      ],
      "URL": "http://people.csail.mit.edu/skamil/wosc/",
      "Title": "WOSC — Workshop on Optimizing Stencil Computations"
    },
    {
      "Type": "Keynotes",
      "Time": "09:00 - 10:30",
      "ShortTitle": "",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 647,
      "Items": [
        947
      ],
      "URL": "http://pear.sfsu.edu/promoto2013/",
      "Title": "PROMOTO — TouchDevelop: Productive Scripting on and for Touch-based Devices and Web Services"
    },
    {
      "Type": "Workshops",
      "Time": "09:00 - 17:30",
      "ShortTitle": "PROMOTO",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 434,
      "Items": [
        707
      ],
      "URL": "http://pear.sfsu.edu/promoto2013/",
      "Title": "PROMOTO — Programming for Mobile and Touch"
    },
    {
      "Type": "Keynotes",
      "Time": "10:30 - 11:30",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 646,
      "Items": [
        946
      ],
      "URL": "http://fool2013.cs.brown.edu",
      "Title": "FOOL — TS*: Gradual Typing Embedded Securely in JavaScript"
    },
    {
      "Type": "SLE",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 441,
      "Items": [
        976,
        977,
        978
      ],
      "URL": "",
      "Title": "Domain Specific Languages"
    },
    {
      "Type": "GPCE",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "Eelco Visser",
      "Key": 587,
      "Items": [
        1017,
        1011,
        1015
      ],
      "URL": "",
      "Title": "Session 1"
    },
    {
      "Type": "Keynotes",
      "Time": "13:00 - 14:00",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 664,
      "Items": [
        958
      ],
      "URL": "http://fool2013.cs.brown.edu",
      "Title": "FOOL Invited Talk — FOOL @ 20"
    },
    {
      "Type": "SLE",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 584,
      "Items": [
        979,
        980,
        981
      ],
      "URL": "",
      "Title": "Language Patterns & Evolution"
    },
    {
      "Type": "GPCE",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "Matthew Flatt",
      "Key": 586,
      "Items": [
        1019,
        1010,
        1007,
        1014
      ],
      "URL": "",
      "Title": "Session 2"
    },
    {
      "Type": "SLE",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 585,
      "Items": [
        982,
        983,
        984
      ],
      "URL": "",
      "Title": "Grammars"
    },
    {
      "Type": "GPCE",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "Julia Lawall",
      "Key": 458,
      "Items": [
        1016,
        1005,
        1002
      ],
      "URL": "",
      "Title": "Session 3"
    },
    {
      "Type": "Keynotes",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency B (Second Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 682,
      "Items": [
        1087
      ],
      "URL": "",
      "Title": "WRT Keynote — Refactoring, Reuse & Reality: Revisited"
    },
    {
      "Type": "Social Events",
      "Time": "18:00 - 21:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-27",
      "ChairsString": "",
      "Key": 632,
      "Items": [
        931
      ],
      "URL": null,
      "Title": "GPCE/SLE/Workshops Reception"
    },
    {
      "Type": "Registration",
      "Time": "08:00 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 599,
      "Items": [
        864
      ],
      "URL": null,
      "Title": "Monday"
    },
    {
      "Type": "Doctoral Symposium",
      "Time": "08:10 - 08:40",
      "ShortTitle": "",
      "Location": "Theory A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 656,
      "Items": [
        956,
        957
      ],
      "URL": "",
      "Title": "Introductions"
    },
    {
      "Type": "Keynotes",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 654,
      "Items": [
        954
      ],
      "URL": "http://program-transformation.org/GPCE13",
      "Title": "GPCE/SLE — Modeling Biology with Solver-Aided Programming Languages"
    },
    {
      "Type": "Keynotes",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Regency C (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 672,
      "Items": [
        998
      ],
      "URL": "",
      "Title": "REM — Making Live Programming Real"
    },
    {
      "Type": "SPLASH-E",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 668,
      "Items": [
        905,
        902
      ],
      "URL": "",
      "Title": "Session 1"
    },
    {
      "Type": "Keynotes",
      "Time": "08:30 - 10:00",
      "ShortTitle": "",
      "Location": "Regency B (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 650,
      "Items": [
        950
      ],
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — JavaScript as an Intermediate Language"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "AGERE! (2/2)",
      "Location": "Regency D (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 439,
      "Items": [
        712
      ],
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Programming based on Actors, Agents, and Decentralized Control (Day 2)"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "MARC",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 550,
      "Items": [
        755
      ],
      "URL": "http://www.mscs.mu.edu/~brylow/SPLASH-MARC-2013/",
      "Title": "MARC — Many-core Applications Research Community Symposium"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "REM",
      "Location": "Regency C (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 431,
      "Items": [
        704
      ],
      "URL": "http://soft.vub.ac.be/REM13",
      "Title": "REM — Reactivity, Events and Modularity"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "TD",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 429,
      "Items": [
        702
      ],
      "URL": "http://mysite.verizon.net/dennis.mancl/splash13/index.html",
      "Title": "TD — Technical Debt"
    },
    {
      "Type": "Workshops",
      "Time": "08:30 - 17:00",
      "ShortTitle": "VMIL",
      "Location": "Regency B (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 427,
      "Items": [
        700
      ],
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — 7th Workshop on Virtual Machines and Intermediate Languages"
    },
    {
      "Type": "Doctoral Symposium",
      "Time": "08:40 - 10:00",
      "ShortTitle": "",
      "Location": "Theory A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 657,
      "Items": [
        783,
        790
      ],
      "URL": "",
      "Title": "Session 1"
    },
    {
      "Type": "DLS",
      "Time": "09:00 - 09:05",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 607,
      "Items": [
        885
      ],
      "URL": "",
      "Title": "Opening Remarks"
    },
    {
      "Type": "Workshops",
      "Time": "09:00 - 17:20",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 690,
      "Items": [
        708
      ],
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml ",
      "Title": "MobilDeLi — Mobile Development Lifecycle"
    },
    {
      "Type": "Keynotes",
      "Time": "09:05 - 10:00",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 653,
      "Items": [
        953
      ],
      "URL": "",
      "Title": "DLS — VMs I Have Known and/or Loved"
    },
    {
      "Type": "Keynotes",
      "Time": "09:20 - 09:50",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 648,
      "Items": [
        948
      ],
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml",
      "Title": "MobileDeLi — MobileFirst: Future Directions in Programming and Runtime Models"
    },
    {
      "Type": "Doctoral Symposium",
      "Time": "10:30 - 11:50",
      "ShortTitle": "",
      "Location": "Theory A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 659,
      "Items": [
        785,
        786
      ],
      "URL": "",
      "Title": "Session 2"
    },
    {
      "Type": "DLS",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 609,
      "Items": [
        877,
        878,
        886
      ],
      "URL": "",
      "Title": "Research Papers 1"
    },
    {
      "Type": "GPCE",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "Jan Vitek",
      "Key": 423,
      "Items": [
        1012,
        1009,
        1018
      ],
      "URL": "",
      "Title": "Session  4"
    },
    {
      "Type": "SPLASH-E",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 669,
      "Items": [
        899,
        900,
        901
      ],
      "URL": "",
      "Title": "Session 2"
    },
    {
      "Type": "SLE",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 459,
      "Items": [
        985,
        986,
        987,
        988
      ],
      "URL": "",
      "Title": "Tools"
    },
    {
      "Type": "Doctoral Symposium",
      "Time": "13:00 - 15:00",
      "ShortTitle": "",
      "Location": "Theory A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 661,
      "Items": [
        789,
        787,
        788
      ],
      "URL": "",
      "Title": "Session 3"
    },
    {
      "Type": "Keynotes",
      "Time": "13:30 - 14:00",
      "ShortTitle": "",
      "Location": "Regency A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 649,
      "Items": [
        949
      ],
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml",
      "Title": "MobileDeLi — Mobile Computing in Resource-Constrained Environments"
    },
    {
      "Type": "SLE",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 582,
      "Items": [
        989,
        990,
        991
      ],
      "URL": "",
      "Title": "Language Analysis"
    },
    {
      "Type": "DLS",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 610,
      "Items": [
        879,
        880,
        881
      ],
      "URL": "",
      "Title": "Research Papers 2"
    },
    {
      "Type": "SPLASH-E",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 670,
      "Items": [
        904,
        917
      ],
      "URL": "",
      "Title": "Session 3"
    },
    {
      "Type": "GPCE",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "Sebastian Erdweg",
      "Key": 588,
      "Items": [
        1006,
        1013,
        1000,
        1001
      ],
      "URL": "",
      "Title": "Session 5"
    },
    {
      "Type": "Keynotes",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency B (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 651,
      "Items": [
        951
      ],
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — Do Computer Programs Have to Be As Dumb As They Are?"
    },
    {
      "Type": "Doctoral Symposium",
      "Time": "15:30 - 16:50",
      "ShortTitle": "",
      "Location": "Theory A (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 663,
      "Items": [
        784,
        791
      ],
      "URL": "",
      "Title": "Session 4"
    },
    {
      "Type": "SLE",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 583,
      "Items": [
        992,
        993,
        994
      ],
      "URL": "",
      "Title": "Meta- and Megamodeling"
    },
    {
      "Type": "DLS",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 611,
      "Items": [
        882,
        883,
        884
      ],
      "URL": "",
      "Title": "Research Papers 3"
    },
    {
      "Type": "SPLASH-E",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 671,
      "Items": [
        903,
        906
      ],
      "URL": "",
      "Title": "Session 4"
    },
    {
      "Type": "GPCE",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan CD (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "Yannis Smaragdakis",
      "Key": 589,
      "Items": [
        1003,
        1004,
        1008
      ],
      "URL": "",
      "Title": "Session 6"
    },
    {
      "Type": "Posters",
      "Time": "18:00 - 21:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-28",
      "ChairsString": "",
      "Key": 593,
      "Items": [
        997,
        793,
        794,
        795,
        796,
        798,
        799,
        800,
        801,
        802,
        803,
        804,
        805,
        995,
        996,
        999,
        1023,
        1024,
        1025,
        1026,
        1027,
        1028,
        1029,
        1030,
        1031,
        1032,
        1033,
        1034,
        1035,
        1036,
        1037,
        1038,
        1039,
        1040,
        1041,
        1042,
        1043,
        1044,
        1045,
        1047,
        1048,
        1049,
        1050,
        1051,
        1052,
        1053,
        1054,
        1055,
        1056,
        1057,
        1058,
        1059,
        1060,
        1061,
        1062,
        1063,
        1065,
        1066,
        1067,
        1068,
        1069,
        1070,
        1077,
        1080,
        1085,
        1088,
        1089
      ],
      "URL": "",
      "Title": "Poster Reception, supported by Microsoft Research"
    },
    {
      "Type": "Registration",
      "Time": "08:00 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 597,
      "Items": [
        865
      ],
      "URL": null,
      "Title": "Tuesday"
    },
    {
      "Type": "Announcements",
      "Time": "08:30 - 08:40",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 635,
      "Items": [
        934
      ],
      "URL": "",
      "Title": "Welcome, Chair's Reports"
    },
    {
      "Type": "Keynotes",
      "Time": "08:40 - 10:00",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 449,
      "Items": [
        720
      ],
      "URL": "",
      "Title": "SPLASH — The Yin and Yang of Hardware Heterogeneity: Can Software Survive?"
    },
    {
      "Type": "SPLASH-I",
      "Time": "10:30 - 11:30",
      "ShortTitle": "Parallel JavaScript",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 506,
      "Items": [
        750
      ],
      "URL": null,
      "Title": "Parallelism for the Masses: A Parallel JavaScript"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Capsule-Oriented Concurrency",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 534,
      "Items": [
        748
      ],
      "URL": "",
      "Title": "Capsule-Oriented Programming: Concurrency Made Simple"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Spoofax",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 538,
      "Items": [
        738
      ],
      "URL": "",
      "Title": "Interactive Language Design with the Spoofax Language Workbench"
    },
    {
      "Type": "OOPSLA",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "Cristina Lopes",
      "Key": 451,
      "Items": [
        813,
        851,
        844
      ],
      "URL": "",
      "Title": "Plenary Session"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "R",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 613,
      "Items": [
        888
      ],
      "URL": "",
      "Title": "R: A Language for Analyzing Data"
    },
    {
      "Type": "Onward!",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "Kevin Sullivan",
      "Key": 558,
      "Items": [
        926,
        925,
        921
      ],
      "URL": "",
      "Title": "Session 1"
    },
    {
      "Type": "SPLASH-I",
      "Time": "11:30 - 12:30",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 640,
      "Items": [
        939
      ],
      "URL": null,
      "Title": "Julia, the language"
    },
    {
      "Type": "Onward! Steering Committee",
      "Time": "12:00 - 14:00",
      "ShortTitle": "",
      "Location": "Studio Six (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "Kevin Sullivan",
      "Key": 677,
      "Items": [
        1064
      ],
      "URL": null,
      "Title": "Onward! Steering Committee Meeting"
    },
    {
      "Type": "SPLASH-I",
      "Time": "13:00 - 14:00",
      "ShortTitle": "Industrial Research",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 509,
      "Items": [
        742
      ],
      "URL": null,
      "Title": "So you want to be an industrial researcher? "
    },
    {
      "Type": "Panels",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "Jan Vitek",
      "Key": 576,
      "Items": [
        872,
        873
      ],
      "URL": "",
      "Title": "Debate: Should Software Conferences Respect Software?"
    },
    {
      "Type": "OOPSLA",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "Dan Grossman",
      "Key": 511,
      "Items": [
        808,
        835,
        825,
        810
      ],
      "URL": "",
      "Title": "Memory & Size Management"
    },
    {
      "Type": "Wavefront",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 565,
      "Items": [
        908,
        909
      ],
      "URL": "",
      "Title": "Papers"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "Performance Requirements Best Practices",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 533,
      "Items": [
        733
      ],
      "URL": "",
      "Title": "Best Practices for Writing and Managing Performance Requirements"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 642,
      "Items": [
        942
      ],
      "URL": "",
      "Title": "Language Modeling Principles"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 546,
      "Items": [
        730
      ],
      "URL": "",
      "Title": "Verified Software Components"
    },
    {
      "Type": "SPLASH-I",
      "Time": "14:00 - 15:00",
      "ShortTitle": "Dart",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 503,
      "Items": [
        725
      ],
      "URL": null,
      "Title": "Civilizing Web Programming with Dart"
    },
    {
      "Type": "SPLASH-I",
      "Time": "15:00 - 16:00",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 508,
      "Items": [
        745
      ],
      "URL": null,
      "Title": "R for Big Data"
    },
    {
      "Type": "OOPSLA",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "Matthias Hauswirth",
      "Key": 513,
      "Items": [
        812,
        836,
        829
      ],
      "URL": "",
      "Title": "Artifacts"
    },
    {
      "Type": "Onward!",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "Jonathan Edwards",
      "Key": 559,
      "Items": [
        922,
        928,
        920
      ],
      "URL": "",
      "Title": "Session 2"
    },
    {
      "Type": "Panels",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "Steven D. Fraser",
      "Key": 577,
      "Items": [
        907
      ],
      "URL": "",
      "Title": "Technical Debt"
    },
    {
      "Type": "SPLASH-I",
      "Time": "16:00 - 17:00",
      "ShortTitle": "Reflections on X10",
      "Location": "Network (Second Level)",
      "Day": "2013-10-29",
      "ChairsString": "",
      "Key": 557,
      "Items": [
        759
      ],
      "URL": null,
      "Title": "Reflections on X10: Towards Performance and Productivity at Scale"
    },
    {
      "Type": "SPLASH Steering Committee",
      "Time": "17:00 - 20:00",
      "ShortTitle": "",
      "Location": "Studio Two (Third Level)",
      "Day": "2013-10-29",
      "ChairsString": "Cristina Lopes",
      "Key": 643,
      "Items": [
        943
      ],
      "URL": null,
      "Title": "SPLASH Steering Committee Meeting"
    },
    {
      "Type": "Registration",
      "Time": "08:00 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 600,
      "Items": [
        866
      ],
      "URL": null,
      "Title": "Wednesday"
    },
    {
      "Type": "Keynotes",
      "Time": "08:40 - 10:00",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 450,
      "Items": [
        721
      ],
      "URL": null,
      "Title": "OOPSLA — Two Solitudes"
    },
    {
      "Type": "Demonstrations",
      "Time": "10:30 - 11:15",
      "ShortTitle": "JML/ajmlc",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 624,
      "Items": [
        889
      ],
      "URL": null,
      "Title": "Client-Aware Checking and Information Hiding in Interface Specifications with JML/ajmlc"
    },
    {
      "Type": "SPLASH-I",
      "Time": "10:30 - 11:30",
      "ShortTitle": "Cloud Sessions",
      "Location": "Theory (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 620,
      "Items": [
        913
      ],
      "URL": null,
      "Title": "Cloud Sessions: A Simple Face for Eventual Consistency"
    },
    {
      "Type": "SPLASH-I",
      "Time": "10:30 - 11:30",
      "ShortTitle": "Subjective Programming",
      "Location": "Network (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 505,
      "Items": [
        739
      ],
      "URL": null,
      "Title": "Dancing with Symmetry to Harness the Power of Complexity: Subjective Programming in Context"
    },
    {
      "Type": "OOPSLA",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "Shigeru Chiba",
      "Key": 452,
      "Items": [
        845,
        841,
        834,
        833
      ],
      "URL": "",
      "Title": "Language Design"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Boa Repository Mining",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 540,
      "Items": [
        736
      ],
      "URL": "http://boa.cs.iastate.edu/",
      "Title": "Mining Ultra-Large-Scale Software Repositories with Boa"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Charm++",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 542,
      "Items": [
        735
      ],
      "URL": "",
      "Title": "Parallel Programming with Charm++"
    },
    {
      "Type": "OOPSLA",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "Gang Tan",
      "Key": 528,
      "Items": [
        822,
        852,
        848,
        840
      ],
      "URL": "",
      "Title": "Security & Optimization"
    },
    {
      "Type": "Onward!",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "Bernd Brügge",
      "Key": 641,
      "Items": [
        940,
        941
      ],
      "URL": "",
      "Title": "Session 3: Essays"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Jikes RVM",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 544,
      "Items": [
        737
      ],
      "URL": "http://sape.inf.usi.ch/rdb",
      "Title": "Using a VM For Effective Research and Teaching: Learn to hack a VM in 90 minutes"
    },
    {
      "Type": "Demonstrations",
      "Time": "11:15 - 12:00",
      "ShortTitle": "ZipPy on Truffle",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 631,
      "Items": [
        892
      ],
      "URL": null,
      "Title": "ZipPy on Truffle: A Fast and Simple Implementation of Python"
    },
    {
      "Type": "SPLASH-I",
      "Time": "11:30 - 12:30",
      "ShortTitle": "",
      "Location": "Theory (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 504,
      "Items": [
        740
      ],
      "URL": null,
      "Title": "Computing without Processors"
    },
    {
      "Type": "SPLASH-I",
      "Time": "11:30 - 12:30",
      "ShortTitle": "Lancet",
      "Location": "Network (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 529,
      "Items": [
        751
      ],
      "URL": null,
      "Title": "Surgical Precision JIT Compilers"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 15:00",
      "ShortTitle": "Dalvik",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 536,
      "Items": [
        747
      ],
      "URL": "",
      "Title": "Diving into Dalvik"
    },
    {
      "Type": "Keynotes",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 502,
      "Items": [
        741
      ],
      "URL": null,
      "Title": "Wavefront — Declarative Programming for the Cloud"
    },
    {
      "Type": "ACM SRC",
      "Time": "13:30 - 17:00",
      "ShortTitle": "",
      "Location": "Theory (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 547,
      "Items": [
        960,
        961,
        962,
        963,
        964,
        965,
        966,
        967,
        968,
        969,
        970,
        971,
        972,
        973,
        974
      ],
      "URL": "",
      "Title": "ACM Student Research Competition"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "Fundamental Developer Practices",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 532,
      "Items": [
        728
      ],
      "URL": "",
      "Title": "Fundamental Practices of Software Developers"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "UML Architecture Documentation",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 537,
      "Items": [
        731
      ],
      "URL": "",
      "Title": "How to Document the Architecture of Your Application Using UML and More"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "Multicore Programming",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 541,
      "Items": [
        729
      ],
      "URL": "",
      "Title": "Multicore Programming using Divide-and-Conquer and Work Stealing"
    },
    {
      "Type": "Demonstrations",
      "Time": "15:30 - 16:15",
      "ShortTitle": "Android App Flaws",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 625,
      "Items": [
        894
      ],
      "URL": null,
      "Title": "Finding Architectural Flaws in Android Apps Is Easy"
    },
    {
      "Type": "SPLASH-I",
      "Time": "15:30 - 16:30",
      "ShortTitle": "",
      "Location": "Network (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 507,
      "Items": [
        744
      ],
      "URL": null,
      "Title": "PHP, Seriously!"
    },
    {
      "Type": "OOPSLA",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "Emerson Murphy-Hill",
      "Key": 518,
      "Items": [
        818,
        842,
        827,
        819
      ],
      "URL": "",
      "Title": "Design & Analysis Tools"
    },
    {
      "Type": "Onward!",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "Sean McDirmid",
      "Key": 560,
      "Items": [
        927,
        923,
        924
      ],
      "URL": "",
      "Title": "Session 4"
    },
    {
      "Type": "OOPSLA",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "Todd Millstein",
      "Key": 519,
      "Items": [
        807,
        853,
        811,
        809
      ],
      "URL": "",
      "Title": "Verification"
    },
    {
      "Type": "Demonstrations",
      "Time": "16:15 - 17:00",
      "ShortTitle": "Panini",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 630,
      "Items": [
        893
      ],
      "URL": null,
      "Title": "Panini: a Capsule-oriented Programming Language for Implicitly Concurrent Program Design"
    },
    {
      "Type": "SPLASH-I",
      "Time": "16:30 - 17:30",
      "ShortTitle": "JavaScript Blues ",
      "Location": "Network (Second Level)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 603,
      "Items": [
        869
      ],
      "URL": null,
      "Title": "Test and Cure your JavaScript Blues "
    },
    {
      "Type": "Social Events",
      "Time": "18:00 - 21:00",
      "ShortTitle": "",
      "Location": "Indiana Roof Ballroom (Across the Street)",
      "Day": "2013-10-30",
      "ChairsString": "",
      "Key": 633,
      "Items": [
        932
      ],
      "URL": null,
      "Title": "Banquet Reception"
    },
    {
      "Type": "Registration",
      "Time": "08:00 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 601,
      "Items": [
        867
      ],
      "URL": null,
      "Title": "Thursday"
    },
    {
      "Type": "Announcements",
      "Time": "08:30 - 08:40",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 637,
      "Items": [
        935,
        936,
        937
      ],
      "URL": "",
      "Title": "Awards"
    },
    {
      "Type": "Keynotes",
      "Time": "08:40 - 10:00",
      "ShortTitle": "",
      "Location": "Regency A-D (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 448,
      "Items": [
        719
      ],
      "URL": null,
      "Title": "Onward! — Does Thought Crime Pay?"
    },
    {
      "Type": "Demonstrations",
      "Time": "10:30 - 11:15",
      "ShortTitle": "Eclipse Runtime Perspective",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 626,
      "Items": [
        895
      ],
      "URL": null,
      "Title": "Finding the Missing Eclipse Perspective: the Runtime Perspective"
    },
    {
      "Type": "SPLASH-I",
      "Time": "10:30 - 11:30",
      "ShortTitle": "Asynchronous Programming",
      "Location": "Network (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 510,
      "Items": [
        743
      ],
      "URL": null,
      "Title": "The Next 700 Asynchronous Programming Models"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Agile",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 622,
      "Items": [
        915
      ],
      "URL": "",
      "Title": "Agile Studies of Agile Methods"
    },
    {
      "Type": "OOPSLA",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Andrew Black",
      "Key": 521,
      "Items": [
        823,
        855,
        832,
        831
      ],
      "URL": "",
      "Title": "Distribution & Parallelism"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "Living without Pointers",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 539,
      "Items": [
        734
      ],
      "URL": "",
      "Title": "Living without Pointers: Bringing Value Semantics to Object-Oriented Parallel Programming"
    },
    {
      "Type": "Onward!",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "Shigeru Chiba",
      "Key": 561,
      "Items": [
        918,
        919
      ],
      "URL": "",
      "Title": "Session 5"
    },
    {
      "Type": "OOPSLA",
      "Time": "10:30 - 12:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Isil Dillig",
      "Key": 453,
      "Items": [
        826,
        846,
        843,
        828
      ],
      "URL": "",
      "Title": "Types & Contracts"
    },
    {
      "Type": "Tutorials",
      "Time": "10:30 - 12:00",
      "ShortTitle": "API Economy",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 543,
      "Items": [
        749
      ],
      "URL": "",
      "Title": "Unlocking the benefits of the API Economy"
    },
    {
      "Type": "Demonstrations",
      "Time": "11:15 - 12:00",
      "ShortTitle": "Boa Repository Mining",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 627,
      "Items": [
        890
      ],
      "URL": null,
      "Title": "Mining Source Code Repositories with Boa"
    },
    {
      "Type": "SPLASH-I",
      "Time": "13:00 - 14:00",
      "ShortTitle": "TypeScript",
      "Location": "Network (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 553,
      "Items": [
        758
      ],
      "URL": null,
      "Title": "TypeScript: a Type System for Toolability"
    },
    {
      "Type": "Demonstrations",
      "Time": "13:30 - 14:15",
      "ShortTitle": "NitroGen",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 628,
      "Items": [
        891
      ],
      "URL": null,
      "Title": "NitroGen: Rapid Development of Mobile Applications"
    },
    {
      "Type": "OOPSLA",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Yu David Liu",
      "Key": 527,
      "Items": [
        815,
        850,
        847,
        839
      ],
      "URL": "",
      "Title": "Mobile & Graphics"
    },
    {
      "Type": "OOPSLA",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Jennifer Sartor",
      "Key": 514,
      "Items": [
        806,
        817,
        816,
        814
      ],
      "URL": "",
      "Title": "Parallelism & Concurrency"
    },
    {
      "Type": "Wavefront Experience",
      "Time": "13:30 - 15:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan B (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 566,
      "Items": [
        910,
        911,
        912
      ],
      "URL": "",
      "Title": "Reports"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "Dafny",
      "Location": "Regency F (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 535,
      "Items": [
        732
      ],
      "URL": "http://research.microsoft.com/dafny",
      "Title": "Developing Verified Programs with Dafny"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "Grace",
      "Location": "Discovery (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 621,
      "Items": [
        914
      ],
      "URL": "http://gracelang.org/",
      "Title": "Grace:  A new object-oriented language for novices"
    },
    {
      "Type": "Tutorials",
      "Time": "13:30 - 17:00",
      "ShortTitle": "FP in Financial Engineering",
      "Location": "Regency E (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 545,
      "Items": [
        746
      ],
      "URL": "",
      "Title": "Using Functional Programming Concepts in Financial Engineering"
    },
    {
      "Type": "SPLASH-I",
      "Time": "14:00 - 15:00",
      "ShortTitle": "AppScale",
      "Location": "Network (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 530,
      "Items": [
        752
      ],
      "URL": null,
      "Title": "Write-Once, Run-Anywhere for the Cloud"
    },
    {
      "Type": "Demonstrations",
      "Time": "14:15 - 15:00",
      "ShortTitle": "Objektgraph",
      "Location": "Vision (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 629,
      "Items": [
        896
      ],
      "URL": null,
      "Title": "Objektgraph: Why Code When MVC Apps Can Be Generated Solely With UML-based Diagrams?"
    },
    {
      "Type": "SPLASH-I",
      "Time": "15:00 - 16:00",
      "ShortTitle": "Comprehensive JavaScript VM",
      "Location": "Network (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 612,
      "Items": [
        887
      ],
      "URL": null,
      "Title": "A Comprehensive JavaScript VM"
    },
    {
      "Type": "OOPSLA",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency CD (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Guoqing Xu",
      "Key": 531,
      "Items": [
        824,
        854,
        838,
        830
      ],
      "URL": "",
      "Title": "Concurrency & Performance"
    },
    {
      "Type": "OOPSLA",
      "Time": "15:30 - 17:00",
      "ShortTitle": "",
      "Location": "Regency AB (Second Level)",
      "Day": "2013-10-31",
      "ChairsString": "Yannis Smaragdakis",
      "Key": 520,
      "Items": [
        820,
        849,
        837,
        821
      ],
      "URL": "",
      "Title": "Faults & Errors"
    },
    {
      "Type": "Social Events",
      "Time": "17:00 - 19:00",
      "ShortTitle": "",
      "Location": "Cosmopolitan Foyer (Third Level)",
      "Day": "2013-10-31",
      "ChairsString": "",
      "Key": 634,
      "Items": [
        933
      ],
      "URL": null,
      "Title": "Ice Cream Social"
    }
  ],
  "Description": "The ACM International Conference on Systems, Programming, Languages and Applications: Software for Humanity (SPLASH) is sponsored by ACM SIGPLAN.\r\n\r\nSPLASH is the home of OOPSLA Research Papers, Onward!, and the Dynamic Languages Symposium, among other events.\r\n",
  "People": [
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1769,
      "Name": " Aniruddha Gokhale"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1449,
      "Name": "A. J. Brush"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1813,
      "Name": "A. Milicevic"
    },
    {
      "Affiliation": "U Porto, Portugal",
      "Bio": "",
      "Key": 1240,
      "Name": "Ademar Aguiar"
    },
    {
      "Affiliation": "U London, UK",
      "Bio": "",
      "Key": 1668,
      "Name": "Adrian Johnstone"
    },
    {
      "Affiliation": "U Athens, Greece",
      "Bio": "",
      "Key": 1428,
      "Name": "Aggelos Biboudis"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1227,
      "Name": "Aharon Abadi"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1748,
      "Name": "Aibek Sarimbekov"
    },
    {
      "Affiliation": "Riken Advanced Institute of Computational Science, Kobe, Japan",
      "Bio": "",
      "Key": 1210,
      "Name": "Akinori Yonezawa"
    },
    {
      "Affiliation": "U Texas San Antonio, USA",
      "Bio": "",
      "Key": 1586,
      "Name": "Akshatha Bhat"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1376,
      "Name": "Alastair Donaldson"
    },
    {
      "Affiliation": "Sioux, Eindhoven, Netherlands",
      "Bio": "",
      "Key": 1677,
      "Name": "Albert Gerritsen"
    },
    {
      "Affiliation": "ETH Zürich, Switzerland",
      "Bio": "",
      "Key": 1380,
      "Name": "Albert Noll"
    },
    {
      "Affiliation": "Free U Bolzano-­Bozen, Italy",
      "Bio": "",
      "Key": 1287,
      "Name": "Alberto Sillitti"
    },
    {
      "Affiliation": "Argentina",
      "Bio": "",
      "Key": 1430,
      "Name": "Alejandro Martinez"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1609,
      "Name": "Aleksandar Milicevic"
    },
    {
      "Affiliation": "ETH Zurich, Switzerland",
      "Bio": "",
      "Key": 1737,
      "Name": "Alen Stojanov"
    },
    {
      "Affiliation": "U Bologna, Italy",
      "Bio": "",
      "Key": 1208,
      "Name": "Alessandro Ricci"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1356,
      "Name": "Alex Aiken"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1679,
      "Name": "Alex Loh"
    },
    {
      "Affiliation": "Victoria U Wellington, New Zealand",
      "Bio": "",
      "Key": 1801,
      "Name": "Alex Potanin"
    },
    {
      "Affiliation": "Johannes Kepler U, Austria",
      "Bio": "",
      "Key": 1243,
      "Name": "Alexander Egyed"
    },
    {
      "Affiliation": "U Colorado Boulder, USA",
      "Bio": "",
      "Key": 1617,
      "Name": "Alexander Repenning"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1753,
      "Name": "Alexander von Rhein"
    },
    {
      "Affiliation": "CAST Software Research Labs, USA",
      "Bio": "",
      "Key": 1581,
      "Name": "Alexandra Szynkarski"
    },
    {
      "Affiliation": "University of Sao Paulo, Brazil",
      "Bio": "",
      "Key": 1831,
      "Name": "Alfredo Goldman"
    },
    {
      "Affiliation": "Centrum Wiskunde & Informatica, Netherlands",
      "Bio": "",
      "Key": 1667,
      "Name": "Ali Afroozeh"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1843,
      "Name": "Ali Jafari"
    },
    {
      "Affiliation": "Siemens, Austria",
      "Bio": "",
      "Key": 1730,
      "Name": "Alois Haselböck"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1447,
      "Name": "Aman Kansal"
    },
    {
      "Affiliation": "India",
      "Bio": "",
      "Key": 1435,
      "Name": "Anand Chitipothu"
    },
    {
      "Affiliation": "Aarhus U, Denmark",
      "Bio": "",
      "Key": 1389,
      "Name": "Anders Møller"
    },
    {
      "Affiliation": "Siemens, USA",
      "Bio": "",
      "Key": 1258,
      "Name": "André Bondi"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1242,
      "Name": "André van der Hoek"
    },
    {
      "Affiliation": "Free U Bolzano-Bozen, Italy",
      "Bio": "",
      "Key": 1274,
      "Name": "Andrea Janes"
    },
    {
      "Affiliation": "U Bologna, Italy",
      "Bio": "",
      "Key": 1803,
      "Name": "Andrea Marongiu"
    },
    {
      "Affiliation": "U Bologna, Italy",
      "Bio": "",
      "Key": 1337,
      "Name": "Andrea Santi"
    },
    {
      "Affiliation": "Real-Time Innovations, USA",
      "Bio": "",
      "Key": 1342,
      "Name": "Andrea Sorbini"
    },
    {
      "Affiliation": "Verbund Traging AG, Austria",
      "Bio": "",
      "Key": 1652,
      "Name": "Andreas Beck"
    },
    {
      "Affiliation": "Intec Software Engineering, Belgium",
      "Bio": "",
      "Key": 1198,
      "Name": "Andreas Classen"
    },
    {
      "Affiliation": "Siemens, Austria",
      "Bio": "",
      "Key": 1729,
      "Name": "Andreas Falkner"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1863,
      "Name": "Andreas Schroeder"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1749,
      "Name": "Andreas Sewe"
    },
    {
      "Affiliation": "Johannes Kepler U Linz, Austria",
      "Bio": "",
      "Key": 1596,
      "Name": "Andreas Woess"
    },
    {
      "Affiliation": "Ioan Cuza U, Romania",
      "Bio": "",
      "Key": 1701,
      "Name": "Andrei Arusoaie"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1548,
      "Name": "Andrei Kirshin"
    },
    {
      "Affiliation": "U Koblenz-Landau, Germany",
      "Bio": "",
      "Key": 1696,
      "Name": "Andrei Varanovich"
    },
    {
      "Affiliation": "Portland State U, USA",
      "Bio": "",
      "Key": 1592,
      "Name": "Andrew Black"
    },
    {
      "Affiliation": "Wayne State U, USA",
      "Bio": "",
      "Key": 1557,
      "Name": "Andrew Giang"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1870,
      "Name": "Andrew Rice"
    },
    {
      "Affiliation": "Queen's U, Canada",
      "Bio": "",
      "Key": 1793,
      "Name": "Andrew Stevenson"
    },
    {
      "Affiliation": "ITU Copenhagen, Denmark",
      "Bio": "",
      "Key": 1712,
      "Name": "Andrzej Wasowski"
    },
    {
      "Affiliation": "U Cambridge, UK",
      "Bio": "",
      "Key": 1828,
      "Name": "Andy Rice"
    },
    {
      "Affiliation": "Delphino Consultancy, Netherlands",
      "Bio": "",
      "Key": 1678,
      "Name": "Angelo Hulshout"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1340,
      "Name": "Aniruddha Gokhale"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1770,
      "Name": "Annemarie Harzl"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1796,
      "Name": "Antonio Barbalace"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1308,
      "Name": "Antony Hosking"
    },
    {
      "Affiliation": "U Bergen, Norway",
      "Bio": "",
      "Key": 1671,
      "Name": "Anya Helene Bagge"
    },
    {
      "Affiliation": "Viewpoints Research Institute, USA",
      "Bio": "",
      "Key": 1615,
      "Name": "Aran Lunzer"
    },
    {
      "Affiliation": "Princeton U, USA",
      "Bio": "",
      "Key": 1370,
      "Name": "Ariel Rabkin"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1387,
      "Name": "Aritra Sengupta"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1790,
      "Name": "Arjmand Samuel"
    },
    {
      "Affiliation": "Cornell U, USA",
      "Bio": "",
      "Key": 1511,
      "Name": "Arjun Guha"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1593,
      "Name": "Armando Fox"
    },
    {
      "Affiliation": "San Francisco State U, USA",
      "Bio": "",
      "Key": 1226,
      "Name": "Arno Puder"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1646,
      "Name": "Arvind Sujeeth"
    },
    {
      "Affiliation": "Aarhus U, Denmark",
      "Bio": "",
      "Key": 1388,
      "Name": "Asger Feldthaus"
    },
    {
      "Affiliation": "Fraunhofer FOKUS, Germany",
      "Bio": "",
      "Key": 1820,
      "Name": "Aurele Destailleur"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1564,
      "Name": "Austin Cory Bart"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1647,
      "Name": "Austin Gibbons"
    },
    {
      "Affiliation": "Argonne National Lab, USA",
      "Bio": "",
      "Key": 1835,
      "Name": "Azamat Mametjanov"
    },
    {
      "Affiliation": "Qualcomm, USA",
      "Bio": "",
      "Key": 1522,
      "Name": "Behnam Robatmili"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1540,
      "Name": "Ben Hardekopf"
    },
    {
      "Affiliation": "Harvey Mudd College, USA",
      "Bio": "",
      "Key": 1539,
      "Name": "Ben Wiedermann"
    },
    {
      "Affiliation": "Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1799,
      "Name": "Benjamin Chung"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1509,
      "Name": "Benjamin Lerner"
    },
    {
      "Affiliation": "U Rennes, INRIA, France",
      "Bio": "",
      "Key": 1717,
      "Name": "Benoit Baudry"
    },
    {
      "Affiliation": "U Rennes, INRIA, France",
      "Bio": "",
      "Key": 1662,
      "Name": "Benoît Combemale"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1355,
      "Name": "Berkeley Churchill"
    },
    {
      "Affiliation": "NICTA & U New South Wales, Australia",
      "Bio": "",
      "Key": 1365,
      "Name": "Bernard Blackham"
    },
    {
      "Affiliation": "TU München, Germany",
      "Bio": "",
      "Key": 1637,
      "Name": "Bernd Brügge"
    },
    {
      "Affiliation": "Klopotek & Partner GmbH, Germany",
      "Bio": "",
      "Key": 1821,
      "Name": "Bernhard Dock"
    },
    {
      "Affiliation": "Viewpoints Research Institute, Germany",
      "Bio": "",
      "Key": 1719,
      "Name": "Bert Freudenberg"
    },
    {
      "Affiliation": "U Washington, USA",
      "Bio": "",
      "Key": 1636,
      "Name": "Bill Howe"
    },
    {
      "Affiliation": "JP Morgan Chase, USA",
      "Bio": "",
      "Key": 1213,
      "Name": "Bill Opdyke"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1797,
      "Name": "Binoy Ravindran"
    },
    {
      "Affiliation": "Texas A&M U, USA",
      "Bio": "",
      "Key": 1347,
      "Name": "Bjarne Stroustrup"
    },
    {
      "Affiliation": "Open U, Israel",
      "Bio": "",
      "Key": 1334,
      "Name": "Boaz Rosenan"
    },
    {
      "Affiliation": "College of William and Mary, USA",
      "Bio": "",
      "Key": 1361,
      "Name": "Boyang Li"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1368,
      "Name": "Brian Demsky"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1367,
      "Name": "Brian Norris"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1272,
      "Name": "Bruce W. Weide"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1280,
      "Name": "Bryan Shrader"
    },
    {
      "Affiliation": "Lawrence Berkeley National Lab, USA",
      "Bio": "",
      "Key": 1836,
      "Name": "Bryan Van Straalen"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1640,
      "Name": "Bryce Cronkite-Ratcliff"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1845,
      "Name": "Brynjar Magnússon"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1234,
      "Name": "Caitlin Sadowski"
    },
    {
      "Affiliation": "Sapienza U Rome, Italy",
      "Bio": "",
      "Key": 1391,
      "Name": "Camil Demetrescu"
    },
    {
      "Affiliation": "Heinrich Heine U Düsseldorf, Germany",
      "Bio": "",
      "Key": 1414,
      "Name": "Carl Friedrich Bolz"
    },
    {
      "Affiliation": "San Jose State U, USA",
      "Bio": "",
      "Key": 1570,
      "Name": "Cay Horstmann"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1292,
      "Name": "Chandra Krintz"
    },
    {
      "Affiliation": "KAIST, South Korea",
      "Bio": "",
      "Key": 1530,
      "Name": "Changhee Park"
    },
    {
      "Affiliation": "Clarkson U, USA",
      "Bio": "",
      "Key": 1295,
      "Name": "Chen Liu"
    },
    {
      "Affiliation": "Indian Institute of Technology, Delhi, India",
      "Bio": "",
      "Key": 1418,
      "Name": "Chinmay Narayan"
    },
    {
      "Affiliation": "U Wisconsin Eau Claire, USA",
      "Bio": "",
      "Key": 1792,
      "Name": "Chris Johnson"
    },
    {
      "Affiliation": "U Gothenberg, Sweden",
      "Bio": "",
      "Key": 1787,
      "Name": "Christian Berger"
    },
    {
      "Affiliation": "U Pennsylvania, USA",
      "Bio": "",
      "Key": 1471,
      "Name": "Christian DeLozier"
    },
    {
      "Affiliation": "Saarland U, Germany",
      "Bio": "",
      "Key": 1453,
      "Name": "Christian Hammer"
    },
    {
      "Affiliation": "Johannes Kepler U Linz, Austria",
      "Bio": "",
      "Key": 1599,
      "Name": "Christian Humer"
    },
    {
      "Affiliation": "U Vermont, USA",
      "Bio": "",
      "Key": 1756,
      "Name": "Christian Skalka"
    },
    {
      "Affiliation": "Oracle, USA",
      "Bio": "",
      "Key": 1552,
      "Name": "Christian Wimmer"
    },
    {
      "Affiliation": "U Twente, Netherlands",
      "Bio": "",
      "Key": 1203,
      "Name": "Christoph Bockisch"
    },
    {
      "Affiliation": "Vrije U Brussel, Netherlands",
      "Bio": "",
      "Key": 1766,
      "Name": "Christophe Scholliers"
    },
    {
      "Affiliation": "Ford Motor Company, USA",
      "Bio": "",
      "Key": 1271,
      "Name": "Christopher Dorman"
    },
    {
      "Affiliation": "Northeastern U, USA",
      "Bio": "",
      "Key": 1466,
      "Name": "Christos Dimoulas"
    },
    {
      "Affiliation": "Oak Ridge National Lab, USA",
      "Bio": "",
      "Key": 1848,
      "Name": "Christos Kartsaklis"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1764,
      "Name": "Claus Hunsen"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1215,
      "Name": "Clay Williams"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1566,
      "Name": "Clifford A. Shaffer"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1437,
      "Name": "Cristian Talau"
    },
    {
      "Affiliation": "National U Singapore, Singapore",
      "Bio": "",
      "Key": 1332,
      "Name": "Cristina David"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1309,
      "Name": "Cristina Lopes"
    },
    {
      "Affiliation": "Lawrence Berkeley National Lab, USA",
      "Bio": "",
      "Key": 1834,
      "Name": "Cy Chan"
    },
    {
      "Affiliation": "Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1642,
      "Name": "Cyrus Omar"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1816,
      "Name": "D. Jackson"
    },
    {
      "Affiliation": "UIUC, USA",
      "Bio": "",
      "Key": 1815,
      "Name": "D. Marinov"
    },
    {
      "Affiliation": "Free U Bolzano-Bozen, Italy",
      "Bio": "",
      "Key": 1275,
      "Name": "Dainius Jocas"
    },
    {
      "Affiliation": "U Central Florida, USA",
      "Bio": "",
      "Key": 1589,
      "Name": "Damian Dechev"
    },
    {
      "Affiliation": "U Washington, USA",
      "Bio": "",
      "Key": 1352,
      "Name": "Dan Grossman"
    },
    {
      "Affiliation": "Brazil",
      "Bio": "",
      "Key": 1590,
      "Name": "Daniel Cukier"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1604,
      "Name": "Daniel Jackson"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1433,
      "Name": "Daniel Patterson"
    },
    {
      "Affiliation": "Sapienza U Rome, Italy",
      "Bio": "",
      "Key": 1390,
      "Name": "Daniele C. D'Elia"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1747,
      "Name": "Danilo Ansaloni"
    },
    {
      "Affiliation": "U Illinois, USA",
      "Bio": "[Danny Dig](http://netfiles.uiuc.edu/dig/www) is a Principal Investigator in the Microsoft/Intel funded Universal Parallel Computing Research Center (UP- CRC) at the University of Illinois, where he leads research on refactorings for parallelism. He received his PhD from Illinois, where his dissertation won the best PhD thesis award. In 2006 he was awarded the First Prize at the interdisciplinary ACM Student Research Competition Grand Finals. After his PhD he was a postdoc at MIT where he opened the field of inter- active refactorings for retrofitting parallelism into sequential programs, before retuning to Illinois. Danny has authored 14 journal and top conference papers and has released 6 software systems, one of which was downloaded over 17,000 times, and others are shipping with the official release of Eclipse, a widely used development environment for Java. Danny started the ACM Workshop on Refactoring Tools, now in its 4th year, and served on the program committees for OOPSLA and several software engineering workshops.",
      "Key": 1865,
      "Name": "Danny Dig"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1700,
      "Name": "Danny M. Groenewegen"
    },
    {
      "Affiliation": "Worcester Polytechnic Institute & U Utah, USA",
      "Bio": "",
      "Key": 1535,
      "Name": "Danny Yoo"
    },
    {
      "Affiliation": "U Illinois Urbana Champaign, USA",
      "Bio": "",
      "Key": 1611,
      "Name": "Darko Marinov"
    },
    {
      "Affiliation": "Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1722,
      "Name": "Darya Kurilova"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1888,
      "Name": "David Brett"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1305,
      "Name": "David Grove"
    },
    {
      "Affiliation": "Open U, Israel",
      "Bio": "",
      "Key": 1333,
      "Name": "David H. Lorenz"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1768,
      "Name": "David Harmon Brett"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1594,
      "Name": "David Patterson"
    },
    {
      "Affiliation": "Victoria U Wellington, New Zealand",
      "Bio": "",
      "Key": 1692,
      "Name": "David Pearce"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1263,
      "Name": "David Ungar"
    },
    {
      "Affiliation": "U West London, UK",
      "Bio": "",
      "Key": 1724,
      "Name": "Dean Kramer"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1878,
      "Name": "Dean Mohamedally"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1877,
      "Name": "Dean Mohamedally,"
    },
    {
      "Affiliation": "Siemens, Austria",
      "Bio": "",
      "Key": 1728,
      "Name": "Deepak Dhungana"
    },
    {
      "Affiliation": "Marquette U, USA",
      "Bio": "",
      "Key": 1294,
      "Name": "Dennis Brylow"
    },
    {
      "Affiliation": "Alcatel-Lucent, USA",
      "Bio": "",
      "Key": 1211,
      "Name": "Dennis Mancl"
    },
    {
      "Affiliation": "U Waterloo, Canada",
      "Bio": "",
      "Key": 1723,
      "Name": "Derek Rayside"
    },
    {
      "Affiliation": "Indiana U - Purdue U Indianapolis (IUPUI), USA",
      "Bio": "",
      "Key": 1779,
      "Name": "Dimithu Gamage"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1282,
      "Name": "Dmitri Makarov"
    },
    {
      "Affiliation": "U Cambridge, UK",
      "Bio": "",
      "Key": 1827,
      "Name": "Dominic Orchard"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1852,
      "Name": "Dominik Charousset"
    },
    {
      "Affiliation": "U Koblenz-Landau, Germany",
      "Bio": "",
      "Key": 1695,
      "Name": "Dominik Mosen"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1307,
      "Name": "Don Batory"
    },
    {
      "Affiliation": "U Wisconsin Madison, USA",
      "Bio": "",
      "Key": 1442,
      "Name": "Dongdong Deng"
    },
    {
      "Affiliation": "Ioan Cuza U, Romania",
      "Bio": "",
      "Key": 1702,
      "Name": "Dorel Lucanu"
    },
    {
      "Affiliation": "SUNY Oswego, USA",
      "Bio": "",
      "Key": 1572,
      "Name": "Doug Lea"
    },
    {
      "Affiliation": "Oracle, USA",
      "Bio": "",
      "Key": 1600,
      "Name": "Doug Simon"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "Doug Schmidt is a Professor of Computer Science at Vanderbilt\nUniversity who has published 9 books and over 450 technical papers\nthat cover a range of research topics, including patterns,\noptimization techniques, and empirical analyses of software frameworks\nand domain-specific modeling environments that facilitate the\ndevelopment of distributed real-time and embedded (DRE) middleware and\napplications.  In addition to his academic research, Doug has over\nfifteen years of experience leading the development of ACE and TAO,\nwhich are widely used, open-source DRE middleware frameworks that\ncontain a rich set of components that implement patterns and\nproduct-line architectures for high-performance DRE systems.",
      "Key": 1583,
      "Name": "Douglas Schmidt"
    },
    {
      "Affiliation": "Vrije U Brussel, Belgium",
      "Bio": "",
      "Key": 1765,
      "Name": "Dries Harnie"
    },
    {
      "Affiliation": "Otterbein U, USA",
      "Bio": "",
      "Key": 1558,
      "Name": "Duane Buck"
    },
    {
      "Affiliation": "U Zürich, Switzerland",
      "Bio": "",
      "Key": 1244,
      "Name": "Dustin Wüest"
    },
    {
      "Affiliation": "State U Milan, Italy",
      "Bio": "",
      "Key": 1659,
      "Name": "Edoardo Vacchi"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1262,
      "Name": "Eelco Visser"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1844,
      "Name": "Ehsan Khamespanah"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1216,
      "Name": "Elham Khabiri"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1565,
      "Name": "Eli Tilevich"
    },
    {
      "Affiliation": "U London, UK",
      "Bio": "",
      "Key": 1669,
      "Name": "Elizabeth Scott"
    },
    {
      "Affiliation": "North Carolina State U, USA",
      "Bio": "",
      "Key": 1231,
      "Name": "Emerson Murphy-Hill"
    },
    {
      "Affiliation": "University of Sao Paulo, Brazil",
      "Bio": "",
      "Key": 1830,
      "Name": "Emilio Francesquini"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1606,
      "Name": "Emina Torlak"
    },
    {
      "Affiliation": "Lund U, Sweden",
      "Bio": "",
      "Key": 1704,
      "Name": "Emma Söderberg"
    },
    {
      "Affiliation": "Harvard U, USA",
      "Bio": "",
      "Key": 1562,
      "Name": "Emmanuel Schanzer"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1873,
      "Name": "Eric Anderson"
    },
    {
      "Affiliation": "New York U, USA",
      "Bio": "",
      "Key": 1420,
      "Name": "Eric Koskinen"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1554,
      "Name": "Eric Lin"
    },
    {
      "Affiliation": "Oracle, USA",
      "Bio": "",
      "Key": 1608,
      "Name": "Eric McCorkle"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1354,
      "Name": "Eric Schkufza"
    },
    {
      "Affiliation": "U Chile, Chile",
      "Bio": "",
      "Key": 1519,
      "Name": "Éric Tanter"
    },
    {
      "Affiliation": "U Minnesota, USA",
      "Bio": "",
      "Key": 1223,
      "Name": "Eric Van Wyk"
    },
    {
      "Affiliation": "U Chile, Chile",
      "Bio": "",
      "Key": 1517,
      "Name": "Esteban Allende"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1643,
      "Name": "Ethan Holder"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1491,
      "Name": "Etienne Kneuss"
    },
    {
      "Affiliation": "George Washington U, USA",
      "Bio": "",
      "Key": 1329,
      "Name": "Eugen Leontie"
    },
    {
      "Affiliation": "Sioux, Eindhoven, Netherlands",
      "Bio": "",
      "Key": 1683,
      "Name": "Eugen Schindler"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1465,
      "Name": "Eugene Burmako"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1867,
      "Name": "Eunjong Choi"
    },
    {
      "Affiliation": "Federal U Rio de Janeiro, Brazil",
      "Bio": "",
      "Key": 1731,
      "Name": "Fábio Basso"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1860,
      "Name": "Farnaz Behrang"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1782,
      "Name": "Faruk Caglar"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1762,
      "Name": "Felix Rieger"
    },
    {
      "Affiliation": "SUNY Buffalo, USA",
      "Bio": "",
      "Key": 1317,
      "Name": "Feng Shen"
    },
    {
      "Affiliation": "Federal U Pernambuco, Brazil",
      "Bio": "",
      "Key": 1344,
      "Name": "Fernando Castor-Filho"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1871,
      "Name": "Fernando Kenji Kamei"
    },
    {
      "Affiliation": "USA",
      "Bio": "",
      "Key": 1541,
      "Name": "Filip Pizlo"
    },
    {
      "Affiliation": "U Porto, Portugal",
      "Bio": "",
      "Key": 1239,
      "Name": "Filipe Correia"
    },
    {
      "Affiliation": "Federal U Campina Grande, Brazil",
      "Bio": "",
      "Key": 1733,
      "Name": "Flávio Medeiros"
    },
    {
      "Affiliation": "Virginia Tech , USA",
      "Bio": "",
      "Key": 1798,
      "Name": "Francesco Quaglia"
    },
    {
      "Affiliation": "INRIA, France",
      "Bio": "",
      "Key": 1455,
      "Name": "Francesco Zappa Nardelli"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1772,
      "Name": "Franz Schreiner"
    },
    {
      "Affiliation": "U Nice Sophia Antipolis, INRIA, France",
      "Bio": "",
      "Key": 1715,
      "Name": "Frederic Mallet"
    },
    {
      "Affiliation": "Fraunhofer FOKUS, Germany",
      "Bio": "",
      "Key": 1819,
      "Name": "Friederike Gutzeit"
    },
    {
      "Affiliation": "Fern U Hagen, Germany",
      "Bio": "",
      "Key": 1601,
      "Name": "Friedrich Steimann"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1560,
      "Name": "Gabi Zodik"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1698,
      "Name": "Gabriël D.P. Konat"
    },
    {
      "Affiliation": "Texas A&M U, USA",
      "Bio": "",
      "Key": 1346,
      "Name": "Gabriel Dos Reis"
    },
    {
      "Affiliation": "TU Delft, Netherlands",
      "Bio": "",
      "Key": 1680,
      "Name": "Gabriël Konat"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1885,
      "Name": "Gal Shachor"
    },
    {
      "Affiliation": "U Central Florida, USA",
      "Bio": "",
      "Key": 1544,
      "Name": "Gary Leavens"
    },
    {
      "Affiliation": "George Washington U, USA",
      "Bio": "",
      "Key": 1330,
      "Name": "Gedare Bloom"
    },
    {
      "Affiliation": "ETH Zurich, Switzerland",
      "Bio": "",
      "Key": 1736,
      "Name": "Georg Ofenbeck"
    },
    {
      "Affiliation": "U Athens, Greece",
      "Bio": "",
      "Key": 1398,
      "Name": "George Balatsouras"
    },
    {
      "Affiliation": "U Athens, Greece",
      "Bio": "",
      "Key": 1399,
      "Name": "George Kastrinis"
    },
    {
      "Affiliation": "Lawrence Berkeley National Lab, USA",
      "Bio": "",
      "Key": 1841,
      "Name": "George Michelogiannakis"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1481,
      "Name": "George Necula"
    },
    {
      "Affiliation": "Ben Gurion U Negev, Israel",
      "Bio": "",
      "Key": 1209,
      "Name": "Gera Weiss"
    },
    {
      "Affiliation": "NICTA & U New South Wales, Australia",
      "Bio": "",
      "Key": 1366,
      "Name": "Gernot Heiser"
    },
    {
      "Affiliation": "TU Wien, Austria",
      "Bio": "",
      "Key": 1658,
      "Name": "Gerti Kappel"
    },
    {
      "Affiliation": "Free U Bolzano-Bozen, Italy",
      "Bio": "",
      "Key": 1277,
      "Name": "Giancarlo Succi"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1249,
      "Name": "Gilad Bracha"
    },
    {
      "Affiliation": "Johannes Kepler U Linz, Austria",
      "Bio": "",
      "Key": 1598,
      "Name": "Gilles Duboscq"
    },
    {
      "Affiliation": "Software Engineering Institute, Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1561,
      "Name": "Grace Lewis"
    },
    {
      "Affiliation": "Mozilla Foundation, Canada",
      "Bio": "",
      "Key": 1252,
      "Name": "Greg Wilson"
    },
    {
      "Affiliation": "U British Columbia, Canada",
      "Bio": "",
      "Key": 1458,
      "Name": "Gregor Kiczales"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1246,
      "Name": "Gregor Richards"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1697,
      "Name": "Guido H. Wachsmuth"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1218,
      "Name": "Guido Salvaneschi"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1284,
      "Name": "Guido Wachsmuth"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1363,
      "Name": "Guoqing Xu"
    },
    {
      "Affiliation": "Federal U Pernambuco, Brazil",
      "Bio": "",
      "Key": 1320,
      "Name": "Gustavo Pinto"
    },
    {
      "Affiliation": "Lund U, Sweden",
      "Bio": "",
      "Key": 1705,
      "Name": "Görel Hedin"
    },
    {
      "Affiliation": "TU München, Germany",
      "Bio": "",
      "Key": 1618,
      "Name": "Han Xu"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1612,
      "Name": "Hannah Quay-de la Vallee"
    },
    {
      "Affiliation": "Chinese Academy of Sciences, China & U California Davis, USA",
      "Bio": "",
      "Key": 1395,
      "Name": "Hao Zhong"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1264,
      "Name": "Harold Ossher"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1842,
      "Name": "Haukur Kristinsson"
    },
    {
      "Affiliation": "TU Braunschweig, Germany",
      "Bio": "",
      "Key": 1802,
      "Name": "Hayder Al-Khalissi"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1464,
      "Name": "Heather Miller"
    },
    {
      "Affiliation": "Federal U Pernambuco, Brazil",
      "Bio": "",
      "Key": 1543,
      "Name": "Henrique Rebelo"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1546,
      "Name": "Hoan Nguyen"
    },
    {
      "Affiliation": "KAIST, South Korea",
      "Bio": "",
      "Key": 1531,
      "Name": "Hongki Lee"
    },
    {
      "Affiliation": "U Saskatchewan, Canada",
      "Bio": "",
      "Key": 1829,
      "Name": "Hongxing Geng"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1206,
      "Name": "Hridesh Rajan"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1649,
      "Name": "Hyoukjoong Lee"
    },
    {
      "Affiliation": "Raytheon Integrated Defense Systems, USA",
      "Bio": "",
      "Key": 1298,
      "Name": "Ian Goodsell"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1550,
      "Name": "Idan Ben-Harrush"
    },
    {
      "Affiliation": "HP, USA",
      "Bio": "",
      "Key": 1270,
      "Name": "Indrajit Roy"
    },
    {
      "Affiliation": "Software Engineering Institute, Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1580,
      "Name": "Ipek Ozkaya"
    },
    {
      "Affiliation": "Carl von Ossietzky U Oldenburg, Germany",
      "Bio": "",
      "Key": 1559,
      "Name": "Ira Diethelm"
    },
    {
      "Affiliation": "College of William and Mary, USA",
      "Bio": "",
      "Key": 1359,
      "Name": "Isil Dillig"
    },
    {
      "Affiliation": "Cutter Consortium",
      "Bio": "",
      "Key": 1285,
      "Name": "Israel Gat"
    },
    {
      "Affiliation": "U California Riverside, USA",
      "Bio": "",
      "Key": 1470,
      "Name": "Iulian Neamtiu"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1493,
      "Name": "Ivan Kuraj"
    },
    {
      "Affiliation": "Texas A&M U, USA",
      "Bio": "",
      "Key": 1214,
      "Name": "James Caverlee"
    },
    {
      "Affiliation": "Indiana U - Purdue U Indianapolis (IUPUI), USA",
      "Bio": "",
      "Key": 1780,
      "Name": "James H. Hill"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1613,
      "Name": "James M. Walsh"
    },
    {
      "Affiliation": "Victoria U Wellington, New Zealand",
      "Bio": "",
      "Key": 1507,
      "Name": "James Noble"
    },
    {
      "Affiliation": "Queen's U, Canada",
      "Bio": "",
      "Key": 1794,
      "Name": "James R. Cordy"
    },
    {
      "Affiliation": "Czech Technical U Prague, Czech Republic",
      "Bio": "",
      "Key": 1336,
      "Name": "Jan Hýbl"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1456,
      "Name": "Jan Vitek"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1761,
      "Name": "Janet Siegmund"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1521,
      "Name": "Jared Roesch"
    },
    {
      "Affiliation": "Intel, USA",
      "Bio": "",
      "Key": 1374,
      "Name": "Jaswanth Sreeram"
    },
    {
      "Affiliation": "U Nacional de Quilmes, Argentina",
      "Bio": "",
      "Key": 1809,
      "Name": "Javier Fernandes"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1233,
      "Name": "Jean Peccoud"
    },
    {
      "Affiliation": "Laboratoire d'Informatique de Grenoble, France",
      "Bio": "",
      "Key": 1832,
      "Name": "Jean-François Mehaut "
    },
    {
      "Affiliation": "IRISA, U Rennes, France",
      "Bio": "",
      "Key": 1740,
      "Name": "Jean-Marc Jézéquel"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1633,
      "Name": "Jeff Bezanson"
    },
    {
      "Affiliation": "U Alabama, USA",
      "Bio": "",
      "Key": 1202,
      "Name": "Jeff Gray"
    },
    {
      "Affiliation": "National Center for Supercomputing Applications, United States",
      "Bio": "",
      "Key": 1859,
      "Name": "Jeffrey Overbey"
    },
    {
      "Affiliation": "Free U Bozen-­Bolzano, Italy",
      "Bio": "",
      "Key": 1289,
      "Name": "Jelena Vlasenko"
    },
    {
      "Affiliation": "Ghent U, Belgium",
      "Bio": "",
      "Key": 1410,
      "Name": "Jennifer B. Sartor"
    },
    {
      "Affiliation": "U Oxford, UK",
      "Bio": "",
      "Key": 1625,
      "Name": "Jeremy Gibbons"
    },
    {
      "Affiliation": "U Colorado Boulder, USA",
      "Bio": "",
      "Key": 1220,
      "Name": "Jeremy Siek"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1378,
      "Name": "Jeroen Ketema"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1861,
      "Name": "Jillian Hall"
    },
    {
      "Affiliation": "North Carolina State U, USA",
      "Bio": "",
      "Key": 1639,
      "Name": "Jim Witschey"
    },
    {
      "Affiliation": "U Amsterdam, Netherlands",
      "Bio": "",
      "Key": 1688,
      "Name": "Jimi van der Woning"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1357,
      "Name": "Jipeng Huang"
    },
    {
      "Affiliation": "Rice U, USA",
      "Bio": "",
      "Key": 1422,
      "Name": "Jisheng Zhao"
    },
    {
      "Affiliation": "U Waterloo, Canada",
      "Bio": "",
      "Key": 1311,
      "Name": "Joanne Attlee"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1429,
      "Name": "Joe Gibbs Politz"
    },
    {
      "Affiliation": "U Bretagne Occidentale, France",
      "Bio": "",
      "Key": 1690,
      "Name": "Joël Champeau"
    },
    {
      "Affiliation": "Vrije Universiteit Brussel, Belgium",
      "Bio": "",
      "Key": 1837,
      "Name": "Joeri De Koster"
    },
    {
      "Affiliation": "U Saskatchewan, Canada",
      "Bio": "",
      "Key": 1325,
      "Name": "Joey Eremondi"
    },
    {
      "Affiliation": "U Chile, Chile",
      "Bio": "",
      "Key": 1518,
      "Name": "Johan Fabry"
    },
    {
      "Affiliation": "U Leipzig, Germany",
      "Bio": "",
      "Key": 1806,
      "Name": "Johannes Muller"
    },
    {
      "Affiliation": "U California Santa Barbara & Harvey Mudd College, USA",
      "Bio": "",
      "Key": 1537,
      "Name": "John Sarracino"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1538,
      "Name": "John Wagner"
    },
    {
      "Affiliation": "Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1221,
      "Name": "Jonathan Aldrich"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1626,
      "Name": "Jonathan Edwards"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1849,
      "Name": "Jonathan Ragan-Kelley"
    },
    {
      "Affiliation": "U Arizona, USA",
      "Bio": "",
      "Key": 1201,
      "Name": "Jonathan Sprinkle"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1864,
      "Name": "Jongwook Kim"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1826,
      "Name": "José Dominguez"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1224,
      "Name": "Judith Bishop"
    },
    {
      "Affiliation": "MetaCase, Finland",
      "Bio": "",
      "Key": 1200,
      "Name": "Juha-Pekka Tolvanen"
    },
    {
      "Affiliation": "U Nice Sophia Antipolis, INRIA, France",
      "Bio": "",
      "Key": 1713,
      "Name": "Julien Deantoni"
    },
    {
      "Affiliation": "IRISA, U Rennes, France",
      "Bio": "",
      "Key": 1739,
      "Name": "Julien Richard-Foy"
    },
    {
      "Affiliation": "Cisco Systems, USA",
      "Bio": "",
      "Key": 1578,
      "Name": "Junilu Lacar"
    },
    {
      "Affiliation": "China",
      "Bio": "",
      "Key": 1434,
      "Name": "Junsong Li"
    },
    {
      "Affiliation": "Centrum Wiskunde & Informatica, Netherlands",
      "Bio": "",
      "Key": 1222,
      "Name": "Jurgen Vinju"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1760,
      "Name": "Jörg Liebig"
    },
    {
      "Affiliation": "Chalmers U Technology, Sweden",
      "Bio": "",
      "Key": 1788,
      "Name": "Jörgen Hansson"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1257,
      "Name": "K. Rustan M. Leino"
    },
    {
      "Affiliation": "U Waterloo, Canada",
      "Bio": "",
      "Key": 1709,
      "Name": "Kacper Bak"
    },
    {
      "Affiliation": "Indian Institute of Science, India",
      "Bio": "",
      "Key": 1393,
      "Name": "Kanchi Gopinath"
    },
    {
      "Affiliation": "KTH Royal Institute of Technology, Stockholm, Sweden",
      "Bio": "",
      "Key": 1858,
      "Name": "Karl Palmskog"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1495,
      "Name": "Katherine E. Coons"
    },
    {
      "Affiliation": "U California Berkeley & LBNL, USA",
      "Bio": "",
      "Key": 1302,
      "Name": "Katherine Yelick"
    },
    {
      "Affiliation": "Worcester Polytechnic Institute, USA",
      "Bio": "",
      "Key": 1563,
      "Name": "Kathi Fisler"
    },
    {
      "Affiliation": "Tufts U, USA",
      "Bio": "",
      "Key": 1627,
      "Name": "Kathleen Fisher"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1501,
      "Name": "Kathryn S. McKinley"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1868,
      "Name": "Katsuro Inoue"
    },
    {
      "Affiliation": "Georgia Tech, USA",
      "Bio": "",
      "Key": 1400,
      "Name": "Kaushik Ravichandran"
    },
    {
      "Affiliation": "Facebook, USA",
      "Bio": "",
      "Key": 1269,
      "Name": "Keith Adams"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1362,
      "Name": "Ken McMillan"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1648,
      "Name": "Kevin Brown"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1630,
      "Name": "Kevin Buffardi"
    },
    {
      "Affiliation": "Vrije U Brussel, Belgium",
      "Bio": "",
      "Key": 1219,
      "Name": "Kevin Pinte"
    },
    {
      "Affiliation": "U Virginia, USA",
      "Bio": "",
      "Key": 1628,
      "Name": "Kevin Sullivan"
    },
    {
      "Affiliation": "Netherlands",
      "Bio": "",
      "Key": 1687,
      "Name": "Kevin van der Vlist"
    },
    {
      "Affiliation": "Pomona College, USA",
      "Bio": "",
      "Key": 1569,
      "Name": "Kim Bruce"
    },
    {
      "Affiliation": "U Marburg, Germany",
      "Bio": "",
      "Key": 1665,
      "Name": "Klaus Ostermann"
    },
    {
      "Affiliation": "Sioux, Eindhoven, Netherlands",
      "Bio": "",
      "Key": 1684,
      "Name": "Klemens Schindler"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1328,
      "Name": "Konstantin Shagin"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1482,
      "Name": "Koushik Sen"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1890,
      "Name": "Krishnendu Ghosh"
    },
    {
      "Affiliation": "Ghent U, Belgium",
      "Bio": "",
      "Key": 1409,
      "Name": "Kristof Du Bois"
    },
    {
      "Affiliation": "U Waterloo, Canada",
      "Bio": "",
      "Key": 1711,
      "Name": "Krzysztof Czarnecki"
    },
    {
      "Affiliation": "Adobe, USA",
      "Bio": "",
      "Key": 1248,
      "Name": "Krzysztof Palacz"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1721,
      "Name": "Kunle Olukotun"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1338,
      "Name": "Kyoungho An"
    },
    {
      "Affiliation": "Indiana U - Purdue U Indianapolis (IUPUI), USA",
      "Bio": "",
      "Key": 1319,
      "Name": "Lahiru Gallege"
    },
    {
      "Affiliation": "King's College London, UK",
      "Bio": "",
      "Key": 1416,
      "Name": "Laurence Tratt"
    },
    {
      "Affiliation": "McGill U, Canada",
      "Bio": "",
      "Key": 1534,
      "Name": "Laurie J. Hendren"
    },
    {
      "Affiliation": "U Illinois, USA",
      "Bio": "",
      "Key": 1278,
      "Name": "Laxmikant Kale"
    },
    {
      "Affiliation": "Federal U Santa Catarina, Brazil",
      "Bio": "",
      "Key": 1778,
      "Name": "Leandro B. Becker"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1369,
      "Name": "Leo Meyerovich"
    },
    {
      "Affiliation": "U Nacional de Quilmes, Argentina",
      "Bio": "",
      "Key": 1812,
      "Name": "Leonardo Gassman"
    },
    {
      "Affiliation": "Ghent U, Belgium",
      "Bio": "",
      "Key": 1412,
      "Name": "Lieven Eeckhout"
    },
    {
      "Affiliation": "Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1800,
      "Name": "Ligia Nistor"
    },
    {
      "Affiliation": "Victoria U Wellington, New Zealand",
      "Bio": "",
      "Key": 1693,
      "Name": "Lindsay Groves"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1477,
      "Name": "Lingming Zhang"
    },
    {
      "Affiliation": "Nanjing U, China",
      "Bio": "",
      "Key": 1485,
      "Name": "Lingzhang Wang"
    },
    {
      "Affiliation": "U Bretagne Occidentale, France",
      "Bio": "",
      "Key": 1691,
      "Name": "Loïc Lagadec"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1281,
      "Name": "Lorand Szakacs"
    },
    {
      "Affiliation": "U York, UK",
      "Bio": "",
      "Key": 1241,
      "Name": "Louis Rose"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1791,
      "Name": "Louis Wasserman"
    },
    {
      "Affiliation": "Peking U, China",
      "Bio": "",
      "Key": 1478,
      "Name": "Lu Zhang"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1744,
      "Name": "Lubomír Bulej"
    },
    {
      "Affiliation": "U Washington, USA",
      "Bio": "",
      "Key": 1351,
      "Name": "Luis Ceze"
    },
    {
      "Affiliation": "Heinrich Heine U Düsseldorf, Germany",
      "Bio": "",
      "Key": 1415,
      "Name": "Lukas Diekmann"
    },
    {
      "Affiliation": "Charles U, Czech Republic",
      "Bio": "",
      "Key": 1741,
      "Name": "Lukas Marek"
    },
    {
      "Affiliation": "Johannes Kepler U Linz, Austria",
      "Bio": "",
      "Key": 1597,
      "Name": "Lukas Stadler"
    },
    {
      "Affiliation": "SUNY Buffalo, USA",
      "Bio": "",
      "Key": 1238,
      "Name": "Lukasz Ziarek"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1304,
      "Name": "Luke Hoban"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1496,
      "Name": "Madanlal Musuvathi"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1520,
      "Name": "Madhukar Kedlaya"
    },
    {
      "Affiliation": "KTH Royal Institute of Technology, Stockholm, Sweden",
      "Bio": "",
      "Key": 1856,
      "Name": "Mads Dam"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1383,
      "Name": "Man Cao"
    },
    {
      "Affiliation": "IBM, India",
      "Bio": "",
      "Key": 1394,
      "Name": "Mangala Gowri Nanda"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1880,
      "Name": "Manoj Vaseekharan"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1441,
      "Name": "Manu Sridharan"
    },
    {
      "Affiliation": "TU Wien, Austria",
      "Bio": "",
      "Key": 1657,
      "Name": "Manuel Wimmer"
    },
    {
      "Affiliation": "Hasso Plattner Institute, U Potsdam , Germany",
      "Bio": "",
      "Key": 1528,
      "Name": "Marcel Weiher"
    },
    {
      "Affiliation": "Federal U Alagoas, Brazil",
      "Bio": "",
      "Key": 1734,
      "Name": "Màrcio Ribeiro "
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1795,
      "Name": "Marina Sadini"
    },
    {
      "Affiliation": "Ecole des Mines de Nantes, France",
      "Bio": "",
      "Key": 1237,
      "Name": "Mario Südholt"
    },
    {
      "Affiliation": "Oracle, USA",
      "Bio": "",
      "Key": 1267,
      "Name": "Mario Wolczko"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1847,
      "Name": "Marjan Sirjani"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1247,
      "Name": "Mark Miller"
    },
    {
      "Affiliation": "WU Vienna, Austria",
      "Bio": "",
      "Key": 1651,
      "Name": "Mark Strembeck"
    },
    {
      "Affiliation": "Eindhoven U Technology, Netherlands",
      "Bio": "",
      "Key": 1296,
      "Name": "Mark van den Brand"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1750,
      "Name": "Marko Martin"
    },
    {
      "Affiliation": "ETH Zürich, Switzerland",
      "Bio": "Markus P\u00fcschel is a Professor of Computer Science at ETH Zurich, Switzerland. Before, he was a Professor of Electrical and Computer Engineering at Carnegie Mellon University, where he still has an adjunct status. He received his Diploma (M.Sc.) in Mathematics and his Doctorate (Ph.D.) in Computer Science, in 1995 and 1998, respectively, both from the University of Karlsruhe, Germany. From 1998-1999 he was a Postdoctoral Researcher at Mathematics and Computer Science, Drexel University. From 2000-2010 he was with Carnegie Mellon University, and since 2010 he has been with ETH Zurich. He was an Associate Editor for the IEEE Transactions on Signal Processing, the IEEE Signal Processing Letters, was a Guest Editor of the Proceedings of the IEEE and the Journal of Symbolic Computation, and served on various program committees of conferences in computing, compilers, and programming languages. He is a recipient of the Outstanding Research Award of the College of Engineering at Carnegie Mellon and the Eta Kappa Nu Award for Outstanding Teaching. He also holds the title of Privatdozent at the University of Technology, Vienna, Austria. In 2009 he cofounded Spiralgen Inc.\r\n\r\nHis research interests include fast computing, algorithms, applied mathematics, and signal processing theory/software/hardware. ",
      "Key": 1738,
      "Name": "Markus Püschel"
    },
    {
      "Affiliation": "Germany",
      "Bio": "",
      "Key": 1674,
      "Name": "Markus Völter"
    },
    {
      "Affiliation": "U Zürich, Switzerland",
      "Bio": "",
      "Key": 1245,
      "Name": "Martin Glinz"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1438,
      "Name": "Martin Odersky"
    },
    {
      "Affiliation": "Sioux, Eindhoven, Netherlands",
      "Bio": "",
      "Key": 1682,
      "Name": "Martin Palatnik"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1463,
      "Name": "Martin Rinard"
    },
    {
      "Affiliation": "ETH Zurich, Switzerland",
      "Bio": "",
      "Key": 1440,
      "Name": "Martin Vechev"
    },
    {
      "Affiliation": "Wayne State U, USA",
      "Bio": "",
      "Key": 1556,
      "Name": "Marwan Abi-Antoun"
    },
    {
      "Affiliation": "U Utah, USA",
      "Bio": "",
      "Key": 1851,
      "Name": "Mary Hall"
    },
    {
      "Affiliation": "Yokohama National University",
      "Bio": "",
      "Key": 1316,
      "Name": "Masahiro Ide"
    },
    {
      "Affiliation": "U Nice Sophia Antipolis, INRIA, France",
      "Bio": "",
      "Key": 1714,
      "Name": "Matias Vara Larsen"
    },
    {
      "Affiliation": "U Nebraska Lincoln, USA",
      "Bio": "",
      "Key": 1629,
      "Name": "Matt Dwyer"
    },
    {
      "Affiliation": "U Utah, USA",
      "Bio": "",
      "Key": 1752,
      "Name": "Matthew Flatt"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1431,
      "Name": "Matthew Milano"
    },
    {
      "Affiliation": "Northeastern U, USA",
      "Bio": "",
      "Key": 1468,
      "Name": "Matthias Felleisen"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1261,
      "Name": "Matthias Hauswirth"
    },
    {
      "Affiliation": "U Freiburg, Germany",
      "Bio": "",
      "Key": 1524,
      "Name": "Matthias Keil"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1855,
      "Name": "Matthias Wählisch"
    },
    {
      "Affiliation": "U Leipzig, Germany",
      "Bio": "",
      "Key": 1805,
      "Name": "Max Lillack"
    },
    {
      "Affiliation": "Nanyang Technological U, Singapore",
      "Bio": "",
      "Key": 1232,
      "Name": "Max Schaefer"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1776,
      "Name": "Maximilian Schafzahl"
    },
    {
      "Affiliation": "Chalmers U Technology, Sweden",
      "Bio": "",
      "Key": 1786,
      "Name": "Md Abdullah Al Mamun"
    },
    {
      "Affiliation": "Qualcomm, USA",
      "Bio": "",
      "Key": 1523,
      "Name": "Mehrdad Reshadi"
    },
    {
      "Affiliation": "DSL Consultancy, Netherlands",
      "Bio": "",
      "Key": 1675,
      "Name": "Meinte Boersma"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1385,
      "Name": "Meisam Fathi Salmi"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1460,
      "Name": "Michael Bauer"
    },
    {
      "Affiliation": "North Carolina State U, USA",
      "Bio": "",
      "Key": 1645,
      "Name": "Michael Bazik"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1461,
      "Name": "Michael Carbin"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1358,
      "Name": "Michael D. Bond"
    },
    {
      "Affiliation": "Oracle, Germany",
      "Bio": "",
      "Key": 1204,
      "Name": "Michael Haupt"
    },
    {
      "Affiliation": "U Duisburg-Essen, Germany",
      "Bio": "",
      "Key": 1407,
      "Name": "Michael Hoppe"
    },
    {
      "Affiliation": "U Vermont, USA",
      "Bio": "",
      "Key": 1758,
      "Name": "Michael Watson"
    },
    {
      "Affiliation": "U Waterloo, Canada",
      "Bio": "",
      "Key": 1710,
      "Name": "Michal Antkiewicz"
    },
    {
      "Affiliation": "Colorado State U, USA",
      "Bio": "",
      "Key": 1846,
      "Name": "Michelle Strout"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1602,
      "Name": "Mikael Mayer"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1382,
      "Name": "Milind Kulkarni"
    },
    {
      "Affiliation": "U Pennsylvania, USA",
      "Bio": "",
      "Key": 1475,
      "Name": "Milo M. K. Martin"
    },
    {
      "Affiliation": "U Illinois Urbana Champaign, USA",
      "Bio": "",
      "Key": 1610,
      "Name": "Milos Gligoric"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1384,
      "Name": "Minjia Zhang"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1751,
      "Name": "Mira Mezini"
    },
    {
      "Affiliation": "TU Braunschweig, Germany",
      "Bio": "",
      "Key": 1804,
      "Name": "Mladen Berekovic"
    },
    {
      "Affiliation": "U California Los Angeles, USA",
      "Bio": "",
      "Key": 1488,
      "Name": "Mohsen Lesani"
    },
    {
      "Affiliation": "LogicBlox, USA",
      "Bio": "",
      "Key": 1266,
      "Name": "Molham Aref"
    },
    {
      "Affiliation": "Tel Aviv U, Israel",
      "Bio": "",
      "Key": 1421,
      "Name": "Mooly Sagiv"
    },
    {
      "Affiliation": "U Gothenberg, Sweden",
      "Bio": "",
      "Key": 1785,
      "Name": "Mozhan Soltani"
    },
    {
      "Affiliation": "Auburn University, United States",
      "Bio": "",
      "Key": 1857,
      "Name": "Munawar Hafiz"
    },
    {
      "Affiliation": "Clemson U, USA",
      "Bio": "",
      "Key": 1255,
      "Name": "Murali Sitaraman"
    },
    {
      "Affiliation": "U Saskatchewan, Canada",
      "Bio": "",
      "Key": 1207,
      "Name": "Nadeem Jamali"
    },
    {
      "Affiliation": "Siemens, Germany",
      "Bio": "",
      "Key": 1619,
      "Name": "Naoufel Boulila"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1375,
      "Name": "Nathan Chong"
    },
    {
      "Affiliation": "King's College London, UK",
      "Bio": "",
      "Key": 1670,
      "Name": "Naveneetha Vasudevan"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1445,
      "Name": "Nick Mitchell"
    },
    {
      "Affiliation": "U Nacional de Quilmes, Argentina",
      "Bio": "",
      "Key": 1808,
      "Name": "Nicolás Passerini "
    },
    {
      "Affiliation": "Nspyre, Netherlands",
      "Bio": "",
      "Key": 1299,
      "Name": "Niels Brouwers"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1508,
      "Name": "Nikhil Swamy"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1869,
      "Name": "Niklas Fors"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1225,
      "Name": "Nikolai Tillmann"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1884,
      "Name": "Nili Guy"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1887,
      "Name": "Niranjan Tulpule"
    },
    {
      "Affiliation": "U Magdeburg, Germany",
      "Bio": "",
      "Key": 1199,
      "Name": "Norbert Siegmund"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1866,
      "Name": "Norihiro Yoshida"
    },
    {
      "Affiliation": "McGill U, Canada",
      "Bio": "",
      "Key": 1533,
      "Name": "Nurudeen Lameed"
    },
    {
      "Affiliation": "Siemens, Germany",
      "Bio": "",
      "Key": 1620,
      "Name": "Oliver Creighton"
    },
    {
      "Affiliation": "IRISA, U Rennes, France",
      "Bio": "",
      "Key": 1716,
      "Name": "Olivier Barais"
    },
    {
      "Affiliation": "Tel Aviv U, Israel",
      "Bio": "",
      "Key": 1419,
      "Name": "Omer Tripp"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1303,
      "Name": "P. (Saday) Sadayappan"
    },
    {
      "Affiliation": "U Nacional de Oeste, Argentina",
      "Bio": "",
      "Key": 1811,
      "Name": "Pablo Tesone"
    },
    {
      "Affiliation": "U Bretagne Occidentale, France",
      "Bio": "",
      "Key": 1689,
      "Name": "Papa Issa Diallo"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1236,
      "Name": "Patrick Eugster"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1377,
      "Name": "Paul H.J. Kelly"
    },
    {
      "Affiliation": "Centrum Wiskunde & Informatica, Netherlands",
      "Bio": "",
      "Key": 1654,
      "Name": "Paul Klint"
    },
    {
      "Affiliation": "Software Engineering Institute, Carnegie Mellon U, USA",
      "Bio": "",
      "Key": 1256,
      "Name": "Paulo Merson"
    },
    {
      "Affiliation": "Icenetic, Spain",
      "Bio": "",
      "Key": 1681,
      "Name": "Pedro J. Molina"
    },
    {
      "Affiliation": "U Vermont, USA",
      "Bio": "",
      "Key": 1755,
      "Name": "Peter Chapin"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1446,
      "Name": "Peter F. Sweeney"
    },
    {
      "Affiliation": "U West London, UK",
      "Bio": "",
      "Key": 1727,
      "Name": "Peter Komisarczuk"
    },
    {
      "Affiliation": "U Wisconsin, USA",
      "Bio": "",
      "Key": 1644,
      "Name": "Peter Ohmann"
    },
    {
      "Affiliation": "U Freiburg, Germany",
      "Bio": "",
      "Key": 1525,
      "Name": "Peter Thiemann"
    },
    {
      "Affiliation": "U Pennsylvania, USA",
      "Bio": "",
      "Key": 1474,
      "Name": "Peter-Michael Osera"
    },
    {
      "Affiliation": "Charles U, Czech Republic",
      "Bio": "",
      "Key": 1745,
      "Name": "Petr Tuma"
    },
    {
      "Affiliation": "U Illinois, USA",
      "Bio": "",
      "Key": 1259,
      "Name": "Phil Miller"
    },
    {
      "Affiliation": "TU Wien, Austria",
      "Bio": "",
      "Key": 1656,
      "Name": "Philip Langer"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1862,
      "Name": "Philip Mayer"
    },
    {
      "Affiliation": "Typesafe, Switzerland",
      "Bio": "",
      "Key": 1268,
      "Name": "Philipp Haller"
    },
    {
      "Affiliation": "Johannes Kepler U, Linz, Austria",
      "Bio": "",
      "Key": 1318,
      "Name": "Philipp Lengauer"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1774,
      "Name": "Philipp Neidhöfer"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1889,
      "Name": "Philippe Dugerdil"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1494,
      "Name": "Philippe Suter"
    },
    {
      "Affiliation": "U Central Florida, USA",
      "Bio": "",
      "Key": 1587,
      "Name": "Pierre LaBorde"
    },
    {
      "Affiliation": "Cisco Systems, USA",
      "Bio": "",
      "Key": 1577,
      "Name": "Pradeep Kathail"
    },
    {
      "Affiliation": "U Athens, Greece",
      "Bio": "",
      "Key": 1427,
      "Name": "Prodromos Gerakios"
    },
    {
      "Affiliation": "U Colorado Colorado Springs, USA",
      "Bio": "",
      "Key": 1588,
      "Name": "Qing Yi"
    },
    {
      "Affiliation": "Wayne State U, USA",
      "Bio": "",
      "Key": 1555,
      "Name": "Radu Vanciu"
    },
    {
      "Affiliation": "Pontificia U Catolica, Brazil",
      "Bio": "",
      "Key": 1228,
      "Name": "Rafael Prikladnicki"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1353,
      "Name": "Rahul Sharma"
    },
    {
      "Affiliation": "George Washington U, USA",
      "Bio": "",
      "Key": 1331,
      "Name": "Rahul Simha"
    },
    {
      "Affiliation": "Indiana U - Purdue U Indianapolis (IUPUI), USA",
      "Bio": "",
      "Key": 1781,
      "Name": "Rajeev R. Raje"
    },
    {
      "Affiliation": "U Koblenz, Germany",
      "Bio": "",
      "Key": 1635,
      "Name": "Ralf Lämmel"
    },
    {
      "Affiliation": "Eindhoven U Technology, Netherlands",
      "Bio": "",
      "Key": 1297,
      "Name": "Ramon Schiffelers"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1854,
      "Name": "Raphael Hiesgen"
    },
    {
      "Affiliation": "Federal U Rio de Janeiro, Brazil",
      "Bio": "",
      "Key": 1732,
      "Name": "Raquel Pillat"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1293,
      "Name": "Ras Bodik"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1607,
      "Name": "Rastislav Bodik"
    },
    {
      "Affiliation": "Sioux, Eindhoven, Netherlands",
      "Bio": "",
      "Key": 1676,
      "Name": "Remi Bosman"
    },
    {
      "Affiliation": "U Gothenberg, Sweden",
      "Bio": "",
      "Key": 1784,
      "Name": "Retta Shiferaw Siyoum"
    },
    {
      "Affiliation": "Stony Brook U, USA",
      "Bio": "",
      "Key": 1850,
      "Name": "Rezaul Chowdhury"
    },
    {
      "Affiliation": "Federal U Pernambuco, Brazil",
      "Bio": "",
      "Key": 1545,
      "Name": "Ricardo Massa Lima"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1685,
      "Name": "Riccardo Solmi"
    },
    {
      "Affiliation": "Seattle U, USA",
      "Bio": "",
      "Key": 1573,
      "Name": "Rich LeBlanc"
    },
    {
      "Affiliation": "U Pennsylvania, USA",
      "Bio": "",
      "Key": 1472,
      "Name": "Richard A. Eisenberg"
    },
    {
      "Affiliation": "IBM, USA",
      "Bio": "",
      "Key": 1822,
      "Name": "Richard Gabriel"
    },
    {
      "Affiliation": "Intel, USA",
      "Bio": "",
      "Key": 1372,
      "Name": "Richard L. Hudson"
    },
    {
      "Affiliation": "Amsterdam U Applied Sciences, Netherlands",
      "Bio": "",
      "Key": 1653,
      "Name": "Riemer van Rozen"
    },
    {
      "Affiliation": "Australian National U, Australia",
      "Bio": "",
      "Key": 1404,
      "Name": "Rifat Shahriyar"
    },
    {
      "Affiliation": "Northwestern U, USA",
      "Bio": "",
      "Key": 1467,
      "Name": "Robert Bruce Findler"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1260,
      "Name": "Robert Dyer"
    },
    {
      "Affiliation": "Colorado State U, USA",
      "Bio": "",
      "Key": 1718,
      "Name": "Robert France"
    },
    {
      "Affiliation": "Hasso Plattner Institute, U Potsdam, Germany",
      "Bio": "",
      "Key": 1529,
      "Name": "Robert Hirschfeld"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1423,
      "Name": "Roberto Lublinerman"
    },
    {
      "Affiliation": "USA",
      "Bio": "",
      "Key": 1273,
      "Name": "Roberto Salama"
    },
    {
      "Affiliation": "U British Columbia, Canada",
      "Bio": "",
      "Key": 1457,
      "Name": "Robin Salkeld"
    },
    {
      "Affiliation": "Federal U Campina Grande, Brazil",
      "Bio": "",
      "Key": 1735,
      "Name": "Rohit Gheyi"
    },
    {
      "Affiliation": "Czech Technical U Prague, Czech Republic",
      "Bio": "",
      "Key": 1335,
      "Name": "Roman Štrobl"
    },
    {
      "Affiliation": "U Nacional de Quilmes, Argentina",
      "Bio": "",
      "Key": 1810,
      "Name": "Ronny De Jesus"
    },
    {
      "Affiliation": "Cornell University, USA",
      "Bio": "",
      "Key": 1833,
      "Name": "Ross Tate"
    },
    {
      "Affiliation": "U California Los Angeles, USA",
      "Bio": "",
      "Key": 1489,
      "Name": "Rupak Majumdar"
    },
    {
      "Affiliation": "TU München, Germany",
      "Bio": "",
      "Key": 1621,
      "Name": "Ruth Demmel"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1504,
      "Name": "Ryder Ziola"
    },
    {
      "Affiliation": "AdaCore, USA",
      "Bio": "",
      "Key": 1254,
      "Name": "S. Tucker Taft"
    },
    {
      "Affiliation": "McMaster U, Canada",
      "Bio": "",
      "Key": 1707,
      "Name": "Sahar Kokaly"
    },
    {
      "Affiliation": "U California Los Angeles, USA",
      "Bio": "",
      "Key": 1487,
      "Name": "Sai Deep Tetali"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1301,
      "Name": "Saman Amarasinghe"
    },
    {
      "Affiliation": "U West London, UK",
      "Bio": "",
      "Key": 1725,
      "Name": "Samia Oussena"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1886,
      "Name": "Samuel Kallner"
    },
    {
      "Affiliation": "TU Braunschweig, Germany",
      "Bio": "",
      "Key": 1759,
      "Name": "Sandro Schulze"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1603,
      "Name": "Santiago Perez De Rosso"
    },
    {
      "Affiliation": "Rutgers U, USA",
      "Bio": "",
      "Key": 1473,
      "Name": "Santosh Nagarakatte"
    },
    {
      "Affiliation": "Georgia Tech, USA",
      "Bio": "",
      "Key": 1401,
      "Name": "Santosh Pande"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1479,
      "Name": "Sarfraz Khurshid"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1462,
      "Name": "Sasa Misailovic"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1265,
      "Name": "Satnam Singh"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1448,
      "Name": "Scott Saponas"
    },
    {
      "Affiliation": "Johns Hopkins U, USA",
      "Bio": "",
      "Key": 1757,
      "Name": "Scott Smith"
    },
    {
      "Affiliation": "George Washington U, USA",
      "Bio": "",
      "Key": 1321,
      "Name": "Scotty Smith"
    },
    {
      "Affiliation": "Microsoft, China",
      "Bio": "",
      "Key": 1605,
      "Name": "Sean McDirmid"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1279,
      "Name": "Sean Mooney"
    },
    {
      "Affiliation": "Stanford U, USA",
      "Bio": "",
      "Key": 1459,
      "Name": "Sean Treichler"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1591,
      "Name": "Sebastian Burckhardt"
    },
    {
      "Affiliation": "TU Darmstadt, Germany",
      "Bio": "",
      "Key": 1664,
      "Name": "Sebastian Erdweg"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1763,
      "Name": "Sergiy Kolesnikov"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1825,
      "Name": "Shaileen C. Pokress"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1881,
      "Name": "Shaileen Pokress"
    },
    {
      "Affiliation": "U Wisconsin Madison, USA",
      "Bio": "",
      "Key": 1444,
      "Name": "Shan Lu"
    },
    {
      "Affiliation": "Google, USA",
      "Bio": "",
      "Key": 1235,
      "Name": "Shane Markstrum"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1783,
      "Name": "Shashank Shekhar"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1379,
      "Name": "Shaz Qadeer"
    },
    {
      "Affiliation": "U Tokyo, Japan",
      "Bio": "",
      "Key": 1638,
      "Name": "Shigeru Chiba"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1882,
      "Name": "Shinichi Shiraishi"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1300,
      "Name": "Shoaib Kamil"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1306,
      "Name": "Shriram Krishnamurthi"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1874,
      "Name": "Sihan Li"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1568,
      "Name": "Simin Hall"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1879,
      "Name": "Siri Vinay"
    },
    {
      "Affiliation": "U Alabama, USA",
      "Bio": "",
      "Key": 1322,
      "Name": "Songqing Yue"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1498,
      "Name": "Sophia Drossopoulou"
    },
    {
      "Affiliation": "U California Irvine, USA",
      "Bio": "",
      "Key": 1553,
      "Name": "Stefan Brunthaler"
    },
    {
      "Affiliation": "U Marburg, Germany",
      "Bio": "",
      "Key": 1663,
      "Name": "Stefan Fehrenbach"
    },
    {
      "Affiliation": "U Duisburg-Essen, Germany",
      "Bio": "",
      "Key": 1408,
      "Name": "Stefan Hanenberg"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1634,
      "Name": "Stefan Karpinski"
    },
    {
      "Affiliation": "Software Languages Lab, Vrije Universiteit Brussel, Belgium",
      "Bio": "",
      "Key": 1838,
      "Name": "Stefan Marr"
    },
    {
      "Affiliation": "WU Vienna, Austria",
      "Bio": "",
      "Key": 1650,
      "Name": "Stefan Sobernig"
    },
    {
      "Affiliation": "Intel, USA",
      "Bio": "",
      "Key": 1371,
      "Name": "Stephan Herhut"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1631,
      "Name": "Stephen Edwards"
    },
    {
      "Affiliation": "Williams College, USA",
      "Bio": "",
      "Key": 1571,
      "Name": "Stephen Freund"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1742,
      "Name": "Stephen Kell"
    },
    {
      "Affiliation": "Australian National U, Australia",
      "Bio": "",
      "Key": 1283,
      "Name": "Stephen M. Blackburn"
    },
    {
      "Affiliation": "U Pennsylvania, USA",
      "Bio": "",
      "Key": 1476,
      "Name": "Steve Zdancewic"
    },
    {
      "Affiliation": "Cisco Systems, USA",
      "Bio": "",
      "Key": 1212,
      "Name": "Steven D. Fraser"
    },
    {
      "Affiliation": "U Central Florida, USA",
      "Bio": "",
      "Key": 1585,
      "Name": "Steven Feldman"
    },
    {
      "Affiliation": "MetaCase, Finland",
      "Bio": "",
      "Key": 1230,
      "Name": "Steven Kelly"
    },
    {
      "Affiliation": "Ghent U, Belgium",
      "Bio": "",
      "Key": 1411,
      "Name": "Stijn Eyerman"
    },
    {
      "Affiliation": "KAIST, South Korea",
      "Bio": "",
      "Key": 1532,
      "Name": "Sukyoung Ryu"
    },
    {
      "Affiliation": "Real-Time Innovations, USA",
      "Bio": "",
      "Key": 1341,
      "Name": "Sumant Tambe"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1432,
      "Name": "Sumner Warren"
    },
    {
      "Affiliation": "Indian Institute of Science & IBM, India",
      "Bio": "",
      "Key": 1392,
      "Name": "Suparna Bhattacharya"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1454,
      "Name": "Suresh Jagannathan"
    },
    {
      "Affiliation": "INRIA, France",
      "Bio": "",
      "Key": 1661,
      "Name": "Suresh Pillay"
    },
    {
      "Affiliation": "U Passau, Germany",
      "Bio": "",
      "Key": 1754,
      "Name": "Sven Apel"
    },
    {
      "Affiliation": "Rice U, USA",
      "Bio": "",
      "Key": 1425,
      "Name": "Swarat Chaudhuri"
    },
    {
      "Affiliation": "Ohio State U, USA",
      "Bio": "",
      "Key": 1386,
      "Name": "Swarnendu Biswas"
    },
    {
      "Affiliation": "Imperial College London, UK",
      "Bio": "",
      "Key": 1497,
      "Name": "Sylvan Clebsch"
    },
    {
      "Affiliation": "Free U Bozen-­Bolzano, Italy",
      "Bio": "",
      "Key": 1286,
      "Name": "Tadas Remencius"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1339,
      "Name": "Takayuki Kuroda"
    },
    {
      "Affiliation": "TU Wien, Austria",
      "Bio": "",
      "Key": 1655,
      "Name": "Tanja Mayerhofer"
    },
    {
      "Affiliation": "U California Riverside, USA",
      "Bio": "",
      "Key": 1469,
      "Name": "Tanzirul Azim"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1402,
      "Name": "Tao Bao"
    },
    {
      "Affiliation": "North Carolina State U, USA",
      "Bio": "",
      "Key": 1875,
      "Name": "Tao Xie"
    },
    {
      "Affiliation": "Intel, USA",
      "Bio": "",
      "Key": 1373,
      "Name": "Tatiana Shpeisman"
    },
    {
      "Affiliation": "Viewpoints Research Institute, USA",
      "Bio": "",
      "Key": 1616,
      "Name": "Ted Kaehler"
    },
    {
      "Affiliation": "U Bergen, Norway",
      "Bio": "",
      "Key": 1672,
      "Name": "Tero Hasu"
    },
    {
      "Affiliation": "Vrije Universiteit Brussel, Belgium",
      "Bio": "",
      "Key": 1839,
      "Name": "Theo D'Hondt"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1505,
      "Name": "Thomas Ball"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1853,
      "Name": "Thomas C. Schmidt"
    },
    {
      "Affiliation": "College of William and Mary, USA",
      "Bio": "",
      "Key": 1360,
      "Name": "Thomas Dillig"
    },
    {
      "Affiliation": "ETH Zürich, Switzerland",
      "Bio": "",
      "Key": 1381,
      "Name": "Thomas Gross"
    },
    {
      "Affiliation": "Oracle, Austria",
      "Bio": "",
      "Key": 1595,
      "Name": "Thomas Würthinger"
    },
    {
      "Affiliation": "U Porto, Portugal",
      "Bio": "",
      "Key": 1582,
      "Name": "Tiago Boldt Sousa"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1291,
      "Name": "Tiark Rompf"
    },
    {
      "Affiliation": "Iowa State U, USA",
      "Bio": "",
      "Key": 1547,
      "Name": "Tien Nguyen"
    },
    {
      "Affiliation": "Centrum Wiskunde & Informatica (CWI), Netherlands",
      "Bio": "",
      "Key": 1673,
      "Name": "Tijs van der Storm"
    },
    {
      "Affiliation": "Fraunhofer FOKUS, Germany",
      "Bio": "",
      "Key": 1818,
      "Name": "Timo Wegeler"
    },
    {
      "Affiliation": "Federal U Rio de Janeiro, Brazil",
      "Bio": "",
      "Key": 1777,
      "Name": "Toacy C. Oliveira"
    },
    {
      "Affiliation": "U California Los Angeles, USA",
      "Bio": "",
      "Key": 1490,
      "Name": "Todd Millstein"
    },
    {
      "Affiliation": "Microsoft, USA",
      "Bio": "",
      "Key": 1503,
      "Name": "Todd Mytkowicz"
    },
    {
      "Affiliation": "U Washington, USA",
      "Bio": "",
      "Key": 1350,
      "Name": "Tom Bergan"
    },
    {
      "Affiliation": "McMaster U, Canada",
      "Bio": "",
      "Key": 1708,
      "Name": "Tom Maibaum"
    },
    {
      "Affiliation": "Vrije Universiteit Brussel, Belgium",
      "Bio": "",
      "Key": 1840,
      "Name": "Tom Van Cutsem"
    },
    {
      "Affiliation": "Purdue U, Czech Republic",
      "Bio": "",
      "Key": 1542,
      "Name": "Tomas Kalibera"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1567,
      "Name": "Tony Allevato"
    },
    {
      "Affiliation": "Middlesex U, UK",
      "Bio": "",
      "Key": 1726,
      "Name": "Tony Clark"
    },
    {
      "Affiliation": "U Leipzig, Germany",
      "Bio": "",
      "Key": 1807,
      "Name": "Ulrich Eisenecker"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1551,
      "Name": "Uzy Hadad"
    },
    {
      "Affiliation": "Wayne State U, USA",
      "Bio": "",
      "Key": 1253,
      "Name": "Václav Rajlich"
    },
    {
      "Affiliation": "Centrum Wiskunde & Informatica, Netherlands",
      "Bio": "",
      "Key": 1666,
      "Name": "Vadim Zaytsev"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1775,
      "Name": "Valentin Rock"
    },
    {
      "Affiliation": "ETH Zürich, Switzerland",
      "Bio": "",
      "Key": 1439,
      "Name": "Veselin Raychev"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1771,
      "Name": "Vesna Krnjic"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1492,
      "Name": "Viktor Kuncak"
    },
    {
      "Affiliation": "Max Planck Institute for Software Systems (MPI-SWS), Germany",
      "Bio": "",
      "Key": 1417,
      "Name": "Viktor Vafeiadis"
    },
    {
      "Affiliation": "U California Santa Barbara, USA",
      "Bio": "",
      "Key": 1536,
      "Name": "Vineeth Kashyap"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1767,
      "Name": "Violetta Vylegzhanina"
    },
    {
      "Affiliation": "MIT, USA",
      "Bio": "",
      "Key": 1632,
      "Name": "Viral Shah"
    },
    {
      "Affiliation": "Rice U, USA",
      "Bio": "",
      "Key": 1426,
      "Name": "Vivek Sarkar"
    },
    {
      "Affiliation": "Delft U Technology, Netherlands",
      "Bio": "",
      "Key": 1699,
      "Name": "Vlad A. Vergu"
    },
    {
      "Affiliation": "Ioan Cuza U, Romania",
      "Bio": "",
      "Key": 1703,
      "Name": "Vlad Rusu"
    },
    {
      "Affiliation": "EPFL, Switzerland",
      "Bio": "",
      "Key": 1436,
      "Name": "Vlad Ureche"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1686,
      "Name": "Vlad Vergu"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1746,
      "Name": "Walter Binder"
    },
    {
      "Affiliation": "State U Milan, Italy",
      "Bio": "",
      "Key": 1660,
      "Name": "Walter Cazzola"
    },
    {
      "Affiliation": "U Wisconsin Madison, USA",
      "Bio": "",
      "Key": 1443,
      "Name": "Wei Zhang"
    },
    {
      "Affiliation": "U Texas Austin, USA",
      "Bio": "",
      "Key": 1622,
      "Name": "William Cook"
    },
    {
      "Affiliation": "JP Morgan Chase, USA",
      "Bio": "",
      "Key": 1579,
      "Name": "William Opdyke"
    },
    {
      "Affiliation": "Brown U, USA",
      "Bio": "",
      "Key": 1614,
      "Name": "William Zimrin"
    },
    {
      "Affiliation": "Vrije U Brussel, Belgium",
      "Bio": "",
      "Key": 1217,
      "Name": "Wolfgang De Meuter"
    },
    {
      "Affiliation": "Graz U Technology, Austria",
      "Bio": "",
      "Key": 1773,
      "Name": "Wolfgang Slany"
    },
    {
      "Affiliation": "U California Berkeley, USA",
      "Bio": "",
      "Key": 1480,
      "Name": "Wontae Choi"
    },
    {
      "Affiliation": "North Carolina State U, USA",
      "Bio": "",
      "Key": 1326,
      "Name": "Xi Ge"
    },
    {
      "Affiliation": "Australian National U, Australia",
      "Bio": "",
      "Key": 1502,
      "Name": "Xi Yang"
    },
    {
      "Affiliation": "Purdue U, USA",
      "Bio": "",
      "Key": 1403,
      "Name": "Xiangyu Zhang"
    },
    {
      "Affiliation": "College of William and Mary, USA",
      "Bio": "",
      "Key": 1506,
      "Name": "Xipeng Shen"
    },
    {
      "Affiliation": "Nanjing U, China",
      "Bio": "",
      "Key": 1486,
      "Name": "Xuandong Li"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1229,
      "Name": "Yael Dubinsky"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1872,
      "Name": "Yael Dubinsky,"
    },
    {
      "Affiliation": "U Athens, Greece",
      "Bio": "",
      "Key": 1397,
      "Name": "Yannis Smaragdakis"
    },
    {
      "Affiliation": "NICTA & U New South Wales, Australia",
      "Bio": "",
      "Key": 1364,
      "Name": "Yao Shi"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1327,
      "Name": "Yishai A. Feldman"
    },
    {
      "Affiliation": "",
      "Bio": "",
      "Key": 1883,
      "Name": "Yoav Rubin"
    },
    {
      "Affiliation": "Viewpoints Research Institute, USA",
      "Bio": "",
      "Key": 1312,
      "Name": "Yoshiki Ohshima"
    },
    {
      "Affiliation": "IBM, Israel",
      "Bio": "",
      "Key": 1549,
      "Name": "Yossi Mesika"
    },
    {
      "Affiliation": "Nanjing U, China",
      "Bio": "",
      "Key": 1483,
      "Name": "You Li"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1323,
      "Name": "Young-Woo Kwon"
    },
    {
      "Affiliation": "U Lugano, Switzerland",
      "Bio": "",
      "Key": 1743,
      "Name": "Yudi Zheng"
    },
    {
      "Affiliation": "Rice U, USA",
      "Bio": "",
      "Key": 1641,
      "Name": "Yunming Zhang"
    },
    {
      "Affiliation": "Texas A&M U, USA",
      "Bio": "",
      "Key": 1345,
      "Name": "Yuriy Solodkyy"
    },
    {
      "Affiliation": "U Victoria, Canada",
      "Bio": "",
      "Key": 1823,
      "Name": "Yvonne Coady"
    },
    {
      "Affiliation": "Vanderbilt U, USA",
      "Bio": "",
      "Key": 1584,
      "Name": "Zach McCormick"
    },
    {
      "Affiliation": "Virginia Tech, USA",
      "Bio": "",
      "Key": 1324,
      "Name": "Zalia Shams"
    },
    {
      "Affiliation": "Czech Technical U Prague, Czech Republic",
      "Bio": "",
      "Key": 1499,
      "Name": "Zdenek Tronícek"
    },
    {
      "Affiliation": "U California Davis, USA",
      "Bio": "",
      "Key": 1396,
      "Name": "Zhendong Su"
    },
    {
      "Affiliation": "Indiana U Bloomington, USA",
      "Bio": "",
      "Key": 1789,
      "Name": "Zheng Dong"
    },
    {
      "Affiliation": "McMaster U, Canada",
      "Bio": "",
      "Key": 1706,
      "Name": "Zinovy Diskin"
    },
    {
      "Affiliation": "Rice U, USA",
      "Bio": "",
      "Key": 1424,
      "Name": "Zoran Budimlic"
    }
  ],
  "Location": "Indianapolis, Indiana, USA",
  "MultiTrack": true,
  "SocialFeeds": [
    {
      "Name": "Plaxo",
      "URL": "http://splash2013.plaxogroups.com/"
    },
    {
      "Name": "Facebook",
      "URL": "https://www.facebook.com/SPLASHCon"
    },
    {
      "Name": "LinkedIn",
      "URL": "http://www.linkedin.com/groups?mostPopular=&gid=2487082"
    },
    {
      "Name": "Twitter",
      "Keywords": [
        "splascon"
      ],
      "URL": "http://twitter.com/splashcon"
    }
  ],
  "SessionPriorities": [
    "Keynotes",
    "OOPSLA",
    "Onward!",
    "Wavefront",
    "Onward! Essays",
    "Wavefront Experience",
    "DLS",
    "GPCE",
    "SLE",
    "SPLASH-E",
    "SPLASH-I",
    "Panels",
    "Workshops",
    "Tutorials",
    "Demonstrations",
    "Posters",
    "Doctoral Symposium",
    "ACM SRC",
    "SPLASH Steering Committee",
    "Registration",
    "Social Events",
    "Announcements",
    "Onward! Steering Committee"
  ],
  "Name": "SPLASH 2013",
  "DataRevision": 4,
  "Items": [
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 862,
      "URL": null,
      "Title": "Saturday"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1223,
        1222
      ],
      "Abstract": "Parsing @ SLE is a new workshop on Parsing Programming Languages. The\r\nintended participants are the authors of parser generation tools and\r\nparsers for programming languages and other software languages. For\r\nthe purpose of this workshop \"parsing\" is a computation that takes a\r\nsequence of characters as input and produces a tree or graph shaped\r\nmodel as output. This possibly includes tokenization using regular\r\nexpressions, deriving trees using context- free grammars, mapping to\r\nabstract syntax trees and even semantic analysis.\r\n\r\nThe goal of the workshop is to bring together today's experts in the\r\nfield of parsing, in order to explore open questions and possibly\r\nforge new collaborations. The topics may include algorithms,\r\nimplementation and generation techniques, syntax and semantics of meta\r\nformalisms (BNF), etc. We expect to attract participants that have\r\nbeen or are developing theory, techniques and tools in the broad area\r\nof parsing non-natural languages such as programming languages.",
      "Key": 706,
      "URL": "http://www.planet-sl.org/parsing-at-sle2013",
      "Title": "Parsing @ SLE"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1311
      ],
      "Abstract": "There is little research on interfaces for features. In FOSD, work on feature modularity has focused on features as a criterion for system decomposition and assembly. The concept of feature modularity pertains mainly to cohesion of features, including language or modelling support for coalescing all information related to a feature into a single module. There is no information hiding among them, and they can directly refer to or override one another. Alternatively, in the feature-interaction literature, feature modules are black boxes that have inputs and outputs, but otherwise share no information. Such extreme information hiding facilitates third-party development of features, but makes it difficult to specify intended interactions, such as when a feature extends or overrides the behaviour of another feature. This talk proposes a compromise, in which features share a limited amount of information with each other by means of a feature interface. It looks at what such an interface might look like, and explores to what degree inter-feature references can be abstracted to references to features' public interfaces.\r\n",
      "Key": 944,
      "URL": "http://www.fosd.de/2013/",
      "Title": "FOSD — Can Features Have Interfaces?"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1198,
        1199
      ],
      "Abstract": "Feature orientation is an emerging paradigm of software\r\ndevelopment. It supports the automatic generation of large-scale\r\nsoftware systems from a set of units of functionality called\r\nfeatures. The key idea of feature-oriented software development (FOSD)\r\nis to emphasize the similarities of a family of software systems for a\r\ngiven application domain (e.g., database systems, banking software,\r\ntext processing systems) with the goal of reusing software artifacts\r\namong the family members. Features distinguish different members of\r\nthe family. A feature is a unit of functionality that satisfies a\r\nrequirement, represents a design decision, and provides a potential\r\nconfiguration option. A challenge in FOSD is that a feature does not\r\nmap cleanly to an isolated module of code. Rather it may affect (\"cut\r\nacross\") many components/artifacts of a software system. Furthermore,\r\nthe decomposition of a software system into its features gives rise to\r\na combinatorial explosion of possible feature combinations and\r\ninteractions. Research on FOSD has shown that the concept of features\r\npervades all phases of the software life cycle and requires a proper\r\ntreatment in terms of analysis, design, and programming techniques,\r\nmethods, languages, and tools, as well as formalisms and theory.",
      "Key": 698,
      "URL": "http://www.fosd.de/2013/",
      "Title": "FOSD — Fifth International Workshop on Feature-Oriented Software Development"
    },
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 863,
      "URL": null,
      "Title": "Sunday"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1312
      ],
      "Abstract": "The software for today's personal computing environments has become so complex that no single person can understand an entire system. Our approach to reduce complexity is to create \"meta-languages\" that allow us to make and experiment with new domain specific languages. With these new languages, we can describe different parts of systems in cleaner and more intention-revealing ways. As a notable example, a new stream-processing language called Nile was invented. The syntax of Nile allows a fully-featured vector graphics engine called Gezira to be written in a clean, mathematical manner in less than 500 lines of code. As one of the \"next steps\", one of the directions we are taking is to incorporate the idea of using multiple constraint solvers to build a system. Solvers can help stronger \"negotiation\" between objects and languages, and help the system to be written in a more declarative manner. Another direction is to take the idea of loose-coupling to the next level; objects should not know about the other objects directly but should always negotiate and \"find\" other objects.\r\n",
      "Key": 945,
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Toward the future of personal computing system construction"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1307
      ],
      "Abstract": "",
      "Key": 955,
      "URL": "http://program-transformation.org/GPCE13",
      "Title": "SLE/GPCE — Dark Knowledge and Graph Grammars in Automated Software Design"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1220,
        1221,
        1306
      ],
      "Abstract": "The search for sound principles for object-oriented languages has\r\ngiven rise to considerable research during the last few decades,\r\nleading to a better understanding of the key concepts of\r\nobject-oriented languages and to important developments in type\r\ntheory, semantics, program verification, and program development. The\r\npurpose of this workshop is to provide a forum for discussing new\r\nideas in the foundations of object-oriented languages and provide\r\nfeedback to authors. Submissions to this workshop were invited in the\r\ngeneral area of foundations of object-oriented languages, including\r\nintegration with other paradigms and extensions, such as aspects,\r\ncomponents, and meta-programming. FOOL is a 1-day workshop that\r\nincludes presentations of accepted papers as well as invited speakers\r\nand other technical sessions. FOOL does not have formal proceedings,\r\nto enable authors to present preliminary work that they wish to later\r\npublish formally in a conference venue.",
      "Key": 705,
      "URL": "http://fool2013.cs.brown.edu/",
      "Title": "FOOL — 20th International Workshop on Foundations of Object-Oriented Languages"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1210,
        1208,
        1209,
        1207
      ],
      "Abstract": "> *ago, agis, egi, actum,* **agere**\r\n\r\n> latin verb meaning to act, to lead, to do, common root for actors and agents\r\n\r\nThe fundamental turn of software into concurrency and distribution is\r\nnot only a matter of performance, but also of design and\r\nabstraction. It calls for programming paradigms that, compared to\r\ncurrent mainstream ones, would allow us to think about, design,\r\ndevelop, execute, debug, and profile - more naturally - systems\r\nexhibiting different degrees of concurrency, asynchrony, and physical\r\ndistribution. To this purpose, the AGERE! workshop is aimed at\r\nfocusing on programming systems, languages and applications based on\r\nactors, agents and other programming paradigms promoting a\r\ndecentralized-control mindset in solving problems and developing\r\nsoftware. The workshop is designed to cover both the theory and the\r\npractice of design and programming, bringing together researchers\r\nworking on the models, languages and technologies, and practitioners\r\ndeveloping real-world systems and applications.",
      "Key": 701,
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Programming based on Actors, Agents, and Decentralized Control (Day 1)"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1202,
        1201,
        1230
      ],
      "Abstract": "An upward shift in abstraction leads to a corresponding increase in\r\nproductivity. In the past this has occurred when programming languages\r\nhave evolved towards a higher level of abstraction. Today,\r\ndomain-specific languages provide a viable solution for continuing to\r\nraise the level of abstraction beyond coding, making development\r\nfaster and easier.\r\n\r\nIn Domain-Specific Modeling (DSM), the models are constructed using\r\nconcepts that represent things in the application domain, not concepts\r\nof a given programming language. The modeling language follows the\r\ndomain abstractions and semantics, allowing developers to perceive\r\nthemselves as working directly with domain concepts. Together with\r\nframeworks and platforms, DSM can automate a large portion of software\r\nproduction. Some possible topics for submission to the workshop\r\ninclude:\r\n\r\n* Industry/academic experience reports\r\n* Creation of metamodel-based languages\r\n* Novel approaches for code generation from domain-specific models\r\n* Evolution of languages\r\n* Metamodeling frameworks and languages\r\n* Tools for creating and using DSM languages",
      "Key": 699,
      "URL": "http://www.dsmforum.org/events/DSM13/",
      "Title": "DSM — Domain-Specific Modeling"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1231,
        1232
      ],
      "Abstract": "Refactoring is the process of improving a program's internal structure\r\nwithout changing its external behavior by applying behavior-preserving\r\ntransformations, themselves known as refactorings. While refactoring\r\nis widely accepted as an indispensable part of the modern software\r\ndeveloper's toolbox, manual refactoring is known to be tedious and\r\nerror-prone: it is often hard to tell whether a transformation will\r\nactually preserve program behavior, and refactorings often require\r\nmany changes throughout the program. Consequently, tool support for\r\nrefactoring has attracted a lot of interest both in industry and in\r\nacademia, and most modern IDEs ship with built-in support for\r\nrefactoring.\r\n\r\nWRT will bring together researchers and developers of refactoring\r\ntools to share new ideas and practical insights, discuss challenges\r\nand solutions, and together shape the future of refactoring. Topics of\r\ninterest include, but are by no means limited to, refactoring tools\r\nfor new domains, novel interface paradigms, and refactoring for\r\npreviously unsupported languages.",
      "Key": 709,
      "URL": "http://refactoring.info/WRT13/",
      "Title": "WRT — Workshop on Refactoring Tools"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1302,
        1303,
        1301,
        1300
      ],
      "Abstract": "Stencil computations describe a computational pattern that occurs in a wide variety of computing applications, from scientific simulations and solvers to image processing and filtering. Though conceptually simple, these computations have been traditionally difficult for general compilers to optimize, due to their difficult-to-analyze dependence structure and because the computations span many domains, each with different requirements for optimization. As a result, much effort has gone into creating strategies for optimizing these computations, including new compiler transformations, cache oblivious algorithms, and several domain-specific languages and compilers, along with software support systems including stencil-specific libraries and frameworks. This workshop aims to create a discussion between the many efforts to optimize stencil computations as well as the various domains that could benefit from these efforts, in order to evaluate the current state-of-the-art as well as pushing new research ideas influenced by the target domains. To ensure a high-quality level of discussion, the mini-conference will consist of invited papers from the various stakeholders interested in stencil applications and optimizations, from a variety of institutions, followed by discussion sessions to synthesize lessons learned.",
      "Key": 757,
      "URL": "http://people.csail.mit.edu/skamil/wosc/",
      "Title": "WOSC — Workshop on Optimizing Stencil Computations"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1505
      ],
      "Abstract": "[TouchDevelop](http://www.touchdevelop.com) is a programming environment that provides high-level abstractions to enable the creation of scripts on and for touch-based devices that access web services.  TouchDevelop has four main components: a statically typed scripting language with novel abstractions to support (a) stateless GUIs with support for live programming and (b) replicated data for collaborative applications; a browser-hosted touch-based integrated development environment that makes it possible to productively create small scripts with a single finger on a variety of devices; a set of high-level APIs to make it easy to access device sensors/resources and web services; a cloud back-end that enables a social approach to software development. In this talk, I\u2019ll show how TouchDevelop is being used in education and then dig into the language abstractions and run-time support for live programming and replicated data, as well as the research opportunities opened up by hosting a software environment in the cloud.",
      "Key": 947,
      "URL": "http://pear.sfsu.edu/promoto2013/",
      "Title": "PROMOTO — TouchDevelop: Productive Scripting on and for Touch-based Devices and Web Services"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1226,
        1224,
        1225
      ],
      "Abstract": "PROMOTO 2013: Programming for Mobile and Touch\r\n\r\nWe are experiencing a technology shift: Powerful and easy-to-use\r\nmobile devices like smartphones and tablets are becoming more\r\nprevalent than traditional PCs and laptops. The languages of today\r\nreflect the platforms of yesterday, providing abstractions that fit\r\nthe capabilities of a standard PC.\r\n\r\nIn this workshop, we want to bring together researchers who have been\r\nexploring new programming paradigms, embracing the new realities of\r\nalways connected, touch-enabled mobile devices. How should we enter\r\ncode without a keyboard? What are simple ways of programming for\r\nsensors? How do manage program code and data without a file system,\r\nand intermittent network connections? Submissions for this event are\r\ninvited in the general area of mobile and touch-oriented programming\r\nlanguages and programming environments, and teaching of programming\r\nfor mobile devices. This year, we would especially like to invite\r\ncontributions covering educational aspects, approaches and insights,\r\nas students are more likely than ever to own a personal computing\r\ndevice. Papers are welcome that discuss introductory and advanced\r\ncourses.",
      "Key": 707,
      "URL": "http://pear.sfsu.edu/promoto2013/",
      "Title": "PROMOTO — Programming for Mobile and Touch"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1508
      ],
      "Abstract": "Enabling the mixture of dynamically and statically type-safe code, gradual type systems have gained prominence in the past decade, both through research languages like Racket and industrial languages like C#. Now, with the advent of TypeScript and Closure, gradual typing has come to JavaScript. However, JavaScript's unusually flexible semantics makes it hard to provide gradual type-safety. Indeed, both Closure and TypeScript's type systems are intentionally unsound.\r\n\r\nIn this talk, I will present ongoing work at Microsoft Research on TS*, a gradually typed surface language on top of JavaScript. Its type system has the distinctive feature of providing safety guarantees even when TS* programs are composed with arbitrary, untrusted JavaScript. To achieve this, TS* provides a new gradual typing discipline, one that includes not one, but two types to classify dynamically typed code: the type Any is for dynamically type-safe TS* expressions, while the type Un is for dynamically typed, but potentially adversarial, JavaScript expressions.\r\n\r\nSo far, we have programmed several small security-critical libraries in TS* and deployed them after compilation to JavaScript. Our experience suggests that web-security idioms that developers currently program in JavaScript (with much difficulty and still with dubious results) can instead be coded naturally in TS*, retaining a flavor of idiomatic JavaScript, while providing, by virtue of our type system, strong safety guarantees.",
      "Key": 946,
      "URL": "http://fool2013.cs.brown.edu",
      "Title": "FOOL — TS*: Gradual Typing Embedded Securely in JavaScript"
    },
    {
      "Type": "SLE",
      "Authors": [
        1652,
        1651,
        1650
      ],
      "Abstract": "",
      "Key": 976,
      "URL": null,
      "Title": "Developing a Domain-specific Language for Scheduling in the European Energy Sector"
    },
    {
      "Type": "SLE",
      "Authors": [
        1654,
        1653
      ],
      "Abstract": "",
      "Key": 977,
      "URL": null,
      "Title": "Micro-Machinations: A DSL for Game Economies"
    },
    {
      "Type": "SLE",
      "Authors": [
        1658,
        1657,
        1656,
        1655
      ],
      "Abstract": "",
      "Key": 978,
      "URL": null,
      "Title": "xMOF: Executable DSMLs based on fUML"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1762,
        1664
      ],
      "Abstract": "Extensible programming languages such as SugarJ or Racket en-\r\nable programmers to introduce customary language features as ex-\r\ntensions of the base language. Traditionally, systems that support\r\nlanguage extensions are either (i) agnostic to the base language or\r\n(ii) only support a single base language. In this paper, we present\r\na framework for language extensibility that turns a non-extensible\r\nlanguage into an extensible language featuring library-based exten-\r\nsible syntax, extensible static analyses, and extensible editor sup-\r\nport. To make a language extensible, our framework only requires\r\nknowledge of the base language\u2019s grammar, the syntax for import\r\nstatements (which activate extensions), and how to compile base-\r\nlanguage programs. We have evaluated the generality of our frame-\r\nwork by instantiating it for Java, Haskell, Prolog, JavaScript, and\r\nSystem F? , and by studying existing module-system features and\r\ntheir support in our framework.\r\n",
      "Key": 1017,
      "URL": null,
      "Title": "A Framework for Extensible Languages"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1752
      ],
      "Abstract": "In an extensible programming language, programmers write code\r\nthat must run at different times\u2014in particular, at compile time\r\nversus run time. The module system of the Racket programming\r\nlanguage enables a programmer to reason about programs in the\r\nface of such extensibility, because the distinction between run-\r\ntime and compile-time phases is built into the language model.\r\nSubmodules extend Racket\u2019s module system to make the phase-\r\nseparation facet of the language extensible. That is, submodules\r\ngive programmers the capability to define new phases, such as \u201ctest\r\ntime\u201d or \u201cdocumentation time,\u201d with the same reasoning and code-\r\nmanagement benefits as the built-in distinction between run time\r\nand compile time.\r\n",
      "Key": 1011,
      "URL": null,
      "Title": "Submodules in Racket: You Want it When, Again?"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1206,
        1260,
        1547
      ],
      "Abstract": "Software repositories contain a vast wealth of information about\r\nsoftware development. Mining these repositories has proven useful\r\nfor detecting patterns in software development, testing hypotheses\r\nfor new software engineering approaches, etc. Specifically, mining\r\nsource code has yielded significant insights into software develop-\r\nment artifacts and processes. Unfortunately, mining source code at\r\na large-scale remains a difficult task. Previous approaches had to\r\neither limit the scope of the projects studied, limit the scope of the\r\nmining task to be more coarse-grained, or sacrifice studying the his-\r\ntory of the code due to both human and computational scalability\r\nissues. In this paper we address the substantial challenges of min-\r\ning source code: a) at a very large scale; b) at a fine-grained level\r\nof detail; and c) with full history information.\r\n\r\nTo address these challenges, we present domain-specific lan-\r\nguage features for source code mining. Our language features are\r\ninspired by object-oriented visitors and provide a default depth-\r\nfirst traversal strategy along with two expressions for defining cus-\r\ntom traversals. We provide an implementation of these features in\r\nthe Boa infrastructure for software repository mining and describe\r\na code generation strategy into Java code. To show the usability\r\nof our domain-specific language features, we reproduced over 40\r\nsource code mining tasks from two large-scale previous studies in\r\njust 2 person-weeks. The resulting code for these tasks show be-\r\ntween 2.0x\u20134.8x reduction in code size. Finally we perform a small\r\ncontrolled experiment to gain insights into how easily mining tasks\r\nwritten using our language features can be understood, with no\r\nprior training. We show a substantial number of tasks (77%) were\r\nunderstood by study participants, in about 3 minutes per task.\r\n",
      "Key": 1015,
      "URL": null,
      "Title": "Declarative Visitors to Ease Fine-grained Source Code Mining with Full History on Billions of AST Nodes"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1569
      ],
      "Abstract": "This is the twentieth anniversary of FOOL! Looking back, Kim Bruce will talk about FOOL over the years.\r\n",
      "Key": 958,
      "URL": "http://fool2013.cs.brown.edu",
      "Title": "FOOL Invited Talk — FOOL @ 20"
    },
    {
      "Type": "SLE",
      "Authors": [
        1662,
        1659,
        1661,
        1660
      ],
      "Abstract": "",
      "Key": 979,
      "URL": null,
      "Title": "Variability Support in Domain-Specific Language Development"
    },
    {
      "Type": "SLE",
      "Authors": [
        1665,
        1664,
        1663
      ],
      "Abstract": "",
      "Key": 980,
      "URL": null,
      "Title": "Software Evolution to Domain-Specific Languages"
    },
    {
      "Type": "SLE",
      "Authors": [
        1666
      ],
      "Abstract": "",
      "Key": 981,
      "URL": null,
      "Title": "Micropatterns in Grammars"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1347,
        1346,
        1345
      ],
      "Abstract": "Pattern matching is an abstraction mechanism that can greatly sim- \r\nplify source code. We present functional-style pattern matching for \r\nC++ implemented as a library, called Mach7 . All the patterns are \r\nuser-definable, can be stored in variables, passed among functions, \r\n  and allow the use of class hierarchies. As an example, we imple- \r\n  ment common patterns used in functional languages. \r\n\r\nOur approach to pattern matching is based on compile-time \r\ncomposition of pattern objects through concepts. This is superior \r\n(in terms of performance and expressiveness) to approaches based \r\non run-time composition of polymorphic pattern objects. In partic- \r\nular, our solution allows mapping functional code based on pattern \r\nmatching directly into C++ and produces code that is only a few \r\npercent slower than hand-optimized C++ code. \r\n\r\nThe library uses an efficient type switch construct, further ex- \r\ntending it to multiple scrutinees and general patterns. We compare \r\nthe performance of pattern matching to that of double dispatch and \r\nopen multi-methods in C++. \r\n",
      "Key": 1019,
      "URL": null,
      "Title": "Open Pattern Matching for C++"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1750,
        1751,
        1664
      ],
      "Abstract": "Reuse of and abstraction over object initialization logic is not prop-\r\nerly supported in mainstream object-oriented languages. This may\r\nresult in significant amount of boilerplate code and proliferation of\r\nconstructors in subclasses. It also makes it impossible for mixins\r\nto extend the initialization interface of classes they are applied to.\r\nWe propose template constructors, which employ template param-\r\neters and pattern matching of them against signatures of superclass\r\nconstructors to enable a one-to-many binding of super-calls. We\r\ndemonstrate how template constructors solve the aforementioned\r\nproblems. We present a formalization of the concept, a Java-based\r\nimplementation, and use cases which exercise its strengths.\r\n",
      "Key": 1010,
      "URL": null,
      "Title": "Template Constructors for Reusable Object Initialization"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1740,
        1739,
        1716
      ],
      "Abstract": "Writing large Web applications is known to be difficult. One chal-\r\nlenge comes from the fact that the application\u2019s logic is scattered\r\ninto heterogeneous clients and servers, making it difficult to share\r\ncode between both sides or to move code from one side to the other.\r\nAnother challenge is performance: while Web applications rely on\r\never more code on the client-side, they may run on smart phones\r\nwith limited hardware capabilities. These two challenges raise the\r\nfollowing problem: how to benefit from high-level languages and\r\nlibraries making code complexity easier to manage and abstract-\r\ning over the clients and servers differences without trading this\r\nease of engineering for performance? This article presents high-\r\nlevel abstractions defined as deep embedded DSLs in Scala that can\r\ngenerate efficient code leveraging the characteristics of both client\r\nand server environments. We compare performance on client-side\r\nagainst other candidate technologies and against hand written low-\r\nlevel JavaScript code. Though code written with our DSL has a\r\nhigh level of abstraction, our benchmark on a real world applica-\r\ntion reports that it runs as fast as hand tuned low-level JavaScript\r\ncode.\r\n",
      "Key": 1007,
      "URL": null,
      "Title": "Efficient High-Level Abstractions for Web Programming"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1428,
        1427,
        1397
      ],
      "Abstract": "Java generics are compiled by-erasure: all clients reuse the same\r\nbytecode, with uses of the unknown type erased. C++ templates are\r\ncompiled by-expansion: each type-instantiation of a template pro-\r\nduces a different code definition. The two approaches offer trade-\r\noffs on multiple axes. We propose an extension of Java generics\r\nthat allows by-expansion translation relative to selected type pa-\r\nrameters only. This language design allows sophisticated users to\r\nget the best of both worlds at a fine granularity. Furthermore, our\r\nproposal is based on Java 8 Type Annotations (JSR 308) and the\r\nChecker Framework as an abstraction layer for controlling compi-\r\nlation without changes to the internals of a Java compiler.\r\n",
      "Key": 1014,
      "URL": null,
      "Title": "Reified Type Parameters Using Java Annotations"
    },
    {
      "Type": "SLE",
      "Authors": [
        1668,
        1667,
        1669,
        1222,
        1296
      ],
      "Abstract": "",
      "Key": 982,
      "URL": null,
      "Title": "Safe Specification of Operator Precedence Rules"
    },
    {
      "Type": "SLE",
      "Authors": [
        1416,
        1670
      ],
      "Abstract": "",
      "Key": 983,
      "URL": null,
      "Title": "Detecting ambiguity in programming language grammars"
    },
    {
      "Type": "SLE",
      "Authors": [
        1671,
        1672
      ],
      "Abstract": "",
      "Key": 984,
      "URL": null,
      "Title": "A Pretty Good Formatting Pipeline"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1761,
        1760,
        1759,
        1754
      ],
      "Abstract": "The C preprocessor (CPP) is a simple and language-independent\r\ntool, widely used to implement variable software systems using\r\nconditional compilation (i.e., by including or excluding annotated\r\ncode). Although CPP provides powerful means to express variabil-\r\nity, it has been criticized for allowing arbitrary annotations that\r\nbreak the underlying structure of the source code. We distinguish\r\nbetween disciplined annotations, which align with the structure of\r\nthe source code, and undisciplined annotations, which do not. Sev-\r\neral studies suggest that especially the latter type of annotations\r\nmakes it hard to (automatically) analyze the code. However, lit-\r\ntle is known about whether the type of annotations has an effect\r\non program comprehension. We address this issue by means of a\r\ncontrolled experiment with human subjects. We designed similar\r\ntasks for both, disciplined and undisciplined annotations, to mea-\r\nsure program comprehension. Then, we measured the performance\r\nof the subjects regarding correctness and response time for solv-\r\ning the tasks. Our results suggest that there are no differences be-\r\ntween disciplined and undisciplined annotations from a program-\r\ncomprehension perspective. Nevertheless, we observed that finding\r\nand correcting errors is a time-consuming and tedious task in the\r\npresence of preprocessor annotations.\r\n",
      "Key": 1016,
      "URL": null,
      "Title": "Does the Discipline of Preprocessor Annotations Matter? A Controlled Experiment"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1733,
        1734,
        1735
      ],
      "Abstract": "The C preprocessor is commonly used to implement variability in\r\nprogram families. Despite the widespread usage, some studies indi-\r\ncate that the C preprocessor makes variability implementation dif-\r\nficult and error-prone. However, we still lack studies to investigate\r\npreprocessor-based syntax errors and quantify to what extent they\r\noccur in practice. In this paper, we define a technique based on a\r\nvariability-aware parser to find syntax errors in releases and com-\r\nmits of program families. To investigate these errors, we perform an\r\nempirical study where we use our technique in 41 program family\r\nreleases, and more than 51 thousand commits of 8 program fam-\r\nilies. We find 7 and 20 syntax errors in releases and commits of\r\nprogram families, respectively. They are related not only to incom-\r\nplete annotations, but also to complete ones. We submit 8 patches\r\nto fix errors that developers have not fixed yet, and they accept 75%\r\nof them. Our results reveal that the time developers need to fix the\r\nerrors varies from days to years in family repositories. We detect\r\nerrors even in releases of well-known and widely used program\r\nfamilies, such as Bash, CVS and Vim. We also classify the syntax\r\nerrors into 6 different categories. This classification may guide de-\r\nvelopers to avoid them during development.\r\n",
      "Key": 1005,
      "URL": null,
      "Title": "Investigating Preprocessor-Based Syntax Errors"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1724,
        1727,
        1725,
        1726
      ],
      "Abstract": "Dynamic Software Product Line (DSPL) Engineering has gained\r\ninterest through its promise of being able to unify software adap-\r\ntation whereby software adaptation can be realised at compile time\r\nand runtime. While previous work has enabled program logic adap-\r\ntation by the use of language extensions and platform support, little\r\nattention has been placed on Graphical User Interface (GUI) vari-\r\nability. Different design patterns including the Model View Con-\r\ntroller are commonly used in GUI implementation, with GUI doc-\r\numents being used for declaring the GUI. To handle dynamic GUI\r\nvariability currently, the developer needs to implement GUI refine-\r\nments using multiple techniques. This paper proposes a solution for\r\ndealing with GUI document variability, statically and dynamically,\r\nin a unified way. In our approach, we currently use a compile time\r\nmethod for producing GUI variants, and code transformations to\r\nhandle these variants within the application at runtime. To avoid\r\nGUI duplicates, only GUI variants that are unique, and related to\r\na valid product configuration, are produced. To validate our ap-\r\nproach, we implemented tool support to enable this for Android\r\nbased applications.\r\n",
      "Key": 1002,
      "URL": null,
      "Title": "Using Document-Oriented GUIs in Dynamic Software Product Lines"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1213
      ],
      "Abstract": "",
      "Key": 1087,
      "URL": "",
      "Title": "WRT Keynote — Refactoring, Reuse & Reality: Revisited"
    },
    {
      "Type": "Social Events",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 931,
      "URL": null,
      "Title": "GPCE/SLE/Workshops Reception"
    },
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 864,
      "URL": null,
      "Title": "Monday"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1238
      ],
      "Abstract": "",
      "Key": 956,
      "URL": null,
      "Title": "Welcome"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [

      ],
      "Abstract": "Two-minute teasers",
      "Key": 957,
      "URL": null,
      "Title": "Elevator Talks"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1293
      ],
      "Abstract": "A good model of a biological cell exposes secrets of the cell's signaling mechanisms, explaining diseases and facilitating drug discovery. Modeling cells is fundamentally a programming problem &mdash; it's programming because the model is a concurrent program that simulates the cell, and it's a problem because it is hard to write a program that reproduces all experimental observations of the cell faithfully.\r\n\r\nIn this talk, I will introduce solver-aided programming languages and show how they ease modeling biology as well as make programming accessible to non-programmers. Solver-aided languages come with constructs that delegate part of the programming problem to a constraint solver, which can be guided to synthesize parts of the program, localize its bugs, or act as a clairvoyant oracle.\r\n\r\nI will describe our work on synthesis of stem cell models in c. elegans and then show how our framework called Rosette can rapidly implement a solver aided language in several domains, from programming by demonstration to spatial parallel programming.",
      "Key": 954,
      "URL": "http://program-transformation.org/GPCE13",
      "Title": "GPCE/SLE — Modeling Biology with Solver-Aided Programming Languages"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1605
      ],
      "Abstract": "Live programming is emerging as the next big step in programming environments that will finally allow us to move beyond our stodgy Smalltalk-era IDEs into a more programmer-friendly future. However, existing live programming experiences are still not very useful\u2014they dazzle us with live feedback but that feedback does not really help us write code! In this talk, I first show how live programming can instead be re-cast as a fusion of editing and debugging at the same time\u2014and in the same space\u2014so that live execution feedback can be quickly applied to edits. Although live programming demos are really cool, they are also quite shallow: can these experiences really be achieved in practice? Implementing live programming systems is the ultimate reactive programming challenging as our changing input is code to be executed! The second part of this talk overcomes these challenges by automating the repair of general-purpose (imperative) programs through dirty techniques that eschew global dependency graphs and topological sorting. Our programming model, Glitch, embraces temporary inconsistencies by re-executing program parts until consistency is achieved. Glitch supports expressive shared-state procedural programming, but with one caveat: operations on shared state must be undoable and commutative to ensure re-execution efficiency and eventual consistency. I show how this is good enough to implement a live programming system (compiler and all) as well as serving as a programming model for a live programming language.\r\n",
      "Key": 998,
      "URL": "",
      "Title": "REM — Making Live Programming Real"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1352,
        1572,
        1573,
        1571
      ],
      "Abstract": "",
      "Key": 905,
      "URL": "",
      "Title": "Panel — Curriculum 2013: What’s new and how do we adapt?"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1564,
        1566,
        1565,
        1568,
        1567
      ],
      "Abstract": "Computing is becoming increasingly distributed. To better prepare students for the challenges of the workplace, computing educators need to introduce issues pertaining to distributed computing. Unfortunately, programming projects in introductory classes are mostly divorced from the students day-to-day computing experiences. These experiences entail interacting with real-time Web-based data from sources including weather reports, news updates, and restaurant recommendations. The disconnect between student experience and the content of their programming projects is known to drive some students away from computing. To address this problem, we have created an architectural framework that makes real-time web data accessible for introductory programming projects. The framework effectively introduces important real-time distributed computing concepts without overwhelming them with the low-level details that working with such data typically requires. Our preliminary results indicate that our approach can be effective in the context of a typical CS 2 data structures class. We are currently working on extending, improving, and fine tuning our toolchain to make our framework accessible to other classes in the curriculum.",
      "Key": 902,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/splash13.acbart.final2.pdf",
      "Title": "Transforming Introductory Computer Science Projects via Real-Time Web Data"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1306
      ],
      "Abstract": "Numerous languages now compile to JavaScript, and its ubiquity in the browser seems to make this inevitable. However, JavaScript appears to be a mediocre target for language deployment, erecting both obvious and subtle obstacles. I will discuss some of these issues, especially drawing on our experiences deploying Racket in the browser.",
      "Key": 950,
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — JavaScript as an Intermediate Language"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1210,
        1208,
        1209,
        1207
      ],
      "Abstract": "> *ago, agis, egi, actum,* **agere**\r\n\r\n> latin verb meaning to act, to lead, to do, common root for actors and agents\r\n\r\nThe fundamental turn of software into concurrency and distribution is\r\nnot only a matter of performance, but also of design and\r\nabstraction. It calls for programming paradigms that, compared to\r\ncurrent mainstream ones, would allow us to think about, design,\r\ndevelop, execute, debug, and profile - more naturally - systems\r\nexhibiting different degrees of concurrency, asynchrony, and physical\r\ndistribution. To this purpose, the AGERE! workshop is aimed at\r\nfocusing on programming systems, languages and applications based on\r\nactors, agents and other programming paradigms promoting a\r\ndecentralized-control mindset in solving problems and developing\r\nsoftware. The workshop is designed to cover both the theory and the\r\npractice of design and programming, bringing together researchers\r\nworking on the models, languages and technologies, and practitioners\r\ndeveloping real-world systems and applications.",
      "Key": 712,
      "URL": "http://agents.usask.ca/agere2013",
      "Title": "AGERE! — Programming based on Actors, Agents, and Decentralized Control (Day 2)"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1295,
        1294
      ],
      "Abstract": "SPLASH-MARC will be a mini-conference focusing on the overlap between\r\nsoftware systems, programming languages, and many-core\r\narchitectures. Previous symposia in this series have brought together\r\ndiverse research interests ranging from power consumption to\r\nprogramming language support, from message passing to software-managed\r\ncoherence, all with a common tie to many-core platforms, such as the\r\nIntel(R) experimental Single-Chip Cloud (SCC) architecture or the Xeon\r\nPhi(TM) product family.\r\n",
      "Key": 755,
      "URL": "http://www.mscs.mu.edu/~brylow/SPLASH-MARC-2013/",
      "Title": "MARC — Many-core Applications Research Community Symposium"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1218,
        1219,
        1238,
        1237,
        1236,
        1217
      ],
      "Abstract": "Programming reactive applications is a challenging task. Reactivity must be properly expressed by suitable language abstractions, reactive code must be modular and extensible, easy to understand and to analyze. Researchers have proposed several solutions to address this issue, including event-based programming, functional-reactive programming and aspect-oriented programming. Many synergies exist between paradigms such as implicit invocations, aspects and joinpoints, asynchronous methods, first-class events, purely functional reactive frameworks and design and architectural patterns such as subject/observer and publish/subscribe respectively. The different paradigms have emerged from different communities, and with different motivations ranging from decoupling of runtime components in distributed and concurrent applications to decoupling of software modules, and consequently also exhibit subtle yet important differences in characteristics and semantics. \r\n\r\nWith the ever increasing pervasiveness of reactive, concurrent, and distributed systems, this workshop serves as a conduit for novel work in the context of reactive software design and implementation broadly construed, i.e., related to any of the above paradigms. Of particular interest is work which bridges between the different paradigms and helps clarify the relations between them. This workshop will gather researchers active in different communities. Among the goals of the workshop is to exchange new technical research results and to define better the field by coming up with taxonomies and overviews of the existing work.",
      "Key": 704,
      "URL": "http://soft.vub.ac.be/REM13",
      "Title": "REM — Reactivity, Events and Modularity"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1213,
        1211,
        1212
      ],
      "Abstract": "Technical debt is an unavoidable part of software development in\ntoday's fast-paced market.\n\nTechnical debt is the result of deliberate design decisions. Schedule\npressure and other forces make it necessary to create \"quick and\ndirty\" code, with the expectation of improving the code later. When\ntechnical debt accumulates, the cost of software maintenance and new\nfeature development begins to increase.\n\nThis workshop will explore the sources of technical debt and some of\nthe best practices for keeping technical debt under control. If we\nbelieve that technical debt is an important issue in long-term\nsoftware product development, do we have ways to keep the technical\ndebt from causing development gridlock? The workshop will discuss some\napproaches to taking on technical debt from systems large and small.",
      "Key": 702,
      "URL": "http://mysite.verizon.net/dennis.mancl/splash13/index.html",
      "Title": "TD — Technical Debt"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1203,
        1206,
        1204,
        1283
      ],
      "Abstract": "The VMIL workshop is a forum for research in virtual machines and\r\nintermediate languages. It is dedicated to identifying programming\r\nmechanisms and constructs that are currently realized as code\r\ntransformations or implemented in libraries but should rather be\r\nsupported at VM level. Candidates for such mechanisms and constructs\r\ninclude modularity mechanisms (aspects, context-dependent layers),\r\nconcurrency (threads and locking, actors, software transactional\r\nmemory), transactions, etc. Topics of interest include the\r\ninvestigation of which such mechanisms are worthwhile candidates for\r\nintegration with the run-time environment, how said mechanisms can be\r\nelegantly (and reusably) expressed at the intermediate language level\r\n(e.g., in bytecode), how their implementations can be optimized, and\r\nhow virtual machine architectures might be shaped to facilitate such\r\nimplementation efforts.",
      "Key": 700,
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — 7th Workshop on Virtual Machines and Intermediate Languages"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1318
      ],
      "Abstract": "Memory anomalies, such as memory leaks, floating garbage, and excessive garbage collection pauses, impact application performance considerably. Sadly, these anomalies often remain inexplicable as detecting and locating them is a tedious task for which only little automated tool support exists. We propose to design a Java virtual machine extension that exposes parts of its internal memory state and allows memory monitoring tools to access this state at runtime. Furthermore our goal is to automate the tuning of the Java virtual machine to counteract memory anomalies. Together with domain experts from our industrial partner, Compuware Austria, we plan to validate our approach on real-world applications.\r\n",
      "Key": 783,
      "URL": null,
      "Title": "VM-Level Memory Monitoring for Resolving Performance Problems"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1317
      ],
      "Abstract": "As Android becomes popular, Android security acquires more and more attentions.\r\nThis paper proposes a new system design strategy for dissemination of high fidelity\r\napplications. We propose to use static and dynamic data flow analysis on Android\r\napplications to detect about how the apps leverage users'/enterprises' sensitive\r\ndata. Also, we plan to build up a cloud-based back-end to safeguard mobile devices.\r\nThe new secure system framework will not only analyze an individual app isolatedly,\r\nbut also analyze the correlation between apps.",
      "Key": 790,
      "URL": null,
      "Title": "A New Secure Online Play Store Based on Information Flow for Android"
    },
    {
      "Type": "DLS",
      "Authors": [
        1414
      ],
      "Abstract": "",
      "Key": 885,
      "URL": null,
      "Title": "Opening Remarks"
    },
    {
      "Type": "Workshops",
      "Authors": [
        1227,
        1228,
        1229
      ],
      "Abstract": "Mobile application usage and development is experiencing exponential\r\ngrowth. The mobile domain presents new challenges to software\r\nengineering1. Mobile platforms are rapidly changing, including diverse\r\ncapabilities as GPS, sensors, and input modes. Applications must be\r\nomni-channel and work on all platforms.\r\n\r\nActivated on mobile platforms, modern applications must be elastic and\r\nscale on demand according to the hardware abilities. During\r\ndevelopment, security and authorization processes for the dataflow\r\nmust be applied. Bring your own device (BYOD) policies bring new\r\nsecurity data leaks challenges.\r\n\r\nDeveloping such applications requires suitable practices and tools\r\ne.g., architecture techniques that relate to the complexity at hand;\r\nimproved refactoring tools for hybrid applications using dynamic\r\nlanguages and polyglot development and applications; and testing\r\ntechniques for applications that run on different devices.\r\n\r\nThis workshop aims at establishing a community of researchers and\r\npractitioners to share their work and lead further research in the\r\nmobile development area.",
      "Key": 708,
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml ",
      "Title": "MobileDeLi — Mobile Development Lifecycle"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1267
      ],
      "Abstract": "For most of my ~30 year career I've been working on Virtual Machines. In that time, much has changed. VMs were obscure in the 1980s; now they underpin much of computing. Performance has improved by about two orders of magnitude; complexity by much more than that. And yet, many problems remain. In this talk, I will use VMs which I've worked on (for Smalltalk, Self and Java) to outline some of the milestones of the past 30 years, list some of the problematic areas, and describe work in progress in Oracle Labs' Virtual Machine Research Group, which is attempting to address some of the problems in building new, high-performance VMs for dynamic languages.",
      "Key": 953,
      "URL": "",
      "Title": "DLS — VMs I Have Known and/or Loved"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1560
      ],
      "Abstract": "Mobile technologies are revolutionizing our personal lives and transforming\r\nthe way we do business. This talk addresses both the technology and\r\nbusiness transformations taking place, and explains how they are\r\nencouraging organizations to rethink the way they do business. The ensuing\r\nchanges affect the internal business processes related to employees and the\r\nexternal customer facing systems that use front office digitization. The\r\nlarge variety of heterogeneous platforms, form factors, native vs. hybrid\r\napplications are among the many challenges associated with developing and\r\nmanaging mobile applications. This challenge is further intensified by\r\nomni-channel requirements, which are driving the need for businesses to\r\npresent customers with a single, transparent system\u2014rather than multiple\r\nchannels with separate inventory, processing, and delivery systems. This\r\ntalk introduces new technologies from IBM Research that tackle these\r\nhurdles and address the entire application lifecycle. These innovations\r\ninclude: tools that help non-programmers create mobile applications,\r\nadvanced services for functional and performance testing, security analysis\r\nand certification, and application usability and usage analytics. This\r\ntechnology transformation underlines the need for new middleware\r\ncapabilities that are delivered as Mobile Back-end as a Service (MBaaS).\r\nThese services can include capabilities such as location, push, cloud code,\r\nand data synchronization; all these can be delivered as part of a\r\ncomprehensive API management system. In addition to platform challenges,\r\nthis talk shares a peek at some new mobile solutions, including advanced\r\nauthentication services, urban mobility, education, healthcare, patient\r\ncentered care, and more.",
      "Key": 948,
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml",
      "Title": "MobileDeLi — MobileFirst: Future Directions in Programming and Runtime Models"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1324
      ],
      "Abstract": "Although software testing is included as a regular part of many programming courses, current assessment techniques used in automated grading tools for evaluating student-written software tests are imperfect. Code coverage measures are typically used in practice, but that approach does not assess how much of the expected behavior is checked by the tests and sometimes, overestimates the true quality of the tests. Two robust and thorough measures for evaluating student-written tests are running each students\u00ed tests against others\u00ed solutions(known as all-pairs testing) and injecting artificial bugs to determine if tests can detect them (also known as mutation analysis). Even though they are better indicators of test quality, both of them posed a number of practical obstacles to classroom use. This proposal describes technical obstacles behind using these two approaches in automated grading. We propose novel and practical solutions to apply all-pairs testing and mutation analysis of student-written tests, especially in the context of classroom grading tools. Experimental results of applying our techniques in eight CS1 and CS2 assignments submitted by 147 students show the feasibility of our solution. Finally, we discuss our plan to combine the approaches to evaluate tests of assignments having variable amounts of design freedom and explain their evaluation method.",
      "Key": 785,
      "URL": null,
      "Title": "Automatically Assessing the Quality of Student-Written Tests"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1321
      ],
      "Abstract": "Controlling software systems autonomously has been a challenging research area.  Modern autonomous systems are guided by a plan, which is a sequence of actions to take to achieve a goal.  Many planning algorithms exist today to produce plans given a problem definition and goal.  To ease programmability of autonomous systems, many languages have been developed for defining problems and goals.  However, planning algorithms tend to need to be customized not only for the problem definition language, but also for the problem definition itself.  This work presents a new problem definition language called PyLOM, an interpreted, object-oriented language.  The PyLOM run-time system uses generic algorithms, which do not need to be customized for each problem definition.  Thus, PyLOM separates problem definitions from planning algorithms to ease programmability and software reuse.  The choice of an object-oriented language also is intended to aid programmability, since prior problem definition languages adopt a functional programming style.",
      "Key": 786,
      "URL": null,
      "Title": "PyLOM: A Language and Run-Time System for Planning Applications"
    },
    {
      "Type": "DLS",
      "Authors": [
        1540,
        1539,
        1537,
        1538,
        1536
      ],
      "Abstract": "JavaScript programs vary widely in functionality, complexity, and use, and analyses of these programs must accommodate such variations. Type-based analyses are typically the simplest such analyses, but due to the language\u2019s subtle idioms and many application-specific needs\u2014ranging from general-purpose program type-checking to verifying security properties to typing library usage\u2014we have found that a single type system does not work well in all contexts. However, these different uses still share many common elements that can be extended and adapted for each setting.\r\n\r\nIn this paper we present TeJaS, a framework for building type systems for JavaScript. TeJaS has been engineered modularly to encourage experimentation. TeJaS reifies its initial type environment, allowing for easy modeling of the various execution contexts of JavaScript programs, and its type language and typing rules are extensible, allowing for variations of the type system to be constructed easily.\r\n\r\nThe paper presents the base TeJaS type system, which performs traditional type-checking for JavaScript. Because JavaScript demands complex types, we explain several design decisions to improve user ergonomics. We then describe TeJaS\u2019s modular structure, and illustrate it by reconstructing the essence of a very different type system for JavaScript. Systems built from TeJaS have been applied to several real-world, third-party JavaScript programs.",
      "Key": 877,
      "URL": null,
      "Title": "Type Refinement for Static Analysis of JavaScript"
    },
    {
      "Type": "DLS",
      "Authors": [
        1519,
        1517,
        1518
      ],
      "Abstract": "Gradual typing enables a smooth and progressive integration of static and dynamic typing. The semantics of a gradually-typed program is given by translation to an intermediate language with casts: runtime type checks that control the boundaries between statically- and dynamically-typed portions of a program. This paper studies the performance of different cast insertion strategies in the context of Gradualtalk, a gradually-typed Smalltalk. We first implement the strategy specified by Siek and Taha, which inserts casts at call sites. We then study the dual approach, which consists in performing casts in callees. Based on the observation that both strategies perform well in different scenarios, we design a hybrid strategy that combines the best of each approach. We evaluate these three strategies using both micro- and macro-benchmarks. We also discuss the impact of these strategies on memory, modularity, and inheritance. The hybrid strategy constitutes a promising cast insertion strategy for adding gradual types to existing dynamically-typed languages.",
      "Key": 878,
      "URL": null,
      "Title": "Cast Insertion Strategies for Gradually-Typed Objects"
    },
    {
      "Type": "DLS",
      "Authors": [
        1511,
        1509,
        1429,
        1306
      ],
      "Abstract": "JavaScript programs vary widely in functionality, complexity, and use, and analyses of these programs must accommodate such variations. Type-based analyses are typically the simplest such analyses, but due to the language\u2019s subtle idioms and many application-specific needs\u2014ranging from general-purpose program type-checking to verifying security properties to typing library usage\u2014we have found that a single type system does not work well in all contexts. However, these different uses still share many common elements that can be extended and adapted for each setting.\r\n\r\nIn this paper we present TeJaS, a framework for building type systems for JavaScript. TeJaS has been engineered modularly to encourage experimentation. TeJaS reifies its initial type environment, allowing for easy modeling of the various execution contexts of JavaScript programs, and its type language and typing rules are extensible, allowing for variations of the type system to be constructed easily.\r\n\r\nThe paper presents the base TeJaS type system, which performs traditional type-checking for JavaScript. Because JavaScript demands complex types, we explain several design decisions to improve user ergonomics. We then describe TeJaS\u2019s modular structure, and illustrate it by reconstructing the essence of a very different type system for JavaScript. Systems built from TeJaS have been applied to several real-world, third-party JavaScript programs.",
      "Key": 886,
      "URL": null,
      "Title": "TejaS: Retrofitting Type Systems for JavaScript"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1753,
        1199,
        1754
      ],
      "Abstract": "Most contemporary programs are customizable. They provide many\r\nfeatures that give rise to millions of program variants. Determining\r\nwhich feature selection yields an optimal performance is challenging,\r\nbecause of the exponential number of variants. Predicting the perfor-\r\nmance of a variant based on previous measurements proved successful,\r\nbut induces a trade-off between the measurement effort and predic-\r\ntion accuracy. We propose the alternative approach of family-based\r\nperformance measurement, to reduce the number of measurements\r\nrequired for identifying feature interactions and for obtaining accurate\r\npredictions. The key idea is to create a variant simulator (by translating\r\ncompile-time variability to run-time variability) that can simulate the\r\nbehavior of all program variants. We use it to measure performance of\r\nindividual methods, trace methods to features, and infer feature inter-\r\nactions based on the call graph. We evaluate our approach by means\r\nof five feature-oriented programs. On average, we achieve accuracy\r\nof 98 %, with only a single measurement per customizable program.\r\nObservations show that our approach opens avenues of future research\r\nin different domains, such an feature-interaction detection and testing.\r\n",
      "Key": 1012,
      "URL": null,
      "Title": "Family-Based Performance Measurement"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1748,
        1749,
        1747,
        1744,
        1741,
        1745,
        1742,
        1746,
        1743
      ],
      "Abstract": "Dynamic analysis tools are often implemented using instrumenta-\r\ntion, particularly on managed runtimes including the Java Virtual\r\nMachine (JVM). Performing instrumentation robustly is especially\r\ncomplex on such runtimes: existing frameworks offer limited cov-\r\nerage and poor isolation, while previous work has shown that ap-\r\nparently innocuous instrumentation can cause deadlocks or crashes\r\nin the observed application. This paper describes ShadowVM, a\r\nsystem for instrumentation-based dynamic analyses on the JVM\r\nwhich combines a number of techniques to greatly improve both\r\nisolation and coverage. These centre on the offload of analysis to\r\na separate process; we believe our design is the first system to en-\r\nable genuinely full bytecode coverage on the JVM. We describe a\r\nworking implementation, and use a case study to demonstrate its\r\nimproved coverage and to evaluate its runtime overhead.\r\n",
      "Key": 1009,
      "URL": null,
      "Title": "ShadowVM?: Robust and Comprehensive Dynamic Program Analysis for the Java Platform"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1753,
        1764,
        1763,
        1754
      ],
      "Abstract": "Analyzing software product lines is difficult, due to their inherent\r\nvariability. In the past, several strategies for product-line analysis\r\nhave been proposed, in particular, product-based, feature-based,\r\nand family-based strategies. Despite recent attempts to conceptu-\r\nally and empirically compare different strategies, there is no work\r\nthat empirically compares all of the three strategies in a controlled\r\nsetting. We close this gap by extending a compiler for feature-\r\noriented programming with support for product-based, feature-\r\nbased, and family-based type checking. We present and discuss\r\nthe results of a comparative performance evaluation that we con-\r\nducted on a set of 12 feature-oriented, JAVA-based product lines.\r\nMost notably, we found that the family-based strategy is superior\r\nfor all subject product lines: it is substantially faster, it detects all\r\nkinds of errors, and provides the most detailed information about\r\nthem.\r\n",
      "Key": 1018,
      "URL": null,
      "Title": "A Comparison of Product-based, Feature-based, and Family-based Type Checking"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1562,
        1563,
        1306
      ],
      "Abstract": "Adding computer science to already-packed middle- and high- school curricula can be difficult; after-school programs offer an enticing alternative to broadening student exposure to computing. Over the last eight years, we have deployed a content-rich introductory computing course to over a thousand middle-school students through after-school programs nationwide. Our program, Bootstrap, teaches students to program their own videogames in a way that connects deeply to in-school learning goals for algebra and coordinate geometry. Volunteers (college students or software professionals) teach Bootstrap through established after-school partners. This paper describes both Bootstrap and lessons we have learned about teaching computing effectively in after-school programs using volunteer teachers.",
      "Key": 899,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/Bootstrap-SPLASHE-2013.pdf",
      "Title": "Bootstrap: Programming Games with Algebra"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1558
      ],
      "Abstract": "This paper advocates the adoption of deferred error coding within computer science curricula. It argues that it is both a sound development strategy and aligns well pedagogically. By deferring specific error handling, the student better appreciates its subtleties and its importance as an independent topic, and will tend to create more reliable applications. This paper includes other topics which may increase community awareness of the issues and enhance curricula: taxonomies of exceptions and exception handlers and the relationships between them, subtle pitfalls of exception handling, and factors influencing the selection of error reporting patterns. Much of the discussion is language independent, but specific attention is given to the Java checked exception controversy, which inspired the curriculum approach.",
      "Key": 900,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/HandlingExceptions_FirstDoNoHarmSPLASH_E14.pdf",
      "Title": "First, Do No Harm: A Curricular Approach to Exceptions"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1474,
        1476
      ],
      "Abstract": "Mathematical induction is a difficult subject for beginning students of computer science to fully grasp. In this short paper, we propose using functional programming and proof assistants as an aide in teaching mathematical induction in a traditional discrete mathematics course. To demonstrate this approach, we created a proof-of- concept web-based tutorial on induction. In this tutorial, students write small functional programs and prove simple properties about them using inductive reasoning. The functional programming language is deliberately designed to be minimalistic so that it can be picked up quickly, especially if the student is already familiar with a functional programming language, and not be a distraction to the ultimate goal of learning induction. Furthermore, the tutorial features an online IDE for entering programs and proofs to minimize the barrier to entry for students and instructors.",
      "Key": 901,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/posera-splashe-2013.pdf",
      "Title": "Teaching Induction with Functional Programming and A Proof Assistant"
    },
    {
      "Type": "SLE",
      "Authors": [
        1677,
        1679,
        1678,
        1262,
        1683,
        1680,
        1284,
        1688,
        1687,
        1684,
        1674,
        1682,
        1675,
        1681,
        1676,
        1685,
        1664,
        1230,
        1673,
        1686,
        1622
      ],
      "Abstract": "",
      "Key": 985,
      "URL": null,
      "Title": "The State of the Art in Language Workbenches"
    },
    {
      "Type": "SLE",
      "Authors": [
        1690,
        1691,
        1689
      ],
      "Abstract": "",
      "Key": 986,
      "URL": null,
      "Title": "A Model-Driven Approach to Enhance Tool Interoperability using the Theory of Models of Computation"
    },
    {
      "Type": "SLE",
      "Authors": [
        1692,
        1693
      ],
      "Abstract": "",
      "Key": 987,
      "URL": null,
      "Title": "Whiley: a Platform for Research in Software Verification"
    },
    {
      "Type": "SLE",
      "Authors": [
        1696,
        1695,
        1635
      ],
      "Abstract": "",
      "Key": 988,
      "URL": null,
      "Title": "Method and tool support for classifying software languages with Wikipedia"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1323
      ],
      "Abstract": "As modern software applications are becoming increasingly distributed and mobile, their design and implementation are characterized by distributed software architectures, possibility of faults, and the need for energy awareness. Thus, software developers should be able to simultaneously reason about and handle the concerns of distribution, fault-tolerance, and energy efficiency. Being closely intertwined, these concerns can introduce significant complexity into the design and implementation of modern software. Thus, to develop reliable and energy efficient applications, software developers must understand how distribution, fault-tolerance, and energy efficiency interplay with each other and how to implement these concerns while keeping the complexity in check. This paper studies these concerns and their interaction; it also develops novel approaches, techniques, and tools that effectively fuse and separate these concerns as required by particular software development scenarios.",
      "Key": 789,
      "URL": null,
      "Title": "Effective Fusion and Separation of Distribution, Fault-Tolerance, and Energy-Efficiency Concerns"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1316
      ],
      "Abstract": "Today, many developers try to create a new scripting language to provide scripting features to their own application domain. We proposed The DeSugar parser that provides a flexible means of extending the user-defined syntax by scripting. The goal of the DeSugar parser is to make it easier for users to adopt the language syntax to their own application domain. This paper presents Konoha, which is fully integrated with the DeSugar parser, and which allows users to extend its own syntax through the DeSugar parser scripting interfaces.",
      "Key": 787,
      "URL": null,
      "Title": "Implementing A Scripting Language Parser with Self-Extensible Syntax"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1322
      ],
      "Abstract": "Meta-programming has shown much promise for improving the quality of software. A system that supports meta-programming is able to generate or manipulate other programs to extend their behaviour. Thus far, the power of meta-programming has not been explored deeply in the area of High Performance Computing (HPC). We propose to bring the power of meta-programming to languages that may be used in HPC to help to solve various problems in HPC software related to efficiency, scalability, and adaptation. In our initial efforts we have implemented a meta-programming framework called OpenFortran to build arbitrary source-to-source program transformation libraries for Fortran programs. The design focus of OpenFortran is to enable program transformation in a manner that is transparent to application programmers. Similarly, we have also built a framework for C called OpenC. In this doctoral symposium summary, we present the idea of building a generalized meta-programming framework suitable for extending an arbitrary programming language, which would allow source-to-source program trans-formation. We also describe the possibility of solving problems emerging in HPC software via program transformation.",
      "Key": 788,
      "URL": null,
      "Title": "Program Transformation Techniques Applied to Languages Used in High Performance Computing"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1561
      ],
      "Abstract": "Edge environments, such as those in which first responders and military\r\npersonnel operate in, are characterized by dynamic context, limited\r\ncomputing resources, intermittent network connectivity, and high levels of\r\nstress. First responders and soldiers can use handheld devices in these\r\nenvironments to help with tasks such as speech and image recognition,\r\nnatural language processing, decision-making and mission planning.\r\nUnfortunately, commercial mobile solutions often do not work because they\r\nnot address the \"challenges of being at the edge.\" This talk will discuss\r\npotential solutions as well as open areas of research for designing and\r\nimplementing mobile systems in edge environments.",
      "Key": 949,
      "URL": "http://sysrun.haifa.il.ibm.com/hrl/mobiledeli2013/index.shtml",
      "Title": "MobileDeLi — Mobile Computing in Resource-Constrained Environments"
    },
    {
      "Type": "SLE",
      "Authors": [
        1700,
        1262,
        1698,
        1697,
        1699
      ],
      "Abstract": "",
      "Key": 989,
      "URL": null,
      "Title": "Language-Parametric Incremental Name and Type Analysis"
    },
    {
      "Type": "SLE",
      "Authors": [
        1701,
        1702,
        1703
      ],
      "Abstract": "",
      "Key": 990,
      "URL": null,
      "Title": "A Generic Framework for Symbolic Execution"
    },
    {
      "Type": "SLE",
      "Authors": [
        1704,
        1705
      ],
      "Abstract": "",
      "Key": 991,
      "URL": null,
      "Title": "Circular Higher-order Attribute Grammars"
    },
    {
      "Type": "DLS",
      "Authors": [
        1522,
        1521,
        1520,
        1523
      ],
      "Abstract": "Type feedback and type inference are two common methods used to optimize dynamic languages such as JavaScript. Each of these methods has its own strengths and weaknesses, and we propose that each can benefit from the other if combined in the right way. We explore the interdependency between these two methods and propose two novel ways to combine them in order to significantly increase their aggregate benefit and decrease their aggregate overhead. In our proposed strategy, an initial type inference pass is applied that can reduce type feedback overhead by enabling more intelligent placement of profiling hooks. This initial type inference pass is novel in the literature. After profiling, a second (and final) type inference pass uses the type information from profiling to generate efficient code. While this second pass is not novel, we significantly improve its effectiveness in a novel way by feeding the type inference pass information about the function signature, i.e., the types of the function\u2019s arguments for a specific function invocation. Our results show significant speedups when using these low-overhead strategies, ranging from 1.2\u00d7 to 4\u00d7 over an implementation that does not perform type feedback or type inference based optimizations. Our experiments are carried out across a wide range of traditional benchmarks and realistic web applications. The results also show an average reduction of 23.46% in the size of the profiled data for these benchmarks.",
      "Key": 879,
      "URL": null,
      "Title": "Improved Type Specialization for Dynamic Scripting Languages"
    },
    {
      "Type": "DLS",
      "Authors": [
        1524,
        1525
      ],
      "Abstract": "JSConTest introduced the notions of effect monitoring and dynamic\r\neffect inference for JavaScript. It enables the description of effects\r\nwith path specifications resembling regular expressions. It is\r\nimplemented by an offline source code transformation.\r\n\r\nTo overcome the limitations of the JSConTest implementation, we\r\nredesigned and reimplemented effect monitoring by taking advantange of\r\nJavaScript proxies. Our new design avoids all drawbacks of the prior\r\nimplementation. It guarantees full interposition; it is not restricted\r\nto a subset of JavaScript; it is self-maintaining; and its scalability\r\nto large programs is significantly better than with JSConTest.\r\n\r\nThe improved scalability has two sources. First, the reimplementation is\r\nsignificantly faster than the original, transformation-based\r\nimplementation. Second, the reimplementation relies on the fly-weight\r\npattern and on trace reduction to conserve memory. Only the\r\ncombination of these techniques enables monitoring and inference for\r\nlarge programs. ",
      "Key": 880,
      "URL": null,
      "Title": "Efficient Dynamic Access Analysis Using JavaScript Proxies"
    },
    {
      "Type": "DLS",
      "Authors": [
        1528,
        1529
      ],
      "Abstract": "In object-oriented programming, polymorphic dispatch of operations\r\ndecouples clients from specific providers of services and allows\r\nimplementations to be modified or substituted without affecting\r\nclients.\r\n\r\nThe Uniform Access Principle (UAP) tries to extend these qualities to\r\nresource access by demanding that access to state be indistinguishable\r\nfrom access to operations. Despite language features supporting the\r\nUAP, the overall goal of substitutability has not been achieved for\r\neither alternative resources such as keyed storage, files or web pages,\r\nor for alternate access mechanisms: specific kinds of resources are bound\r\nto specific access mechanisms and vice versa. Changing storage or access\r\npatterns either requires changes to both clients and service providers and\r\ntrying to maintain the UAP imposes significant penalties in terms of code-\r\nduplication and/or performance overhead.\r\n\r\nWe propose introducing first class identifiers as polymorphic names for\r\nstorage locations to solve these problems. With these Polymorphic\r\nIdentifiers, we show that we can provide uniform access to a wide variety\r\nof resource types as well as storage and access mechanism, whether parametrized\r\nor direct, without affecting client code, without causing code duplication or\r\nsignificant performance penalties. ",
      "Key": 881,
      "URL": null,
      "Title": "Polymorphic Identifiers: Uniform Resource Access in Objective-Smalltalk"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1570,
        1352,
        1569,
        1306
      ],
      "Abstract": "",
      "Key": 904,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/Caycs1mooc.pdf",
      "Title": "Panel — MOOCs: Early Experience"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1593,
        1594
      ],
      "Abstract": "This paper describes our experience in trying to transfer our revised software engineering curriculum from UC Berkeley to other universities. Our original plan was just to develop an inexpensive electronic textbook, but we were swept up in the first wave of Massive Open Online Course (MOOCs) while we were writing it. Thus, the paper lists the lessons learned about educational technology transfer from writing Ebooks and developing MOOCs. To make it easier for instructors to use MOOC material, EdX offers Small Private Online Course (SPOCs) We argue that SPOCs and Ebooks may become the textbook of the 21st Century.",
      "Key": 917,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/PattersonSPLASHEv6.pdf",
      "Title": "Myths about MOOCs and Software Engineering Education"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1737,
        1736,
        1738,
        1438,
        1291
      ],
      "Abstract": "Program generators for high performance libraries are an appeal-\r\ning solution to the recurring problem of porting and optimizing\r\ncode with every new processor generation, but only few such gen-\r\nerators exist to date. This is due to not only the difficulty of the\r\ndesign, but also of the actual implementation, which often results\r\nin an ad-hoc collection of standalone programs and scripts that are\r\nhard to extend, maintain, or reuse. In this paper we ask whether\r\nand which programming language concepts and features are needed\r\nto enable a more systematic construction of such generators. The\r\nsystematic approach we advocate extrapolates from existing gen-\r\nerators: a) describing the problem and algorithmic knowledge us-\r\ning one, or several, domain-specific languages (DSLs), b) express-\r\ning optimizations and choices as rewrite rules on DSL programs,\r\nc) designing data structures that can be configured to control the\r\ntype of code that is generated and the data representation used, and\r\nd) using autotuning to select the best-performing alternative. As a\r\ncase study, we implement a small, but representative subset of Spi-\r\nral in Scala using the Lightweight Modular Staging (LMS) frame-\r\nwork. The first main contribution of this paper is the realization of\r\nc) using type classes to abstract over staging decisions, i.e. which\r\npieces of a computation are performed immediately and for which\r\npieces code is generated. Specifically, we abstract over different\r\ncomplex data representations jointly with different code represen-\r\ntations including generating loops versus unrolled code with scalar\r\nreplacement\u2014a crucial and usually tedious performance transfor-\r\nmation. The second main contribution is to provide full support for\r\na) and d) within the LMS framework: we extend LMS to support\r\ntranslation between different DSLs and autotuning through search.\r\n",
      "Key": 1006,
      "URL": null,
      "Title": "Spiral in Scala: Towards the Systematic Construction of Generators for Performance Libraries"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1756,
        1758,
        1755,
        1757
      ],
      "Abstract": "Programming wireless embedded networks is challenging due to\r\nsevere limitations on processing speed, memory, and bandwidth.\r\nStaged programming can help bridge the gap between high level\r\ncode refinement techniques and efficient device level programs by\r\nallowing a first stage program to specialize device level code. Here\r\nwe introduce a two stage programming system for wireless sensor\r\nnetworks. The first stage program is written in our extended dialect\r\nof Scala, called Scalaness, where components written in our type\r\nsafe dialect of nesC, called nesT, are composed and specialized.\r\nScalaness programs can dynamically construct TinyOS-compliant\r\nnesT device images that can be deployed to motes. A key result,\r\ncalled cross-stage type safety, shows that successful static type\r\nchecking of a Scalaness program means no type errors will arise ei-\r\nther during programmatic composition and specialization of WSN\r\ncode, or later on the WSN itself. Scalaness has been implemented\r\nthrough direct modification of the Scala compiler. Implementation\r\nof a staged public-key cryptography calculation shows the sensor\r\nmemory footprint can be significantly reduced by staging.\r\n",
      "Key": 1013,
      "URL": null,
      "Title": "Scalaness/nesT: Type Specialized Staged Programming for Sensor Networks"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1646,
        1647,
        1649,
        1648,
        1721,
        1438,
        1291
      ],
      "Abstract": "Domain-specific languages provide a promising path to automatically compile high-level code to parallel, heterogeneous, and distributed hardware. However, in practice high performance DSLs \r\n  still require considerable software expertise to develop and force \r\n  users into tool-chains that hinder prototyping and debugging. To \r\n  address these problems, we present Forge, a new meta DSL for \r\n  declaratively specifying high performance embedded DSLs. Forge \r\n  provides DSL authors with high-level abstractions (e.g., data structures, parallel patterns, effects) for specifying their DSL in a way \r\n that permits high performance. From this high-level specification, \r\n  Forge automatically generates both a na\u00efve Scala library implementation of the DSL and a high performance version using the Delite \r\n  DSL framework. Users of a Forge-generated DSL can prototype \r\n  their application using the library version, and then switch to the \r\n  Delite version to run on multicore CPUs, GPUs, and clusters with-out changing the application code. Forge-generated Delite DSLs \r\n  perform within 2x of hand-optimized C++ and up to 40x better \r\n  than Spark, an alternative high-level distributed programming environment. Compared to a manually implemented Delite DSL, Forge \r\n  provides a factor of 3-6x reduction in lines of code and does not \r\n  sacrifice any performance. Furthermore, Forge specifications can \r\n  be generated from existing Scala libraries, are easy to maintain, \r\n  shield DSL developers from changes in the Delite framework, and \r\n  enable DSLs to be retargeted to other frameworks transparently. \r\n",
      "Key": 1000,
      "URL": null,
      "Title": "Forge: Generating a High Performance DSL Implementation from a Declarative Specification."
    },
    {
      "Type": "GPCE",
      "Authors": [
        1722,
        1723
      ],
      "Abstract": "We argue that synthesizing operations on recursive linked data\r\nstructures is not as hard as it appears and is, in fact, within reach\r\nof current SAT-based synthesis techniques\u2014with the addition of\r\na simple approach that we describe to decompose the problem\r\ninto smaller parts. To generate smaller pieces of code, i.e., shorter\r\nroutines, is obviously easier than large and complex routines, and,\r\nalso, there is more potential for automating the code synthesis.\r\n\r\nIn this paper, we present a code generation algorithm for synthesizing operations of linked data structures and, as an example,\r\ndescribe how the proposed algorithm works to synthesize opera-\r\ntions of an AVL tree.\r\n",
      "Key": 1001,
      "URL": null,
      "Title": "On the Simplicity of Synthesizing Linked Data Structure Operations"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1506
      ],
      "Abstract": "Looking around this world, we see that a fledgling can fly faster and faster, a pupil can calculate quicker and quicker, and a graduate student can write papers better and better.  But since the birth of computers, it has been the case that after the release of a software package, the one millionth run of the program is typically not a bit better than its first-time run. Do programs have to be this dumb? In this talk, I will discuss the barriers that cause such dumbness, our efforts in creating a more intelligent paradigm, and some open challenges that you may be able to help address.",
      "Key": 951,
      "URL": "http://design.cs.iastate.edu/vmil/2013",
      "Title": "VMIL — Do Computer Programs Have to Be As Dumb As They Are?"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1319
      ],
      "Abstract": "Integrating a distributed software system using publically available software services saves effort, time, and cost. One key step in this process is the service selection which identifies a relevant set of services for this integration. In an open service marketplace, it is hard to judge the trust of software services using a static view (consisting of service specifications) published by their developers. Instead, the concepts of trust in the context of services needs to be properly quantified, specified, negotiated, and then used in the selection process. Prevalent service selection and negotiation approaches do not consider the trust aspect of services. Trustworthy service representation, selection, and negotiation are challenging tasks due to the subjective and temporal nature of trust, lack of standards, and associated uncertainty. This proposal defines the trust of a service, quantifies the trust by monitoring and aggregating various evidences, represents the trust in the service specification and improves the service selection and negotiation process using this representation. Publically available software objects (from Java collection framework library) and mobile app services (from the Android marketplace) are used as datasets to empirically evaluate this proposal.",
      "Key": 784,
      "URL": null,
      "Title": "TruSSCom – Proposal for Trustworthy Service Representation Selection and Negotiation for Integrating Software Systems"
    },
    {
      "Type": "Doctoral Symposium",
      "Authors": [
        1320
      ],
      "Abstract": "Great strides have been made to increase the energy efficiency of hardware, data center facilities, and network infrastructure. However, in any computer system, it is software that directs much of the activity of the hardware. Moreover, multicore processors have become ubiquitous, mainly because their multiple benefits, especially enhanced performance for multi-threaded and compute-intensive applications. Nonetheless, there are few studies addressing the topic of restructuring multicore applications to consume less energy and even fewer that leverage developer expertise to achieve that goal. In this thesis we present a brief background study for refactoring multicore applications in order to improve both performance and energy consumption. The idea consists in proposing a catalog of refactorings targeting some languages of the JVM platform.",
      "Key": 791,
      "URL": null,
      "Title": "Refactoring Multicore Applications Towards Energy Efficiency"
    },
    {
      "Type": "SLE",
      "Authors": [
        1707,
        1708,
        1706
      ],
      "Abstract": "",
      "Key": 992,
      "URL": null,
      "Title": "Mechanics of Megamodeling: Design Patterns and Laws"
    },
    {
      "Type": "SLE",
      "Authors": [
        1712,
        1709,
        1711,
        1710,
        1706
      ],
      "Abstract": "",
      "Key": 993,
      "URL": null,
      "Title": "Partial Instances via Subclassing"
    },
    {
      "Type": "SLE",
      "Authors": [
        1717,
        1662,
        1715,
        1713,
        1714,
        1716,
        1718
      ],
      "Abstract": "",
      "Key": 994,
      "URL": null,
      "Title": "Reifying Concurrency for Executable Metamodeling"
    },
    {
      "Type": "DLS",
      "Authors": [
        1530,
        1531,
        1532
      ],
      "Abstract": "The with statement in JavaScript makes static analysis of JavaScript applications difficult by introducing a new scope at run time and thus invalidating lexical scoping. Therefore, many static approaches to JavaScript program analysis and the strict mode of ECMAScript 5 simply disallow the with statement. To justify exclusion of the with statement, we should better understand the actual usage patterns of the with statement.\r\nIn this paper, we present the usage patterns of the with statement in real-world JavaScript applications currently used in the 898 most popular web sites. We investigate whether we can rewrite the with statements in each pattern to other statements not using the with statement. We show that we can rewrite all the static occurrences of the with statement that do not have any dynamic code generating functions. Even though the rewriting process is not applicable to any dynamically generated with statements, our results are still promising. Because all the static approaches that disallow the with statement also disallow dynamic code generation, such static approaches can allow the with statement using our rewriting process. We formally present our rewriting strategy, provide its implementation, and show its faithfulness using extensive testing. We believe that removing with statements will simplify JavaScript program analysis designs without considering dynamic scope introduction while imposing less syntactic restrictions.",
      "Key": 882,
      "URL": null,
      "Title": "All about the with Statement in JavaScript: Removing with Statements in JavaScript Applications"
    },
    {
      "Type": "DLS",
      "Authors": [
        1534,
        1533
      ],
      "Abstract": "MATLAB is a popular dynamic array-based language used by engineers, scientists and students worldwide. The built-in function feval is an important MATLAB feature for certain classes of numerical programs and solvers which benefit from having functions as parameters. Programmers may pass a function name or function handle to the solver and then the solver uses feval to indirectly call the function. In this paper, we show that there are significant performance overheads for function calls via feval, in both MATLAB interpreters and JITs. The paper then proposes, implements and compares two on-the-fly mechanisms for specialization of feval calls. The first approach uses on-stack replacement technology, as supported by McVM/McOSR. The second approach specializes calls of functions with feval using a combination of runtime input argument types and values. Experimental results on seven numerical solvers show that the techniques provide good performance improvements.",
      "Key": 883,
      "URL": null,
      "Title": "Optimizing MATLAB feval with Dynamic Techniques"
    },
    {
      "Type": "DLS",
      "Authors": [
        1535,
        1306
      ],
      "Abstract": "JavaScript is the language of the ubiquitous Web, but it only poorly\r\nsupports event-driven functional programs due to its\r\nsingle-threaded, asynchronous nature and lack of rich control flow\r\noperators. We present Whalesong, a compiler from Racket that generates\r\nJavaScript code that masks these problems. We discuss the\r\nimplementation strategy using delimited continuations, an interface\r\nto the DOM, and an FFI for adapting JavaScript libraries to add new\r\nplatform-dependent reactive features. In the process, we also\r\ndescribe extensions to Racket's functional event-driven programming\r\nmodel. We also briefly discuss the implementation details.",
      "Key": 884,
      "URL": null,
      "Title": "Whalesong: Running Racket in the Browser"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1253
      ],
      "Abstract": "Teaching software developer skills should be a fundamental part of software engineering curriculum. The current industry relies on evolutionary and agile processes that add one feature or property at a time. The main task of these processes is software change. Results of the recent research allow this topic to be taught on both undergraduate and graduate level. Phased model of software change (PMSC) divides the task of software change into phases that are sufficiently well-understood and suitable for teaching in the undergraduate course. Among the phases, concept location finds the module(s) to be changed, impact analysis assesses the full extent and difficulty of the change, prefactoring reorganizes software to make it suitable for the change, actualization implements the new feature, and postfactoring cleans up the aftermath.",
      "Key": 903,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/Rajlich%20Teaching%20Developers.pdf",
      "Title": "Teaching Future Software Developers"
    },
    {
      "Type": "SPLASH-E",
      "Authors": [
        1630,
        1573,
        1631
      ],
      "Abstract": "Learning contemporary software development practices and acquiring good programming habits are valuable skills in computer science education. However, there are challenges in encouraging students' adherence to the incremental testing pattern involved in Test-Driven Development. We propose a model for an adaptive feedback system to observe and encourage incremental testing. Using data analysis of 6,953 submissions of students' programming assignments, we offer insight into students' development habits and their interaction with our adaptive feedback system. Based on our findings, we evaluate a model for measuring incremental testing and suggest approaches for improving reinforcement.",
      "Key": 906,
      "URL": "http://www.cs.pomona.edu/splashe/SPLASH-E2013/SPLASH-E_2013_files/buffardi-TDDpanel.pdf",
      "Title": "Panel — Test-Driven Development"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1730,
        1729,
        1728
      ],
      "Abstract": "Software solutions in complex environments, such as railway con-\r\ntrol systems or power plants, are assemblies of heterogeneous com-\r\nponents, which are very large and complex systems themselves.\r\nInterplay of these systems requires a thorough design of a system-\r\nof-systems (SoS) encompassing the required interactions between\r\nthe involved systems. One of the challenges lies in reconciliation of\r\nthe domain data structures and runtime constraints to ensure con-\r\nsistency of the SoS behavior. In this paper, we present a generative\r\napproach that enables reconciliation of a common platform based\r\non reusable domain models of the involved systems. This is com-\r\nparable to a product line configuration problem where we generate\r\na common platform model for all involved systems. We discuss the\r\nspecific requirements for model composition in a SoS context and\r\naddress them in our approach. In particular, our approach addresses\r\nthe operational and managerial independence of the individual sys-\r\ntems and offers appropriate modeling constructs. We report on our\r\nexperiences of applying the approach in several real world projects\r\nand share the lessons learned.\r\n",
      "Key": 1003,
      "URL": null,
      "Title": "Generation of Conjoint Domain Models for System-of-Systems"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1731,
        1778,
        1732,
        1777
      ],
      "Abstract": "The growth of applications developed with the support of\r\nmodel transformations makes reuse a required practice, spe-\r\ncially when applied to transformation assets (e.g. transfor-\r\nmation chains, algorithms, and configuration files). In order\r\nto promote reuse one must consider the different implemen-\r\ntations, communalities, and variants among these assets. In\r\nthis domain, a couple techniques have been used as solutions\r\nto adapt reusable assets for specific needs. However, so far,\r\nno work has discussed their combined use in real software\r\nprojects. In this paper, we present a new tool named WCT,\r\nwhich can be used to adapt transformation assets. Moreover,\r\nthrough lessons learned in industry, we address some reuse\r\ntechniques devoted to adapt these assets.\r\n",
      "Key": 1004,
      "URL": null,
      "Title": "Supporting Large Scale Model Transformation Reuse"
    },
    {
      "Type": "GPCE",
      "Authors": [
        1342,
        1340,
        1338,
        1341,
        1339
      ],
      "Abstract": "The Object Management Group\u2019s (OMG) Data Distribution Ser-\r\nvice (DDS) provides many configurable policies which determine\r\nend-to-end quality of service (QoS) of applications. It is chal-\r\nlenging to predict the system\u2019s performance in terms of latencies,\r\nthroughput, and resource usage because diverse combinations of\r\nQoS configurations influence QoS of applications in different ways.\r\nTo overcome this problem, design-time formal methods have been\r\napplied with mixed success, but lack of sufficient accuracy in pre-\r\ndiction, tool support, and understanding of formalism has prevented\r\nwider adoption of the formal techniques. A promising approach to\r\naddress this challenge is to emulate system behavior and gather\r\ndata on the QoS parameters of interest by experimentation. To re-\r\nalize this approach, which is preferred over formal methods due to\r\ntheir limitations in accurately predicting QoS, we have developed\r\na model-based automatic performance testing framework with gen-\r\nerative capabilities to reduce manual efforts in generating a large\r\nnumber of relevant QoS configurations that can be deployed and\r\ntested on a cloud platform. This paper describes our initial efforts\r\nin developing and using this technology.\r\n",
      "Key": 1008,
      "URL": null,
      "Title": "Model-driven Generative Framework for Automated OMG DDS Performance Testing in the Cloud"
    },
    {
      "Type": "Posters",
      "Authors": [
        1501
      ],
      "Abstract": "Power and energy constraints are now the driving force in devices from servers to smartphones. Quantitative power, performance, and energy measurements suggest that hardware heterogeneity to match software diversity has the potential to deliver energy efficiency. However, programming heterogeneous hardware directly is a nightmare. We discuss some approaches and results that abstract, choose, and exploit hardware heterogeneity. New programming and system abstractions are essential for establishing a parallel heterogeneous ecosystem in the post-Dennard era.",
      "Key": 997,
      "URL": null,
      "Title": "The Yin and Yang of Heterogeneous Hardware: Can Software Survive?"
    },
    {
      "Type": "Posters",
      "Authors": [
        1325
      ],
      "Abstract": "There exist many automated theorem provers. Often these systems' usefulness is outweighed by the difficulty of translating results into computer-readable form. I describe a case-study regarding proof-assistive tools developed in Prolog. They are applicable to many problems, and allow for rapid proof development with little intellectual overhead.",
      "Key": 793,
      "URL": null,
      "Title": "The Poor Man's Proof Assistant: Using Prolog to Develop Formal Language Theoretic Proofs"
    },
    {
      "Type": "Posters",
      "Authors": [
        1326
      ],
      "Abstract": "Local code search tools help developers efficiently find code snippets in the code base under development. Synthesizing high-quality queries for those tools is a non-trivial task because it expects developers knowing the terms used in the code base. To solve this problem, we propose a dictionary-based query recommendation technique.",
      "Key": 794,
      "URL": null,
      "Title": "Dictionary-Base Query Recommendation for Local Code Search"
    },
    {
      "Type": "Posters",
      "Authors": [
        1227,
        1328,
        1327
      ],
      "Abstract": "Program analysis plays an important role in a variety of software\r\nengineering processes, such as automated code refactoring, compiler\r\noptimizations, and program slicing.  The internal program\r\nrepresentation used by the program analysis algorithm affects the\r\npower and efficiency of the analysis.  In particular, representations\r\nthat contain data-flow information alongside control flow are known to\r\nbe especially useful.  While there are many popular internal program\r\nrepresentations with data-flow information for traditional languages\r\nand platforms, few specifically target mobile applications.  In this\r\npaper, we propose a new data-flow-enabled representation that\r\naddresses the screen-oriented nature of a mobile application and\r\nexplore its potential.  We consider a mobile application to be a\r\nreactive system in which states are the screens, and events are user\r\nactions, incoming communication, or anything else that causes\r\ntransition from one screen to another.  The resulting representation\r\nis a finite state machine extended with data-flow information.  We\r\nsuggest that this representation can greatly contribute to\r\noptimization, refactoring, and understanding of mobile applications.",
      "Key": 795,
      "URL": null,
      "Title": "A Screen-Oriented Representation for Mobile Applications"
    },
    {
      "Type": "Posters",
      "Authors": [
        1329,
        1330,
        1331
      ],
      "Abstract": "Object-oriented programming encapsulates object implementations with access specifiers like public and private. Unfortunately, specifiers can be circumvented by direct memory access, thus programmers are taught \u201cprivate is not secure\u201d. We propose hardware and software support to confine memory accesses within and between objects to make private secure.",
      "Key": 796,
      "URL": null,
      "Title": "Hardware and Software Support for Fine-Grained Memory Access Control and Encapsulation in C++"
    },
    {
      "Type": "Posters",
      "Authors": [
        1334,
        1333
      ],
      "Abstract": "",
      "Key": 798,
      "URL": null,
      "Title": "Source Code Management for Projectional Editing"
    },
    {
      "Type": "Posters",
      "Authors": [
        1335,
        1499
      ],
      "Abstract": "We deal with the problem of migration from deprecated API. We implemented two tools: JaSCUT, which updates the source code based on a configuration file, and a generator, which generates the configuration file for JaSCUT. We evaluated these tools on five open source projects and the results are very encouraging.",
      "Key": 799,
      "URL": null,
      "Title": "Migration from Deprecated API in Java"
    },
    {
      "Type": "Posters",
      "Authors": [
        1336,
        1499
      ],
      "Abstract": "We present a tool that facilitates checking the source compatibility. This tool figures out the component interface and generates the client code that uses the component interface to maximum extent. If the generated client compiles against the new component interface, those two versions are more or less compatible.",
      "Key": 800,
      "URL": null,
      "Title": "On Testing the Source Compatibility in Java"
    },
    {
      "Type": "Posters",
      "Authors": [
        1208,
        1337
      ],
      "Abstract": "The conceptual integration of OOP with concurrency, including asynchronous and even-driven programming, is still an issue, both from a conceptual and practical point of view. simpAL-O is a novel approach, based a simple conceptual model that integrates plain old objects with concurrency through agents, adopted as first-class abstractions.",
      "Key": 801,
      "URL": null,
      "Title": "Concurrent OOP with Agents"
    },
    {
      "Type": "Posters",
      "Authors": [
        1330,
        1331,
        1321
      ],
      "Abstract": "",
      "Key": 802,
      "URL": null,
      "Title": "PyLOM: A Language and Run-Time System for Planning Applications"
    },
    {
      "Type": "Posters",
      "Authors": [
        1342,
        1340,
        1338,
        1341,
        1339
      ],
      "Abstract": "The Object Management Group\u2019s (OMG) Data Distribution Service (DDS) provides many configurable policies which determine end-to-end quality of service (QoS) delivered to the applications. It is challenging, however, to predict the system\u2019s performance in terms of latencies, throughput, and resource usage because diverse combinations of QoS configurations influence QoS of applications in different ways. To overcome this problem, design-time formal methods have been applied with mixed success, but a lack of sufficient accuracy in prediction, tool support, and understanding of formalism has prevented wider adoption of the formal techniques. A promising approach to address this challenge is to emulate system behavior and gather data on the QoS parameters of interest by experimentation. To realize this approach, we have developed a middleware framework that uses model-driven generative mechanisms to automate performance testing of a large number of DDS QoS configuration combinations that can be deployed and tested on a cloud platform.",
      "Key": 803,
      "URL": null,
      "Title": "Model-driven Generative Framework for Automated OMG DDS Performance Testing in the Cloud"
    },
    {
      "Type": "Posters",
      "Authors": [
        1344,
        1320
      ],
      "Abstract": "Our study analyzed the performance and energy consumption of multicore applications, using a number of techniques to manage concurrent execution. We concluded that language constructs for concurrent execution can impact energy consumption. Nonetheless, the trade-off between performance and energy consumption in multicore applications is not as obvious as it seems.",
      "Key": 804,
      "URL": null,
      "Title": "On The Implications of Language Constructs for Concurrent Execution in the Energy Efficiency of Multicore Applications"
    },
    {
      "Type": "Posters",
      "Authors": [
        1347,
        1346,
        1345
      ],
      "Abstract": "Pattern matching is an abstraction mechanism that greatly simplifies source-code. We present functional-style pattern matching for C++ implemented as a library. All the patterns are user-definable, can be stored in variables, passed among functions, and support open class hierarchies. As an example, we implement common patterns from functional languages.",
      "Key": 805,
      "URL": null,
      "Title": "Open Pattern Matching for C++"
    },
    {
      "Type": "Posters",
      "Authors": [
        1422,
        1423,
        1425,
        1426,
        1424
      ],
      "Abstract": "",
      "Key": 995,
      "URL": null,
      "Title": "Isolation for Nested Task-Parallelism (OOPSLA'13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1442,
        1444,
        1443
      ],
      "Abstract": "",
      "Key": 996,
      "URL": null,
      "Title": "Efficient Concurrency-Bug Detection Across Inputs (OOPSLA'13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1376,
        1378,
        1375,
        1377,
        1379
      ],
      "Abstract": "Data-dependent GPU kernels, whose data or control flow are dependent on the input of the program, are difficult to verify because they require reasoning about shared state manipulated by many parallel threads. Existing verification techniques for GPU kernels achieve soundness and scalability by using a two-thread reduction and making the contents of the shared state nondeterministic each time threads synchronize at a barrier, to account for all possible thread interactions. This coarse abstraction prohibits verification of data-dependent kernels. We present barrier invariants, a novel abstraction technique which allows key properties about the shared state of a kernel to be preserved across barriers during formal reasoning. We have integrated barrier invariants with the GPUVerify tool, and present a detailed case study showing how they can be used to verify three prefix sum algorithms, allowing efficient modular verification of a stream compaction kernel, a key building block for GPU programming. This analysis goes significantly beyond what is possible using existing verification techniques for GPU kernels.",
      "Key": 999,
      "URL": null,
      "Title": "Barrier Invariants: A Shared State Abstraction for the Analysis of Data-Dependent GPU Kernels. (OOPSLA '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1766,
        1765,
        1217
      ],
      "Abstract": "In software projects, a significant amount of time is spent on finding and fixing runtime errors. This is mostly a manual process that backtracks from the point where the error is detected and reported. We present a novel program transformation called blame prediction which checks preconditions of primitive operations ahead of time. The execution of these programs then predicts runtime errors that are guaranteed to occur. This helps the programmer narrow down the actual causes of runtime errors, even across function or method boundaries.",
      "Key": 1023,
      "URL": null,
      "Title": "Blame Prediction"
    },
    {
      "Type": "Posters",
      "Authors": [
        1453,
        1455,
        1246,
        1456,
        1454
      ],
      "Abstract": "Providing security guarantees for software systems built out of untrusted components requires the ability to enforce fine-grained access control policies. This is evident in Web 2.0 applications where JavaScript code from different origins is often combined on a single page, leading to well-known vulnerabilities. We present a security infrastructure which allows users and content providers to specify access control policies over subsets of JavaScript execution traces and reversion to a safe state if a violation is detected. The proposal is evaluated in the context of a production browser where security principals are based on the browser's same origin policy. Simple security policies can be shown to prevent real attacks without imposing drastic restrictions on legacy applications. We have evaluated our infrastructure with two non-trivial policies on 50 of the Alexa top websites with no changes to the legacy JavaScript code and measured the performance overheads of our instrumentation.",
      "Key": 1024,
      "URL": null,
      "Title": "Flexible Access Control Policies with Delimited Histories (OOPSLA '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1769,
        1768,
        1767
      ],
      "Abstract": "This paper describes our experience developing a mobile, cloud- based weather alert system, which was motivated by the need to overcome the limitations in an existing, centralized severe weather warning system at Vanderbilt University. We faced different design choices, integration challenges and a substantial learning curve in realizing a decentralized, scalable, and easy-to-use solution. In our solution, Android devices in the vicinity of the hazardous weather event can post timely data to a server, including the approximate location of the severe weather incident, and where the server, in turn, can distribute messages scalably to relevant Android devices that are in the potential path of the weather incident. Although, the use case for this research was severe weather alerting, the basic patterns and design choices used in the mobile application design can be used in many other related scenarios. ",
      "Key": 1025,
      "URL": null,
      "Title": "Design Considerations in Developing a Mobile Application for Scalable and Decentralized Publish/Subscribe-based Weather Alert System"
    },
    {
      "Type": "Posters",
      "Authors": [
        1420,
        1421,
        1419
      ],
      "Abstract": "Nondeterminism is a useful and prevalent concept in the design and implementation of software systems. An important property of nondeterminism is its latent parallelism: A nondeterministic action can evaluate to multiple behaviors. If at least one of these behaviors does not conflict with concurrent tasks, then there is an admissible execution of the action in parallel with these tasks. Unfortunately, existing implementations of the atomic paradigm --- optimistic as well as pessimistic --- are unable to fully exhaust the parallelism potential of nondeterministic actions, lacking the means to guide concurrent tasks toward nondeterministic choices that minimize interference.\r\n\r\nThis paper investigates the problem of utilizing parallelism due to nondeterminism. We observe that nondeterminism occurs in many real-world codes. We motivate the need for devising coordination mechanisms that can utilize available nondeterminism. We have developed a system featuring such mechanisms, which leverages nondeterminism in a wide class of query operations, allowing a task to look into the future of concurrent tasks that mutate the shared state during query evaluation and reduce conflict accordingly. We evaluate our system on a suite of 12 algorithmic benchmarks of wide applicability, as well as an industrial application. The results are encouraging.",
      "Key": 1026,
      "URL": null,
      "Title": "Turning Nondeterminism into Parallelism (OOPSLA '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1733,
        1734,
        1735
      ],
      "Abstract": "The C preprocessor is commonly used to implement variability in program families. Despite the widespread usage, some studies indicate that the C preprocessor makes variability implementation difficult and error-prone. However, we still lack studies to investigate preprocessor-based syntax errors and quantify to what extent they occur in practice. In this paper, we define a technique based on a variability-aware parser to find syntax errors in releases and commits of program families. To investigate these errors, we perform an empirical study where we use our technique in 41 program families releases, and more than 51 thousand commits of 8 program families. We find 7 and 20 syntax errors in releases and commits of program families, respectively. They are related not only to incomplete annotations, but also to complete ones. We submit 8 patches to fix errors that developers have not fixed yet, and they accept 75% of them. Our results reveal that the time developers need to fix the errors varies from days to years in family repositories. We detect errors even in releases of well-known and widely used program families, such as Bash, CVS and Vim. We also classify the syntax errors into 6 different categories. This classification may guide developers to avoid them during development.\r\n",
      "Key": 1027,
      "URL": null,
      "Title": "Investigating Preprocessor-Based Syntax Errors (GPCE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1770,
        1772,
        1771,
        1773
      ],
      "Abstract": "Only very few end users have the skills to develop mobile apps\r\nsuch as games or animations. Visual programming languages can\r\nbe very supportive for casual and first-time users, allowing the users\r\nto concentrate on the programming task rather than learning complex\r\nsyntax. This is why visual programming languages are often\r\nused where children are concerned. Nevertheless, studies have\r\nshown that the advantage of visual languages tends to decrease on\r\nlarger tasks or mathematical formulas. The paper distinguishes different\r\napproaches for creating formulas with end user programming\r\nlanguages, namely purely textual, purely visual, and hybrid approaches.\r\nIn our paper we introduce Pocket Code, a new approach\r\nwith visual programming and hybrid formula editing, which combines\r\nthe easiness of visual programming with the effectiveness\r\nand clarity of textual formula displaying. Additionally, we present\r\na proposal of an evaluation of the different approaches to formula\r\nmanipulation in visual programming languages for smartphones.",
      "Key": 1028,
      "URL": null,
      "Title": "Purely Visual and Hybrid Visual/Textual Formula Composition: A Usability Study Plan (PROMOTO Workshop paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1770,
        1776,
        1774,
        1775,
        1773
      ],
      "Abstract": "Pocket Code is a free and open source mobile visual programming \r\nsystem for the Catrobat language. It allows users, starting from \r\nthe age of eight, to develop games and animations with their smartphones. \r\nChildren can create programs with their Android phone, \r\niPhone, Windows Phone, or other smartphone with an HTML5 \r\nbrowser. No notebook or desktop computer is needed. Pocket Code \r\nis inspired by, but distinct from, the Scratch programming system \r\ndeveloped by the Lifelong Kindergarten Group at the MIT Media \r\nLab. This tool demo describes an in-practice experience with Pocket \r\nCode, the Windows Phone IDE for the Catrobat language.",
      "Key": 1029,
      "URL": null,
      "Title": "A Scratch-like visual programming system for Microsoft Windows Phone 8 (PROMOTO Workshop paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1530,
        1531,
        1532
      ],
      "Abstract": "The with statement in JavaScript makes static analysis of JavaScript applications difficult by introducing a new scope at run time and thus invalidating lexical scoping. Therefore, many static approaches to JavaScript program analysis and the strict mode of ECMAScript 5 simply disallow the with statement. To justify exclusion of the with statement, we should better understand the actual usage patterns of the with statement.\r\nIn this paper, we present the usage patterns of the with statement in real-world JavaScript applications currently used in the 898 most popular web sites. We investigate whether we can rewrite the with statements in each pattern to other statements not using the with statement. We show that we can rewrite all the static occurrences of the with statement that do not have any dynamic code generating functions. Even though the rewriting process is not applicable to any dynamically generated with statements, our results are still promising. Because all the static approaches that disallow the with statement also disallow dynamic code generation, such static approaches can allow the with statement using our rewriting process. We formally present our rewriting strategy, provide its implementation, and show its faithfulness using extensive testing. We believe that removing with statements will simplify JavaScript program analysis designs without considering dynamic scope introduction while imposing fewer syntactic restrictions. ",
      "Key": 1030,
      "URL": null,
      "Title": "All about the 'with' Statement in JavaScript: Removing 'with' Statements in JavaScript Applications (DLS '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1731,
        1778,
        1732,
        1777
      ],
      "Abstract": "The growth of applications developed with the support of model transformations makes reuse a required practice, specially when applied to transformation assets (e.g. transformation chains, algorithms, and configuration files). In order to promote reuse one must consider the different implementations, communalities, and variants among these assets. In this domain, a couple techniques have been used as solutions to adapt reusable assets for specific needs. However, so far, no work has discussed their combined use in real software projects. In this paper, we present a new tool named WCT, which can be used to adapt transformation assets. Moreover, through lessons learned in industry, we address some reuse techniques devoted to adapt these assets.",
      "Key": 1031,
      "URL": null,
      "Title": "Supporting Large Scale Model Transformation Reuse (GPCE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1722,
        1723
      ],
      "Abstract": "We argue that synthesizing operations on recursive linked data structures is not as hard as it appears and is, in fact, within reach of current SAT-based synthesis techniques\u2014with the addition of a simple approach that we describe to decompose the problem into smaller parts. To generate smaller pieces of code, i.e., shorter routines, is obviously easier than large and complex routines, and, also, there is more potential for automating the code synthesis.\r\n\r\nIn our work, we present a code generation algorithm for synthesizing operations of linked data structures and, as an example, describe how the proposed algorithm works to synthesize operations of an AVL tree.",
      "Key": 1032,
      "URL": null,
      "Title": "On the Simplicity of Synthesizing Linked Data Structure Operations (GPCE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1779,
        1780,
        1319,
        1781
      ],
      "Abstract": "Integrating a distributed software system using publicly available\r\nsoftware services saves effort, time, and cost. One key step in this\r\nprocess is the service selection which identifies a relevant set of\r\nservices for this integration. In an open service marketplace, it is\r\nhard to judge the trust of software services using a static view\r\n(consisting of service specifications) published by their developers.\r\nInstead, the concepts of trust in the context of services needs to be\r\nproperly quantified, specified, negotiated, and then used in the\r\nselection process. Prevalent service selection and negotiation\r\napproaches do not consider the trust aspect of services. Trustworthy\r\nservice representation, selection, and negotiation are challenging tasks\r\ndue to the subjective and temporal nature of trust, lack of standards,\r\nand associated uncertainty. This proposal defines the trust of a\r\nservice, quantifies the trust by monitoring and aggregating various\r\nevidences, represents the trust in the service specification and\r\nimproves the service selection and negotiation process using this\r\nrepresentation. Publicly available software objects (from Java\r\ncollection framework library) and mobile app services (from the Android\r\nmarketplace) are used as datasets to empirically evaluate this proposal.",
      "Key": 1033,
      "URL": null,
      "Title": "TruSSCom – Proposal for Trustworthy Service Representation Selection and Negotiation for Integrating Software Systems (Doctoral Symposium)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1769,
        1782,
        1338,
        1783
      ],
      "Abstract": "There is a growing trend towards migrating applications and services to the\r\ncloud.  This trend has led to the emergence of different cloud service\r\nproviders (CSPs), in turn leading to different cost models offered by these CSPs\r\nto lease their resources, variabilities in the granularity and specification of\r\nresources provided, and heterogeneous APIs offered by the CSPs to the users to\r\nprogram resource requests and deployment for their cloud-hosted services.\r\nThese challenges make it hard for customers of the cloud to seamlessly\r\ntransition their services to the cloud or migrate between different CSPs.  To\r\naddress these challenges, this paper presents a solution based on model-driven\r\nengineering (MDE).  Specifically, we describe the design of the domain-specific\r\nmodeling languages in our MDE framework and the associated generative mechanisms\r\nthat address the challenges related to estimating performance and cost to host\r\nthe services in the cloud, automated deployment and resource management. ",
      "Key": 1034,
      "URL": null,
      "Title": "Model-driven Performance Estimation, Deployment, and Resource Management for Cloud-hosted Services (DSM'13 Workshop) "
    },
    {
      "Type": "Posters",
      "Authors": [
        1785,
        1784
      ],
      "Abstract": "Most IT companies are interested in investigating new mobile technologies as mobile devices are noticeably prevalent these days. In this study, we collaborated with Volvo IT to identify the extent of conformance to domain-driven architectures when developing Windows Phone 8 (WP8) applications. \r\n\r\nWe took the Action Design Research (ADR) strategy to develop a purchasing order system prototype. We found that\r\nthe Model View View-Model (MVVM) pattern brings high maintainability to WP8 applications, and these applications\r\ncan conform to a domain-driven architecture with, at least,the user interface, domain, communication, and service components.",
      "Key": 1035,
      "URL": null,
      "Title": "Evaluating Domain-Driven Architectural Designs for Windows Phone 8 Mobile Application (Workshop paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1737,
        1736,
        1738,
        1438,
        1291
      ],
      "Abstract": "Program generators for high performance libraries are an appealing solution to the recurring problem of porting and optimizing code with every new processor generation, but only few such generators exist to date. This is due to not only the difficulty of the design, but also of the actual implementation, which often results in an ad-hoc collection of standalone programs and scripts that are hard to extend, maintain, or reuse. In this paper we ask whether and which programming language concepts and features are needed to enable a more systematic construction of such generators. The systematic approach we advocate extrapolates from existing generators: a) describing the problem and algorithmic knowledge using one, or several, domain-specific languages (DSLs), b) expressing optimizations and choices as rewrite rules on DSL programs, c) designing data structures that can be configured to control the type of code that is generated and the data representation used, and d) using autotuning to select the best-performing alternative. As a case study, we implement a small, but representative subset of Spiral in Scala using the Lightweight Modular Staging (LMS) framework. The first main contribution of this paper is the realization of c) using type classes to abstract over staging decisions, i.e. which pieces of a computation are performed immediately and for which pieces code is generated. Specifically, we abstract over different complex data representations jointly with different code representations including generating loops versus unrolled code with scalar replacement---a crucial and usually tedious performance transformation. The second main contribution is to provide full support for a) and d) within the LMS framework: we extend LMS to support translation between different DSLs and autotuning through search.",
      "Key": 1036,
      "URL": null,
      "Title": "Spiral in Scala: Towards the Systematic Construction of Generators for Performance Libraries (GPCE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1785,
        1784
      ],
      "Abstract": "Most IT companies are interested in investigating new mobile technologies as mobile devices are noticeably prevalent these days. In this study, we collaborated with Volvo IT to identify the extent of conformance to domain-driven architectures when developing Windows Phone 8 (WP8) applications. \r\n\r\nWe took the Action Design Research (ADR) strategy to develop a purchasing order system prototype. We found that\r\nthe Model View View-Model (MVVM) pattern brings high maintainability to WP8 applications, and these applications\r\ncan conform to a domain-driven architecture with, at least,the user interface, domain, communication, and service components.",
      "Key": 1037,
      "URL": null,
      "Title": "Evaluating Domain-Driven Architectural Designs for Windows Phone 8 Mobile Applications "
    },
    {
      "Type": "Posters",
      "Authors": [
        1787,
        1788,
        1786
      ],
      "Abstract": "Innovations for today\u2019s vehicle functions are mainly driven by software. They realize comfort systems like automated parking but also safety systems where sensors are continuously monitoring the vehicle\u2019s surroundings to brake autonomously for avoiding collisions with cars, pedestrians, or bicyclists. In simulation environments, various traffic situations with alternative sensor setups are imitated before testing them on prototypical cars. In this paper, we are presenting an MDE approach for managing different sensor setups in a cyber-physical system development environment to leverage automated model verification, support system testing, and enable code generation. For example, the models are used as the single point of truth to configure and generate sensor setups for system validations in a 3D simulation environment. After their validation, a considered sensor configuration is transformed into a constraint-satisfaction model to be solved by the logical programming language Prolog. Based on this transformation, the conformance to the embedded system specification is formally verified and possible pin assignments how to connect the required sensors are calculated. The approach was validated during the development of a self-driving miniature vehicle using an STM32F4-based embedded system running the real-time operating system ChibiOS as the software/hardware interface to the sensors and actors.\r\n",
      "Key": 1038,
      "URL": null,
      "Title": "MDE-based Sensor Management and Verification for a Self-Driving Miniature Vehicle (DSM'13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1790,
        1789
      ],
      "Abstract": "Lab of Things (LoT) is a research platform to interconnect various types of consumer devices and provide remote accessibility and cloud synchronization features. Traditionally programming on the LoT platform has been is done using C# on Microsoft Visual Studio. While the LoT programs written on the .Net framework offers a rich set of functionality, writing programs on LoT can be difficult for developers who are not experienced with the technology involved. In this work, we introduce an innovative programming approach on the LoT framework by building a generic web service and corresponding libraries on the user-friendly TouchDevelop environment. As an example, we implemented the same functionality of the LoT Alerts app using the proposed approach. In addition to a touch-enabled programming environment, the new approach also reduced the length of the program to only a few lines.",
      "Key": 1039,
      "URL": null,
      "Title": "Touch-enabled Programming for the Lab of Things (PROMOTO '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1791
      ],
      "Abstract": "We discuss Refaster, a tool that uses normal, compilable\r\nbefore-and-after examples of Java code to specify a Java\r\nrefactoring. Refaster has been used successfully by the Java\r\nCore Libraries Team at Google to perform a wide variety\r\nof refactorings across Google\u2019s massive Java codebase. Our\r\nmain contribution is that a large class of useful refactorings\r\ncan be expressed in pure Java, without a specialized DSL,\r\nwhile keeping the tool easily accessible to average Java\r\ndevelopers.",
      "Key": 1040,
      "URL": null,
      "Title": "Scalable, Example-Based Refactorings with Refaster (WRT'13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1324
      ],
      "Abstract": "Although software testing is included as a regular part of many programming courses, current assessment techniques used in automated grading tools for evaluating student-written software tests are imperfect. Code coverage measures are typically used in practice, but that approach does not assess how much of the expected behavior is checked by the tests and sometimes, overestimates the true quality of the tests. Two robust and thorough measures for evaluating student-written tests are running each students\u2019 tests against others\u2019 solutions(known as all-pairs testing) and injecting artificial bugs to determine if tests can detect them (also known as mutation analysis). Even though they are better indicators of test quality, both of them posed a number of practical obstacles to classroom use. This proposal describes technical obstacles behind using these two approaches in automated grading. We propose novel and practical solutions to apply all-pairs testing and mutation analysis of student-written tests, especially in the context of classroom grading tools. Experimental results of applying our techniques in eight CS1 and CS2 assignments submitted by 147 students show the feasibility of our solution. Finally, we discuss our plan to combine the approaches to evaluate tests of assignments having variable amounts of design freedom and explain their evaluation method.",
      "Key": 1041,
      "URL": null,
      "Title": "Automated Assessment of Students’ Testing Skills for Improving Correctness of Their Code (Doctoral Symposium)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1317
      ],
      "Abstract": "As Android becomes popular, Android security acquires more and more attentions.\r\nThis paper proposes a new system design strategy for dissemination of high fidelity\r\napplications. We propose to use static and dynamic data flow analysis on Android\r\napplications to detect about how the apps leverage users'/enterprises' sensitive\r\ndata. Also, we plan to build up a cloud-based back-end to safeguard mobile devices.\r\nThe new secure system framework will not only analyze an individual app isolatedly,\r\nbut also analyze the correlation between apps.",
      "Key": 1042,
      "URL": null,
      "Title": "A Secure Play Store for Android"
    },
    {
      "Type": "Posters",
      "Authors": [
        1792
      ],
      "Abstract": "Constructionism is a learning theory that states that we learn more when we construct tangible objects. In the process of building and presenting our work, we make concrete the abstract mental models we've formed, see where they breakdown through the feedback we receive, and revise the models accordingly. Computer programming has long been taught under a constructionist approach using sensory-rich contexts like robots, media, and Logo-style environments. Now, with affordable 3-D printers in the hands of consumers, we have a new medium in which learners may realize their computational ideas. In this demonstration, we share a mobile development environment named Madeup, which empowers its users to navigate 3-D space using a Logo-like imperative and functional language. Every stop in space becomes a vertex in a 3-D model. The generated models may be exported or uploaded to a 3-D printing service.",
      "Key": 1043,
      "URL": null,
      "Title": "Madeup: A Mobile Development Environment for Programming 3-D Models (PROMOTO Workshop)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1391,
        1390
      ],
      "Abstract": "",
      "Key": 1044,
      "URL": null,
      "Title": "Ball-Larus Path Profiling Across Multiple Loop Iterations (OOPSLA'13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1522,
        1540,
        1521,
        1520,
        1523
      ],
      "Abstract": "Type feedback and type inference are two common methods used to optimize dynamic languages such as JavaScript. Each of these methods has its own strengths and weaknesses, and we propose that each can benefit from the other if combined in the right way. We explore the interdependency between these two methods and propose two novel ways to combine them in order to significantly increase their aggregate benefit and decrease their aggregate overhead. In our proposed strategy, an initial type inference pass is applied that can reduce type feedback overhead by enabling more intelligent placement of profiling hooks. This initial type inference pass is novel in the literature. After profiling, a second (and final) type inference pass uses the type information from profiling to generate efficient code. While this second pass is not novel, we significantly improve its effectiveness in a novel way by feeding the type inference pass information about the function signature, i.e., the types of the function\u2019s arguments for a specific function in- vocation. Our results show significant speedups when using these low-overhead strategies, ranging from 1.2\u00d7 to 4\u00d7 over an implementation that does not perform type feedback or type inference based optimizations. Our experiments are carried out across a wide range of traditional benchmarks and realistic web applications. The results also show an average reduction of 23.46% in the size of the profiled data for these benchmarks.",
      "Key": 1045,
      "URL": null,
      "Title": "Improved Type Specialization for Dynamic Scripting Languages (DLS '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1540,
        1539,
        1537,
        1538,
        1536
      ],
      "Abstract": "Static analysis of JavaScript has proven useful for a variety of purposes, including optimization, error checking, security auditing, program refactoring, and more. We propose a technique called type refinement that can improve the precision of such static analyses for JavaScript without any discernible performance impact. Refinement is a known technique that uses the conditions in branch guards to refine the analysis information propagated along each branch path. The key insight of this paper is to recognize that JavaScript semantics include many implicit conditional checks on types, and that performing type refinement on these implicit checks provides significant benefit for analysis precision.\r\nTo demonstrate the effectiveness of type refinement, we implement a static analysis tool for reporting potential type-errors in JavaScript programs. We provide an extensive empirical evaluation of type refinement using a benchmark suite containing a variety of JavaScript application domains, ranging from the standard performance benchmark suites (Sunspider and Octane), to open-source JavaScript applications, to machine-generated JavaScript via Emscripten. We show that type refinement can significantly improve analysis precision by up to 86% without affecting the performance of the analysis.",
      "Key": 1047,
      "URL": null,
      "Title": "Type Refinement for Static Analysis of JavaScript (DLS '13 Paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1564,
        1566,
        1565,
        1568,
        1567
      ],
      "Abstract": "Computing is becoming increasingly distributed. To better prepare students for the challenges of the workplace, computing educators need to introduce issues pertaining to distributed computing. Unfortunately, programming projects in introductory classes are mostly divorced from the students' day-to-day computing experiences. These experiences entail interacting with real-time Web-based data from sources including weather reports, news updates, and restaurant recommendations. The disconnect between student experience and the content of their programming projects is known to drive some students away from computing. To address this problem, we have created an architectural framework that makes real-time web data accessible for introductory programming projects. The framework effectively introduces important real-time distributed computing concepts without overwhelming them with the low-level details that working with such data typically requires. Our preliminary results indicate that our approach can be effective in the context of a typical CS 2 data structures class. We are currently working on extending, improving, and fine-tuning our toolchain to make our framework accessible to other classes in the curriculum.",
      "Key": 1048,
      "URL": null,
      "Title": "Transforming Introductory Computer Science Projects via Real-Time Web Data (SPLASH-E '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1793,
        1794
      ],
      "Abstract": "We propose an enhancement to current parsing and transformation systems\r\nby leveraging the expressive power of Boolean grammars, a generalization\r\nof context-free grammars that adds conjunction and negation operators.\r\nIn addition to naturally expressing a larger class of languages, Boolean\r\ngrammars capture multiple parse trees of the same document\r\nsimultaneously and the ability to switch between these parse \u201cviews\u201d. In\r\nparticular, source transformation and reengineering tasks can benefit\r\nfrom parse views by recasting the input text into whichever parse is\r\nmost suitable for the task at hand.",
      "Key": 1049,
      "URL": null,
      "Title": "Parse Views with Boolean Grammars (Parsing@SLE '13)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1796,
        1797,
        1798,
        1795
      ],
      "Abstract": "Popcorn is a Linux based replicated-kernel Operating System (OS). Popcorn was conceived as a research OS for a wide class of future heterogeneous-ISA hardware. Because of the novelty of such hardware, in which diverse OS-capable CPUs are glued together, it is not clear what level of memory sharing will be provided across these CPUs. In this paper we consider a setup in which diverse CPUs do not share memory. We addressed the problem of providing a consistent replicated process address space amongst different kernels, running on those CPUs, by proposing a new page coherency protocol. We deploy this protocol in Popcorn OS while adding additional functionalities to the Linux kernel to support inter-kernel thread migration and coordination. We tested and evaluated a prototype version of this work in an emulated environment; results shown that the proposed page coherency protocol is correct and effective.",
      "Key": 1050,
      "URL": null,
      "Title": "A Page Coherency Protocol for Popcorn Replicated-kernel Operating System (SPLASH MARC'13)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1801,
        1799,
        1642,
        1722,
        1221,
        1800
      ],
      "Abstract": "Domain-specific languages (DSLs) enable the expression of domain-specific ideas naturally and permit domain-specific verification and compilation strategies. Embedding DSLs within host languages has advantages for interoperation between the DSLs and general-purpose code in the host language. Designing a language that supports embedded DSLs that can use their own syntax and integrate well with the host language, however, is challenging. One reason is that it can be difficult to ensure that the parsing extensions for different DSLs do not conflict with each other or with the host language's syntax.\r\n\r\nWe are developing a new approach to parsing for embedded DSLs, which uses the host language's type system to decide how to parse a block of DSL code. In our approach, a type can be associated with a DSL that defines its own parser, which provides extensibility and avoids parsing conflicts. The approach is embedded in the Wyvern language that we are currently developing. Our presentation will elaborate on the motivation for Wyvern and on the mechanism described above.",
      "Key": 1051,
      "URL": null,
      "Title": "Extensible Type-Driven Parsing for Embedded DSLs in Wyvern (Parsing @ SLE '13)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1803,
        1802,
        1804
      ],
      "Abstract": "The advent of the Single-chip Cloud Computer (SCC) chip in the many-core realm imposes challenges to programmers. From a programmer's perspective is desirable to use the shared memory paradigm, employing high-level parallel programming abstractions such as OpenMP model based on this paradigm. In this paper we discuss our ongoing efforts to support OpenMP on SCC. Specifically, we focus on the following threes key aspects in our approach: i) Investigating the implementation directly uses SCC hardware support. ii) How to handle OpenMP shared variables. iii) high-level barrier implementation directly uses SCC hardware support. To meet this need, we propose effective barrier synchronization implementations for OpenMP on the SCC. In particular, we present an efficient evaluation of the overhead associated with integration barrier algorithms that is required for OpenMP run-time libraries on such a machine. Our initial experimental results show significant performance improvement up to 98% for 48 cores.",
      "Key": 1052,
      "URL": null,
      "Title": "An approach for Supporting OpenMP on the Intel SCC"
    },
    {
      "Type": "Posters",
      "Authors": [
        1806,
        1805,
        1807
      ],
      "Abstract": "Many large mainframe based business applications were developed with proprietary macro-based generator systems. To maintain these applications the legacy generators employed to generate them have to be maintained as well. This is a problem because of the generator code that is often hard to understand. A solution would be to replace the old generator technology with a new one. However, this requires a deep understanding of the old generators and the features of the programs they generate. This understanding is currently not available. We propose program slicing as a technique to support program understanding of generators and show its application in four use cases in that domain. We show the feasibility of the technique using real-world generators.",
      "Key": 1053,
      "URL": null,
      "Title": "Program Slicing to Understand Software Generators (FOSD Workshop)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1428,
        1427,
        1397
      ],
      "Abstract": "Java generics are compiled by-erasure: all clients reuse the same bytecode, with uses of the unknown type erased. C++ templates are compiled by-expansion: each type-instantiation of a template produces a different code definition. The two approaches offer tradeoffs on multiple axes. We propose an extension of Java generics that allows by-expansion translation relative to selected type parameters only. This language design allows sophisticated users to get the best of both worlds at a fine granularity. Furthermore, our proposal is based on Java 8 Type Annotations (JSR 308) and the Checker Framework as an abstraction layer for controlling compilation without changes to the internals of a Java compiler.",
      "Key": 1054,
      "URL": null,
      "Title": "Reified Type Parameters Using Java Annotations (GPCE '13)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1809,
        1812,
        1808,
        1811,
        1810
      ],
      "Abstract": "In the construction of object-oriented user interfaces, a significant amount of time is usually spent in a few rutinary tasks related to the transference of data between domain objects and user interface components. Multiple repetitions of these simple tasks are a common source of programming errors. Binding-based MVC architectures, such as Direct Manipulation, MVVM and MVB, reduce these tasks but introduce some non-trivial issues like canceling the current operation and rolling back changes. This work proposes an aspect-oriented solution to these problems combining well-known aspect-oriented techniques, such as observable objects and software transactions, to provide a simple and transparent MVC implementation. Our solution focuses on providing warranties of atomicity, consistency and isolation of objects environments and it demonstrated to be useful in a big range of applications.",
      "Key": 1055,
      "URL": null,
      "Title": "Enhancing Binding-based User Interfaces with Transaction Support"
    },
    {
      "Type": "Posters",
      "Authors": [
        1609,
        1604,
        1611,
        1610
      ],
      "Abstract": "Applications are increasingly distributed and event-driven. Advances\r\nin web frameworks have made it easier to program standalone servers\r\nand their clients, but these applications remain hard to write. A\r\nmodel-based programming paradigm is proposed that allows a programmer\r\nto represent a distributed application as if it were a simple\r\nsequential program, with atomic actions updating a single, shared\r\nglobal state.  A runtime environment executes the program on a\r\ncollection of clients and servers, automatically handling (and hiding\r\nfrom the programmer) complications such as network communication\r\n(including server push), serialization, concurrency and races,\r\npersistent storage of data, and queuing and coordination of events.",
      "Key": 1056,
      "URL": null,
      "Title": "Model-Based, Event-Driven Programming Paradigm for Interactive Web Applications (Onward '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1368,
        1367
      ],
      "Abstract": "",
      "Key": 1057,
      "URL": null,
      "Title": "CDSChecker: Checking Concurrent Data Structures Written with C/C++ Atomics (OOPSLA '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1463,
        1461,
        1462
      ],
      "Abstract": "Emerging high-performance architectures are anticipated to contain unreliable components that may exhibit soft errors, which silently corrupt the results of computations. Full detection and recovery from soft errors is challenging, expensive, and, for some applications, unnecessary. For example, approximate computing applications (such as multimedia processing, machine learning, and big data analytics) can often naturally tolerate soft errors.\r\n\r\nIn this paper we present Rely, a programming language that enables developers to reason about the quantitative reliability of an application -- namely, the probability that it produces the correct result when executed on unreliable hardware. Rely allows developers to specify the reliability requirements for each value that a function produces.\r\n\r\nWe present a static quantitative reliability analysis that verifies quantitative requirements on the reliability of an application, enabling a developer to perform sound and verified reliability engineering. The analysis takes a Rely program with a reliability specification and a hardware specification that characterizes the reliability of the underlying hardware components and verifies that the program satisfies its reliability specification when executed on the underlying unreliable hardware platform. We demonstrate the application of quantitative reliability analysis on six computations implemented in Rely.",
      "Key": 1058,
      "URL": null,
      "Title": "Verifying Quantitative Reliability for Programs that Execute on Unreliable Hardware (OOPSLA '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1604,
        1603
      ],
      "Abstract": "It is commonly asserted that the success of a software development, and the usability of the final product, depend on the quality of the concepts that underlie its design. Yet this hypothesis has not been systematically explored by researchers, and conceptual design has not played the central role in the research and teaching of software engineering that one might expect.\r\n\r\nAs part of a new research project to explore conceptual design, we are engaging in a series of case studies. This paper reports on the early stages of our first study, on the Git version control system. Despite its widespread adoption, Git puzzles even experienced developers and is not regarded as easy to use. In an attempt to understand the root causes of its complexity, we analyze its conceptual model and identify some undesirable properties; we then propose a reworking of the conceptual model that forms the basis of (the first version of) Gitless, an ongoing effort to redesign Git and experiment with the effects of conceptual simplifications.",
      "Key": 1059,
      "URL": null,
      "Title": "What's Wrong with Git? A Conceptual Design Analysis (Onward! '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [

      ],
      "Abstract": "Domain-specific languages (DSLs) can improve software maintainability due to\r\nless verbose syntax, avoidance of boilerplate code, more accurate static\r\nanalysis, and domain-specific tool support. However, most existing\r\napplications cannot capitalize on these benefits because they were not\r\ndesigned to use DSLs, and rewriting large existing applications from scratch\r\nis infeasible.\r\nWe propose a process for evolving existing software to use embedded DSLs\r\nbased\r\non modular definitions and applications of syntactic sugar as provided by the\r\nextensible programming language SugarJ.\r\nOur process is incremental along two dimensions: A developer can add support\r\nfor another DSL as library, and a developer can refactor more code to use the\r\nsyntax, static analysis, and tooling of a DSL. Importantly, the application\r\nremains executable at all times and no complete rewrite is necessary. We\r\nevaluate our process by incrementally evolving the Java Pet Store and a\r\ndeliberately small part of the Eclipse IDE to use language support for\r\nfield-accessors, JPQL, XML, and XML Schema.\r\nTo help maintainers to locate Java code that would benefit from using\r\nDSLs, we\r\ndeveloped a tool that analyzes the definition of a DSL to derive patterns of\r\nJava code that could be represented with a high-level abstraction of the\r\nDSL instead.",
      "Key": 1060,
      "URL": null,
      "Title": "Software Evolution to Domain-Specific Languages (SLE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1820,
        1821,
        1819,
        1818
      ],
      "Abstract": "There are many tools available for the creation of domain specific languages, but the question remains how to identify appropriate use cases for the application of domain specific modeling and language design, and how to measure success. We report on our observations after 3 years of accompanying several real-life industrial DSL design projects and on our experiments with applying qualitative and quantitative evaluation criteria. We suggest an evaluation methodology spanning the entire DSL life cycle. It consists of an assessment of motivation, qualitative interviews, a validation of DSL design, quantifying benefits and a comparison of impacted workflows before and after adoption. We conclude with a discussion of inherent limitations.",
      "Key": 1061,
      "URL": null,
      "Title": "Evaluating the Benefits of Using Domain-Specific Modeling Languages - an Experience Report (DSM '13)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1322
      ],
      "Abstract": "Meta-programming has shown much promise for improving the quality of software. A system that supports meta-programming is able to generate or manipulate other programs to extend their behaviour. Thus far, the power of meta-programming has not been explored deeply in the area of High Performance Computing (HPC). We propose to bring the power of meta-programming to languages that may be used in HPC to help to solve various problems in HPC software related to efficiency, scalability, and adaptation. In our initial efforts we have implemented a meta-programming framework called OpenFortran to build arbitrary source-to-source program transformation libraries for Fortran programs. The design focus of OpenFortran is to enable program transformation in a manner that is transparent to application programmers. Similarly, we have also built a framework for C called OpenC. In this doctoral symposium summary, we present the idea of building a generalized meta-programming framework suitable for extending an arbitrary programming language, which would allow source-to-source program transformation. We also describe the possibility of solving problems emerging in HPC software via program transformation.",
      "Key": 1062,
      "URL": null,
      "Title": "Program Transformation Techniques Applied to Languages Used in High Performance Computing"
    },
    {
      "Type": "Posters",
      "Authors": [
        1519,
        1517,
        1518
      ],
      "Abstract": "Gradual typing enables a smooth and progressive integration of\r\n  static and dynamic typing. The semantics of a gradually-typed\r\n  program is given by translation to an intermediate language with\r\n  casts: runtime type checks that control the boundaries between\r\n  statically- and dynamically-typed portions of a program. This paper\r\n  studies the performance of different cast insertion strategies in\r\n  the context of Gradualtalk, a gradually-typed Smalltalk. We first\r\n  implement the strategy specified by Siek and Taha, which inserts\r\n  casts at call sites. We then study the dual approach, which consists\r\n  in performing casts in callees. Based on the observation that both\r\n  strategies perform well in different scenarios, we design a hybrid\r\n  strategy that combines the best of each approach. We evaluate these\r\n  three strategies using both micro- and macro-benchmarks. We also\r\n  discuss the impact of these strategies on memory, modularity, and\r\n  inheritance. The hybrid strategy constitutes a promising cast\r\n  insertion strategy for adding gradual types to existing\r\n  dynamically-typed languages.",
      "Key": 1063,
      "URL": null,
      "Title": "Cast Insertion Strategies for Gradually-Typed Objects (DLS '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1826,
        1825
      ],
      "Abstract": "",
      "Key": 1065,
      "URL": null,
      "Title": "MIT App Inventor: Enabling Personal Mobile Computing"
    },
    {
      "Type": "Posters",
      "Authors": [
        1221
      ],
      "Abstract": "Three years ago in this venue, Cook argued that the essence of objects is procedural data abstraction. His observation raises a natural question: if procedural data abstraction is the essence of objects, has it contributed to the empirical success of objects, and if so, how?\r\n\r\nThis essay attempts to answer that question. It begins by reviewing Cook's definition and then, following Kay, broadens the scope of inquiry to consider objects that abstract not just data, but higher-level goals. Using examples taken from object-oriented frameworks, I illustrate the unique design leverage that objects provide: the ability to define abstractions that can be extended, and whose extensions are interoperable. The essay argues that the form of interoperable extension supported by objects is essential to modern software: many modern frameworks and ecosystems could not have been built without objects or their equivalent. In this sense, the success of objects was not a coincidence: it was inevitable.",
      "Key": 1066,
      "URL": null,
      "Title": "The Power of Interoperability: Why Objects Are Inevitable"
    },
    {
      "Type": "Posters",
      "Authors": [
        1828,
        1827
      ],
      "Abstract": " Many of the computer models used in scientific research have been\r\n developed in Fortran over many years. This evolutionary process\r\n means these models inevitably utilise deprecated features and idioms\r\n of the language that impede software maintenance.  To mitigate this,\r\n we built CamFort, an open-source automated refactoring tool\r\n for upgrading Fortran source code.  We describe\r\n functionality in CamFort for removing equivalence statements\r\n and common blocks, and for deriving structured data types, and we\r\n give examples of how these transformations can benefit codebase\r\n robustness. We would like to encourage programmers to try CamFort on\r\n their own projects to guide further improvements in the tool.",
      "Key": 1067,
      "URL": null,
      "Title": "Upgrading Fortran source code using automatic refactoring"
    },
    {
      "Type": "Posters",
      "Authors": [
        1474,
        1476
      ],
      "Abstract": "Mathematical induction is a difficult subject for beginning students of computer science to fully grasp. In this short paper, we propose using functional programming and proof assistants as an aide in teaching mathematical induction in a traditional discrete mathematics course. To demonstrate this approach, we created a proof-of- concept web-based tutorial on induction. In this tutorial, students write small functional programs and prove simple properties about them using inductive reasoning. The functional programming language is deliberately designed to be minimalistic so that it can be picked up quickly, especially if the student is already familiar with a functional programming language, and not be a distraction to the ultimate goal of learning induction. Furthermore, the tutorial features an online IDE for entering programs and proofs to minimize the barrier to entry for students and instructors.",
      "Key": 1068,
      "URL": null,
      "Title": "Teaching Induction with Functional Programming and A Proof Assistant"
    },
    {
      "Type": "Posters",
      "Authors": [
        1829,
        1207
      ],
      "Abstract": "In a variety of contexts \u2013 from social media to wireless sensor networks \u2013 we see increasingly complex patterns of communication, often characterized by having multiple senders for messages. This paper argues that existing communication mechanisms do not adequately support many-to-many communication, and proposes multicall \u2013 a richer form of blocking broadcast \u2013 as a possible solution. The syntax and implementation of multicall are presented, followed by examples to illustrate how multicall can be used to program many-to-many communication.",
      "Key": 1069,
      "URL": null,
      "Title": "Supporting Many-to-Many Communication (AGERE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1831,
        1830,
        1832
      ],
      "Abstract": "The actor model is present in many systems that demand substantial computing resources which are often provided by multicore and multiprocessor platforms such as non-uniform memory access architectures (NUMA) and manycore processors. Yet, no actor model runtime environment (RE) currently in use takes into account the hierarchical memory characteristics of these platforms. These REs essentially assume a flat-memory space therefore not performing as well as they could. In this paper we present our proposal to improve the performance of these systems. Using knowledge\r\nabout the general characteristics of actor-based applications and the underlying platform, we propose techniques spanning from memory management to scheduling and load-balancing. We evaluated some of these modifications on a real actor RE running on a NUMA machine using standard benchmarks. This modified RE improved the performance of the tested applications by a factor of 2.50 on the best case while limiting the slowdown on the worst case by a factor of 1.09. We also present our design guidelines for the RE adaptation to the Kalray MPPA-256 manycore processor.",
      "Key": 1070,
      "URL": null,
      "Title": "Improving the Performance of Actor Model Runtime Environments on Multicore and Manycore Platforms (AGERE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1837,
        1838,
        1839,
        1840
      ],
      "Abstract": "The Actor Model was originally proposed for a distributed context. However, \r\nmore and more application developers are also starting to use it to program \r\nshared-memory multicore machines because of the safety guarantees it provides. \r\nIt avoids issues such as deadlocks and race conditions by construction, and \r\nthus facilitates concurrent programming. The tradeoff is that the Actor Model \r\nsacrifices expressiveness with respect to accessing shared state because \r\nactors are fully isolated from each other (a.k.a. \"shared-nothing \r\nparallelism\"). There is a need for more high level synchronization mechanisms \r\nthat integrate with the actor model without sacrificing the safety and \r\nliveness guarantees it provides. This paper introduces a variation on the \r\ncommunicating event-loops actor model called the TANK Model. A tank is an \r\nactor that can expose part of it's state as a shared read-only resource. The \r\nmodel ensures that any other actor will always observe a consistent version of \r\nthat state, even while the actor that owns that state is writing to it.",
      "Key": 1077,
      "URL": null,
      "Title": "Tanks: Multiple reader, single writer actors (AGERE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1843,
        1845,
        1844,
        1842,
        1847
      ],
      "Abstract": "Although timed actor-based models attracted more attention in the\r\nrecent years, there is not much done on analyzing and model checking\r\nof such systems. The actor-based language, Timed Rebeca, was\r\nintroduced to model distributed and asynchronous systems with\r\ntiming constraints, and a supporting tool was developed for automated\r\ntranslation of Timed Rebeca models to Erlang. The translated\r\ncode can be executed using McErlang. In this paper, we propose\r\nextensions for Timed Rebeca language to improve the usability\r\nof the language. Designers can now develop more complicated\r\nmodels by calling Erlang custom functions and using lists. Moreover,\r\nto be able to use the new version of McErlang which supports\r\ntiming constructs of Timed Rebeca we changed the mapping and\r\nthe tool accordingly. This gives us the possibility of model checking\r\nand simulation of Timed Rebeca models for the first time. We\r\ncan use the safety monitors in McErlang to verify safety properties\r\nin the model. Also, statistical methods are applied to the simulation\r\nresults to reason about the system behavior. We examine the typical\r\ncase study of elevators to show the applicability of our technique\r\nand tool.",
      "Key": 1080,
      "URL": null,
      "Title": "Model Checking and Performance Evaluation of Timed Rebeca Models Using McErlang"
    },
    {
      "Type": "Posters",
      "Authors": [
        1404
      ],
      "Abstract": "",
      "Key": 1085,
      "URL": null,
      "Title": "Taking Off the Gloves with Reference Counting Immix"
    },
    {
      "Type": "Posters",
      "Authors": [
        1852,
        1855,
        1854,
        1853
      ],
      "Abstract": "Writing concurrent software is challenging, especially with low-level synchronization primitives such as threads or locks in shared memory environments. The actor model replaces implicit communication by an explicit message passing  in a 'shared-nothing' paradigm. It applies to concurrency as well as distribution, but has not yet entered the native programming domain. This paper contributes the design of a native actor extension for C++, and the report on a software platform that implements our design for (a) concurrent, (b) distributed, and (c) heterogeneous hardware environments. GPGPU and embedded hardware components are integrated in a transparent way. Our software plattform supports the development of scalable and efficient parallel software.  It includes a lock-free mailbox algorithm with pattern matching facility for message processing. Thorough performance evaluations reveal an extraordinary small memory footprint in realistic application scenarios, while runtime performance not only outperforms existing mature actor implementations, but exceeds the scaling behavior of low-level message passing libraries such as OpenMPI.",
      "Key": 1088,
      "URL": null,
      "Title": "Native Actors - A Scalable Software Platform for Distributed, Heterogeneous Environments (AGERE '13 paper)"
    },
    {
      "Type": "Posters",
      "Authors": [
        1858,
        1856
      ],
      "Abstract": "In distributed object systems, it is desirable to enable migration of objects between locations, e.g., in order to support efficient resource allocation. Existing approaches build complex routing infrastructures to handle object-to-object communication, typically on top of IP, using, e.g., message forwarding chains or centralized object location servers. These solutions are costly and problematic in terms of efficiency, overhead, and correctness. We show how location independent routing can be used to implement object overlays with complex messaging behavior in a sound, fully abstract, and efficient way, on top of an abstract network of processing nodes connected point-to-point by asynchronous channels. We consider a distributed object language with futures, essentially lazy return values. Futures are challenging in this context due to the global consistency requirements they impose. The key conclusion is that execution in a decentralized, asynchronous network can preserve the standard, network-oblivious behavior of objects with futures, in the sense of contextual equivalence. To the best of our knowledge, this is the first such result in the literature. We also believe the proposed execution model may be of interest in its own right in the context of large-scale distributed computing.",
      "Key": 1089,
      "URL": null,
      "Title": "Efficient and Fully Abstract Routing of Futures in Object Network Overlays"
    },
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 865,
      "URL": null,
      "Title": "Tuesday"
    },
    {
      "Type": "Announcements",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 934,
      "URL": null,
      "Title": "Welcome, Chair's Reports"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1501
      ],
      "Abstract": "Power and energy constraints are now the driving force in devices from\r\nservers to smartphones. Quantitative power, performance, and energy\r\nmeasurements suggest that hardware heterogeneity to match software\r\ndiversity has the potential to deliver energy efficiency.  However,\r\nprogramming heterogeneous hardware directly is a nightmare.  We\r\ndiscuss some approaches and results that abstract, choose, and exploit\r\nhardware heterogeneity. New programming and system abstractions are\r\nessential for establishing a parallel heterogeneous ecosystem in the\r\npost-Dennard era.\r\n",
      "Key": 720,
      "URL": "",
      "Title": "SPLASH — The Yin and Yang of Hardware Heterogeneity: Can Software Survive?"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1372
      ],
      "Abstract": "Parallel programming has long been the realm of experts. Locks, memory models and races were the devils that JavaScript banished at its inception. Parallel JavaScript, named River Trail, rejects the notion that parallelism requires a Faustian bargain. Instead Parallel JavaScript gently extends JavaScript in safe, secure, and programmer-friendly ways resulting in the most important performance change web programmers will enjoy over the next few years.  This talk presents our work on creating a web appropriate and HTML5/JavaScript programmer friendly parallel programming model, the implementation, and how we are building community acceptance. Parallel JavaScript is the leading contender on how to bring parallelism to the masses and is rapidly gaining acceptance both in the standards arena as well as in application arenas as the answer to evolving JavaScript into a more parallel world.\r\n",
      "Key": 750,
      "URL": null,
      "Title": "Parallelism for the Masses: A Parallel JavaScript"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1280,
        1206,
        1281,
        1279
      ],
      "Abstract": "This tutorial will provide an introduction to capsule-oriented programming and introduce the Panini programming language and infrastructure.\r\n\r\nIt is often difficult but necessary to read, write, and reason about concurrent programs, a process which can benefit from better abstractions for concurrency. One promising approach to addressing this problem is the combination of state and control within a linguistic mechanism, as well as the use of asynchronous messages to enable communication between system entities. However, this approach requires programmers adapt to the asynchronous style of programming. Capsule-oriented programming, a new approach to addressing these concerns, focuses on providing sequentially trained programmers with actor-like abstractions via a familiar synchronous model. The programs look similar to sequential programs and maintain sequential semantics, but are implicitly concurrent.\r\n\r\nThis tutorial will begin by discussing capsule-oriented programming. We will then proceed to define the Panini language, a capsule-oriented extension of Java, and work through several hands-on examples which demonstrate the benefits of the language. We will conclude with pointers to the ongoing design and implementation work of the language. ",
      "Key": 748,
      "URL": "",
      "Title": "Capsule-Oriented Programming: Concurrency Made Simple"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1262,
        1284
      ],
      "Abstract": "The Spoofax language workbench is a platform for the development of textual software languages with state-of-the-art IDE support. Spoofax provides a comprehensive environment that integrates syntax definition, name binding, program transformation, code generation, and declarative specification of IDE components. It supports agile development of languages by allowing incremental, iterative development of languages and showing editors for the language under development alongside its definition.\r\n\r\nThis tech talk presents principles and techniques for the design and implementation of software languages in Spoofax, illustrated using a subset of Java. These techniques are explained using Spoofax\u2019s high-level DSLs for language engineering. Spoofax\u2019s testing language enables test-driven language engineering. The syntax definition formalism SDF supports modular definition of (composite) languages. The name binding language NaBL enables declarative definitions of name binding and scope rules of software languages. The Stratego transformation language unifies model transformation and code generation. The use of concrete object syntax allows structured transformation patterns to be phrased in the syntax of the source language.",
      "Key": 738,
      "URL": "",
      "Title": "Interactive Language Design with the Spoofax Language Workbench"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1370,
        1369
      ],
      "Abstract": "Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 SourceForge projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers.\r\n\r\nWe report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages, and the overall number of languages developers are familiar with is independent of age. Developers select more varied languages if their education exposed them to different language families. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as more valuable for properties such as the former rather than for correctness checking.",
      "Key": 813,
      "URL": "http://www.eecs.berkeley.edu/~lmeyerov/projects/socioplt/papers/adoptquant.pdf",
      "Title": "Empirical Analysis of Programming Language Adoption"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1485,
        1486,
        1483,
        1396
      ],
      "Abstract": "Symbolic execution is a promising testing and analysis methodology. It systematically explores a program's execution space and can generate test cases with high coverage. One significant practical challenge for symbolic execution is how to effectively explore the enormous number of program paths. Various heuristics have been proposed for guiding symbolic execution, but they are generally ineffective and ad-hoc. In this paper, we introduce a novel, unified strategy to guide symbolic execution to less explored parts of a program. Our key idea is to exploit a specific type of path spectra, namely the length-*n* subpath program spectra, to systematically approximate full path information for guiding path exploration. In particular, we use frequency distributions of explored length-*n* subpaths to prioritize 'less traveled' parts of the program to improve test coverage and error detection.  We have implemented our general strategy in KLEE, a state-of-art symbolic execution engine. Evaluation results on the GNU Coreutils programs show that (1) varying the length *n* captures program-specific information and exhibits different degrees of effectiveness, and (2) our general approach outperforms traditional strategies in both coverage and error detection.",
      "Key": 851,
      "URL": "http://www.cs.ucdavis.edu/~su/publications/oopsla13-pgse.pdf",
      "Title": "Steering Symbolic Execution to Less Traveled Paths"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1463,
        1461,
        1462
      ],
      "Abstract": "Emerging high-performance architectures are anticipated to contain unreliable components that may exhibit soft errors, which silently corrupt the results of computations.  Full detection and recovery from soft errors is challenging, expensive, and, for some applications, unnecessary.  For example, approximate computing applications (such as multimedia processing, machine learning, and big data analytics) can often naturally tolerate soft errors.\r\n\r\nIn this paper we present Rely, a programming language that enables developers to reason about the quantitative reliability of an application -- namely, the probability that it produces the correct result when executed on unreliable hardware.  Rely allows developers to specify the reliability requirements for each value that a function produces.\r\n\r\nWe present a static quantitative reliability analysis that verifies quantitative requirements on the reliability of an application, enabling a developer to perform sound and verified reliability engineering. The analysis takes a Rely program with a reliability specification and a hardware specification that characterizes the reliability of the underlying hardware components and verifies that the program satisfies its reliability specification when executed on the underlying unreliable hardware platform. We demonstrate the application of quantitative reliability analysis on six computations implemented in Rely.",
      "Key": 844,
      "URL": "",
      "Title": "Verifying Quantitative Reliability of Programs That Execute on Unreliable Hardware"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1542
      ],
      "Abstract": "The R language and runtime was released in 1995 and quickly gained its popularity as a tool for scientific computing. Over the last decade it has become a key platform for implementing data analysis algorithms. Today R has over 5000 open-source packages, an estimated base of 2000 package developers and 2 million end users. For computer scientists, R is a useful tool for analyzing and visualizing experimental results. But most of all it is a challenge for researchers in programming languages and virtual machines. R has function closures with lexical scoping, but also lazy evaluation of function arguments. R allows to reflectively access code as text and to turn text into code and evaluate it in any scope. R code can run in synthetically created scopes, e.g. in data sets. R has rich support for vector arithmetics, including arithmetics with missing data. The talk includes a tutorial on R for computer scientists based on a running example of summarizing results of a DaCapo benchmark and it is intended for anyone who needs to analyze experimental results - no prior knowledge of R is expected. The second part of the talk covers interesting features of the R language which make R a distinctive language but also a challenge for fast execution.",
      "Key": 888,
      "URL": "",
      "Title": "R: A Language for Analyzing Data"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1612,
        1613,
        1563,
        1306,
        1614
      ],
      "Abstract": "The privacy policies of many websites, especially those designed for social sharing, are a product of many inputs.  They are defined by the program underlying the website; by user inputs, such as privacy settings; and by the user interfaces through which users interact. Therefore, the security mechanisms in the interface must be presented so that users can employ them effectively.\r\n\r\nBecause this is an interface design problem, it is typically left as a manual evaluation task for user experience experts. However, interfaces are generated by programs and user input is received and processed by programs. Therefore, usable security should also be approached as a program analysis problem.\r\n\r\nIn this paper we establish a foundation on which to build formal analyses for usable security. We define a formal model for data sharing websites. We present a set of design principles for usable security and formalize these principles with respect to our model. In the formalization, we decompose each principle into two parts: a part amenable to formal analysis, and a part that requires manual evaluation by a designer. We demonstrate the potential of this approach through a preliminary analysis of GitHub using our model.",
      "Key": 926,
      "URL": null,
      "Title": "Usable Security as a Static Analysis Problem: Modeling and Reasoning About User Permissions in Social-Sharing Systems"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1609,
        1604,
        1611,
        1610
      ],
      "Abstract": "Today's applications are increasingly distributed and event-driven. Advances in web frameworks have made it easier to program standalone servers and their clients, but these applications remain hard to write. A new model-based programming paradigm is proposed that allows a programmer to represent such an application as if it were a simple sequential program, with atomic actions updating a single, shared global state.  A runtime environment executes the program on a collection of clients and servers, automatically handling (and hiding from the programmer) complications such as network communication (including server push), serialization, concurrency and races, persistent storage of data, and queuing and coordination of events. Moreover, a fully functional user interface can be generated automatically from the model. Last but not least, because the modeling language is reducible to first order relational logic, the action descriptions can be manipulated by tools to generate test cases automatically, and to perform software model checking to check critical properties. Several sample applications have been implemented in the framework and are compared to existing implementations.",
      "Key": 925,
      "URL": null,
      "Title": "Model-Based, Event-Driven Programming Paradigm for Interactive Web Applications"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1604,
        1603
      ],
      "Abstract": "It is commonly asserted that the success of a software development, and the usability of the final product, depend on the quality of the concepts that underlie its design. Yet this hypothesis has not been systematically explored by researchers, and conceptual design has not played the central role in the research and teaching of software engineering that one might expect.\r\n\r\nAs part of a new research project to explore conceptual design, we are engaging in a series of case studies. This paper reports on the early stages of our first study, on the Git version control system. Despite its widespread adoption, Git puzzles even experienced developers and is not regarded as easy to use. In an attempt to understand the root causes of its complexity, we analyze its conceptual model and identify some undesirable properties; we then propose a reworking of the conceptual model that forms the basis of (the first version of) Gitless, an ongoing effort to redesign Git and experiment with the effects of conceptual simplifications.\r\n\r\nKeywords: software design, concepts, conceptual modeling, conceptual integrity, design, version control, Git",
      "Key": 921,
      "URL": null,
      "Title": "What’s Wrong with Git? A Conceptual Design Analysis"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1633,
        1634,
        1632
      ],
      "Abstract": "This talk gives an overview of Julia. Julia is a high-level, high-performance dynamic programming language for technical computing, with syntax that is familiar to users of other technical computing environments. It provides a sophisticated compiler, distributed parallel execution, numerical accuracy, and an extensive mathematical function library.",
      "Key": 939,
      "URL": null,
      "Title": "Julia, the language"
    },
    {
      "Type": "Onward! Steering Committee",
      "Authors": [
        1592,
        1308,
        1637,
        1262,
        1625,
        1626,
        1628,
        1822,
        1529,
        1823
      ],
      "Abstract": "",
      "Key": 1064,
      "URL": null,
      "Title": "Onward! Steering Committee Meeting"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1267
      ],
      "Abstract": "Students about to graduate are usually faced with the choice of continuing their career in academia or in industry. Research students may want to stay in research, and industrial research often beckons (who wants to grade assignments?), but - judging by the candidates I interview - few know much about industrial research and how it differs from academic research. Indeed, many in industry don't know what industrial research labs do. This talk will attempt to paint a clear picture, based on my experiences. What's the function of an industrial research lab? How are they organized and run? What are their goals? Why would you want to work in one \u2013 or not? \r\n",
      "Key": 742,
      "URL": null,
      "Title": "So you want to be an industrial researcher? "
    },
    {
      "Type": "Panels",
      "Authors": [
        1306
      ],
      "Abstract": "![Shriram Krishnamurthi](http://splashcon.org/2013/images/photos/krishnamurthi-debate.jpg)\r\n\r\nThe software sciences are rich in artifacts: programs, yes, but also datasets, tests, execution logs, models, and more. Yet, our research is evaluated entirely on the content of bitmapped encodings of partial views of these artifacts. In reality, the work is embodied at least as much in this constellation of artifacts as in the paper that describes them. It\u2019s time artifacts got their due.\r\n\r\nHow did we arrive at the current state of affairs? Decades ago, our discipline made the important step from the specific to the general: one could no longer publish a paper merely for having built something, but rather needed to learn something from the experience, and distill what they learned into packaged, reusable scientific knowledge. This was an important, necessary step for the discipline. In making this shift, however, we have devalued the artifacts that embody and lead to that knowledge. We should restore this missing balance.\r\n\r\nNaturally, not every paper needs to be accompanied by an artifact. In particular, entirely theoretical or speculative ideas are as valuable as ever. However, an artifact-driven paper that is not accompanied by an artifact that can be evaluated independently should perhaps rightly be regarded with some suspicion. It remains \u2014 as it already is \u2014 the responsibility of program committees to assess these submissions. Formalizing artifact evaluation merely forces authors to be clear on what type of paper they are claiming to submit, so program committees can arrive at more informed decisions.\r\n\r\nWhat might we learn from evaluating artifacts? The most negative interpretation is that they increase honesty and decrease outright fraud. More neutrally, they help reviewers form a fuller picture of what a paper accomplishes: for instance, where the artifacts are executable, reviewers can experiment with new inputs, building a better understanding of what the system does. In the best case, the process can even teach reviewers new things that the papers did not cover.\r\n\r\nThe beauty and power of the peer review process is, by applying diverse viewpoints to an effort, it raises questions the initial authors did not consider. The more inputs the reviewers have to work with, the better they can function.",
      "Key": 872,
      "URL": null,
      "Title": "Point"
    },
    {
      "Type": "Panels",
      "Authors": [
        1507
      ],
      "Abstract": "![James Noble](http://splashcon.org/2013/images/photos/noble-debate.jpg)\r\n\r\nScience is about knowledge. Engineering is about products. We should not confuse the two, but artifact evaluation is based in this confusion. Ideas, algorithms, and studies should not be accepted based on how easy they are to obtain, install, run, or how much memory you need to start a virtual machine.\r\n\r\nArtifact evaluation is biased against many kinds of research. Good human ethics research practice requires confidentiality or anonymity. Companies often need to keep their code (and especially their customers' code) in house. Double blind artifact evaluation is biased against large and complex systems of systems: how can you evaluate a web-based system without leaking identity (other than virtualizing the entire infrastructure?) Under some qualitative research methods (such as ground theory) it simply does not make sense to \"re-analyze\" data \u2014 reproducibility requires doing new studies.\r\n\r\nFinally, artifact evaluation discourages innovation and encourages rent seeking. Toolsmiths have vested interests in encouraging researchers to build upon their mature tools, rather than hacking together quick prototypes, or just working things out on paper. New programs, languages, systems, applications, and proof techniques will obviously be more fragile that more established methods. In no other research discipline are papers evaluated upon how easily experimental equipment can be packaged up and moved into other labs, rather than on the quality of the results, descriptions, and analyses.",
      "Key": 873,
      "URL": null,
      "Title": "Counterpoint"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1357,
        1358
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nState-of-the-art dynamic bug detectors such as data race and memory leak detectors report program locations that are likely causes of bugs. However, static program locations are not enough for developers to understand the behavior of increasingly complex and concurrent software. Dynamic calling context provides additional information, but it is expensive to record calling context frequently, e.g., at every read and write. Context-sensitive dynamic analyses can build and maintain a calling context tree to track calling context, but in order to reuse existing nodes, CCT-based approaches require an expensive lookup.\r\n\r\nThis paper introduces a new approach for context sensitivity that avoids this expensive lookup. The approach uses a new data structure called the calling context uptree (CCU) in which each node points 'up' to its parent instead of 'down' to its children. Our CCU-based approach adds low time overhead by avoiding the lookup and instead allocating a node. A key contribution is that the approach can mitigate the costs of allocating many nodes by extending tracing-based garbage collection (GC): GC collects unused CCU nodes naturally and efficiently, and we extend GC to merge duplicate nodes lazily.\r\n\r\nWe implement our CCU-based approach in a high-performance Java virtual machine and integrate it with a staleness based memory leak detector and happens-before data race detector, so they can report context-sensitive program locations that cause bugs. We show that the CCU-based approach, in concert with an extended GC, can provide good time and space performance for context-sensitive bug detection analyses.",
      "Key": 808,
      "URL": "http://www.cse.ohio-state.edu/~mikebond/ccu-oopsla-2013.pdf",
      "Title": "Efficient Context Sensitivity for Dynamic Analyses via Calling Context Uptrees and Customized Memory Management"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1437,
        1438,
        1436
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nParametric polymorphism enables code reuse and type safety. Underneath the uniform interface exposed to programmers, however, its low level implementation has to cope with inherently non-uniform data: value types of different sizes and semantics (bytes, integers, floating point numbers) and reference types (pointers to heap objects). On the Java Virtual Machine, parametric polymorphism is currently translated to bytecode using two competing approaches: homogeneous translation requires boxing, and thus introduces indirect access delays. Heterogeneous translation duplicates code and adapts it to each value type individually, inflating the bytecode size. Therefore speed and size are at odds with each other. This paper proposes a novel translation which improves the situation by significantly reducing the bytecode size without affecting the execution speed. The key insight is that all non-pointer types can be encoded on long integers, reducing the need to duplicate code for each value type. The resulting bytecode approaches the performance of monomorphic code and obtains speedups of up to 22x over the homogeneous translation, all with modest increases in size.",
      "Key": 835,
      "URL": "http://infoscience.epfl.ch/record/188060/files/miniboxing-oopsla.pdf",
      "Title": "Miniboxing: Improving the Speed to Code Size Tradeoff in Parametric Polymorphism Translations"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1501,
        1404,
        1283,
        1502
      ],
      "Abstract": "Despite some clear advantages and recent advances, reference counting remains a poor cousin to high performance tracing garbage collectors. The advantages of reference counting include a) immediacy of reclamation, b) incrementality, and c) local scope of its operations. After decades of languishing with hopelessly bad performance, recent work narrowed the gap between reference counting and tracing collectors to within 10% of the fastest collectors. Though a major advance, this gap remains a substantial barrier to adoption in performance-conscious application domains. Our work identifies heap organization as the principal source of the remaining performance gap. We present the design, implementation, and analysis of a new collector, RC Immix, that replaces reference counting's traditional free-list heap organization with the line and block heap structure introduced by the Immix collector. The key innovations are a) to combine traditional reference counts with per-line live object counts to identify reusable memory and b) to proactively and reactively mitigate fragmentation by copying objects opportunistically , which means copying until all available space is consumed during a collection. The line and block heap organization delivers excellent mutator locality and efficient allocation, closing the 10% performance gap, such that RC Immix matches the performance of a highly tuned production generational collection. By removing the performance barrier, our work transforms reference counting into a serious alternative for meeting high performance objectives for garbage collected languages.\r\n\r\nKeywords: Reference Counting, Memory Management, Garbage Collection, Java",
      "Key": 825,
      "URL": "http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rcix-oopsla-2013.pdf",
      "Title": "Taking Off the Gloves with Reference Counting Immix"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1363
      ],
      "Abstract": "Modern object-oriented applications commonly suffer from severe performance problems that need to be optimized away for increased efficiency and user satisfaction. Many existing optimization techniques (such as object pooling and pretenuring) require precise identification of object lifetimes. However, it is particularly challenging to obtain object lifetimes both precisely and efficiently: precise profiling techniques such as Merlin introduce multiple hundred times slowdown even for small programs while efficient approximation techniques often sacrifice precision and produce less useful lifetime information. This paper presents a tunable profiling technique, called Resurrector, that explores the middle ground between the high precision and the high efficiency to find the precision-efficiency sweetspot for various liveness-based optimization techniques. Our evaluation shows that Resurrector is both more precise and more efficient than the GC-based approximation, and it is orders-of-magnitude faster than Merlin. To demonstrate Resurrector's usefulness, we have developed client analyses to find allocation sites that create large data structures with disjoint lifetimes. By inspecting program source code and reusing data structures created from these allocation sites, we have achieved significant performance gains. We have also improved the precision of an existing optimization technique using the lifetime information collected by Resurrector.",
      "Key": 810,
      "URL": "http://www.ics.uci.edu/~guoqingx/papers/xu-oopsla13.pdf",
      "Title": "Resurrector: A Tunable Object Lifetime Profiling Technique for Optimizing Real-World Programs"
    },
    {
      "Type": "Wavefront",
      "Authors": [
        1582
      ],
      "Abstract": "Proliferation of the Internet is enabling the use of sensors and actuators to capture data and control devices remotely in a multitude of contexts.  Still, there is a general lack of best practices while designing large scale real-time systems.  This paper proposes a generic architecture for deploying such systems in the cloud, enabling run-time evolution of the system with new sensors, actuators or services possibly developed by third-parties.  Such architecture orchestrates the flow of information in the ecosystem and scales transparently to external components when needed, requiring no change in them.  Application in the Portuguese nation-wide AAL project AAL4ALL is then described.",
      "Key": 908,
      "URL": null,
      "Title": "Sensors, Actuators and Services - A Distributed Approach "
    },
    {
      "Type": "Wavefront",
      "Authors": [
        1583,
        1584
      ],
      "Abstract": "Massive open online courses (MOOCs) aimed at large-scale participation and open access via the Web are disruptive trends that are changing how education is delivered and funded around the world. In the spring of 2013, we developed and taught Vanderbilt's first MOOC offering, entitled \u201cPattern-Oriented Software Architecture for Concurrent and Networked Software\u201d (known as the \u201cPOSA\u201d MOOC). This ten week MOOC was an amalgamation of several courses on software design and programming that roughly 600 undergraduate and graduate students at Vanderbilt have taken over the past decade.  Enrollment in our ten week long POSA MOOC was more than 50 times (30,000+) that number, consisting of students with a wide range of interests and experience from scores of countries around the world. ",
      "Key": 909,
      "URL": null,
      "Title": "Lessons Learned Creating and Teaching a MOOC on Pattern-Oriented Software Design and Programming "
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1258
      ],
      "Abstract": "Functional requirements refer to how a piece of a system functions or what it does given specific inputs. Nonfunctional requirements refer to such business and engineering needs as performance, reliability, availability, stability, usability, compatibility with interfaces, and security. Performance requirements are one of the main drivers of architectural decisions. They may also play a role in the choice of programming languages and environments to be used. Because many performance problems have their roots in architectural decisions, and since poor performance is a principal cause of software project risk, it is essential that performance requirements be developed early in the software lifecycle, and that they be clearly formulated. In this tutorial, we shall look at criteria for high-quality performance requirements, including algebraic consistency, measurability, testability, and linkage to business and engineering needs. While focus of this tutorial is on practice, we shall show how the drafting of performance requirements can be aided by performance modeling. We shall show methods for presenting and managing performance requirements that will improve their chances of being accepted by architects, developers, testers, contract negotiators, and purchasers; and of their being successfully implemented and tested.",
      "Key": 733,
      "URL": "",
      "Title": "Best Practices for Writing and Managing Performance Requirements"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1635
      ],
      "Abstract": " This tutorial is concerned with <i>software languages</i> in a broad sense to include domain-specific languages (DSLs and DSMLs, embedded or not), programming languages as well as intermediate and auxiliary languages in grammarware and modelware. The overarching objective of the tutorial is to foster cross-pollination between the technological spaces with interests in language modeling: modelware, grammarware, and, to some extent, ontoware. <i>Language modeling</i> refers to the process of defining the syntax and semantics of a language while involving different aspects: abstract (tree- versus graph-based) versus concrete (textual versus visual) syntax, parsing, editing, pretty-printing, well-formedness, well-typedness, and other constraints, dynamic semantics in terms of interpretation or reduction, and translation-based semantics.\r\n\r\nThe tutorial walks through a catalogue of <i>language modeling problems</i> and recovers fundamental <i>notions</i> to provide simple, technology-neutral explanations of these problems. The notions, some of them on the verge of extinction, are adopted from diverse disciplines of programming languages and software engineering, e.g., compiler construction, formal semantics, metamodeling, software language engineering, algebraic specification, term rewriting, functional programming, the semantic web, software reverse and re-engineering.\r\n\r\nFor instance, consider the well-known problem of mapping (textual) concrete syntax to abstract syntax. How to model and thus, to fundamentally understand such a mapping in a principled manner? The problem can be explained in terms of these basic notions: algebraic signature, term algebra, algebraic interpretation of a context-free grammar, and signature morphism. This is a suitable foundation for understanding such mappings as facilitated by specific grammarware or modelware technologies. Here are some other language modeling problems: definition-use resolution, type and constraint checking, type inference and logical reasoning, program and model normalization, interpretation, model and program translation and generation, and language embedding. Of course, the idea is not to cover these problems in depth, but to associate them with fundamental notions that explain the problems at a basic level to support helpful and robust intuitions.\r\n\r\nLightweight semi-formal notation, encoded in Prolog or Haskell, is used to capture the involved notions, thereby providing an integrated and executable model of language modeling. Profound background on the aforementioned disciplines is not assumed. Specific grammarware and modelware technologies serve for illustration. Further reading pointers are provided. The tutorial is interactive in that it is designed to pursue continuous discussion on a representative and manageable set of language modeling problems, a suitable and digestible set of notions to explain the problems, and a diverse set of technologies and applications for illustration. ",
      "Key": 942,
      "URL": "",
      "Title": "Language Modeling Principles"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1272,
        1255
      ],
      "Abstract": "In this tutorial, attendees will learn how to design, specify, and implement verified software components.  The tutorial should be of interest to researchers, educators, and software practitioners. They will be involved in hands-on experimentation with construction and modular  verification using a web-integrated software engineering environment that requires no software installation.  The tutorial will discuss how to engineer specifications and how to design and annotate object-based component implementations of software components. To make the ideas concrete, the tutorial will use RESOLVE, an integrated specification and programming language especially designed for building verified components, which features a prototype \u201cpush-button\u201d verifying compiler. It will also summarize the presenters\u2019 experiences in adapting a RESOLVE discipline of component-based development to C++ and Java.",
      "Key": 730,
      "URL": "",
      "Title": "Verified Software Components"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1249
      ],
      "Abstract": "Contemporary web programming offers enormous advantages, and at the same time can be excruciatingly painful. Dart is a response to the very real problems of performance and productivity encountered doing serious programming on the web platform.  Dart is a purely object-oriented, class based, optionally typed imperative programming language focused on web programming. Dart is by design conservative, so as to be accessible to a broad audience of programmers.  Dart has been under intense development at Google since late 2010. We'll go over the motivation for Dart, and discuss the current state of the Dart platform and where we expect it to go next.\r\n",
      "Key": 725,
      "URL": null,
      "Title": "Civilizing Web Programming with Dart"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1270
      ],
      "Abstract": "Data scientists use sophisticated algorithms to obtain insights. However, what takes tens of lines in a high-level data analytics language like R is now been rewritten in Hadoop and applied at scale in the industry. Instead of rewriting algorithms in a new model and language can we stretch the limits of R and reuse it for analyzing Big Data? In this talk I will present our experience in scaling R to efficiently perform distributed machine learning and graph processing on industrial-scale data sets.\r\n",
      "Key": 745,
      "URL": null,
      "Title": "R for Big Data"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1368,
        1367
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nWriting low-level concurrent software has traditionally required intimate knowledge of the entire toolchain and often has involved coding in assembly. New language standards have extended C and C++ with support for low-level atomic operations and a weak memory model, enabling developers to write portable and efficient multithreaded code.\r\n\r\nDeveloping correct low-level concurrent code is well-known to be especially difficult under a weak memory model, where code behavior can be surprising. Building reliable concurrent software using C/C++ low-level atomic operations will likely require tools that help developers discover unexpected program behaviors.\r\n\r\nIn this paper we present CDSChecker, a tool for exhaustively exploring the behaviors of concurrent code under the C/C++ memory model. We develop several novel techniques for modeling the relaxed behaviors allowed by the memory model and for minimizing the number of execution behaviors that CDSChecker must explore.  We have used CDSChecker to exhaustively unit test several concurrent data structure implementations on specific inputs and have discovered errors in both a recently published C11 implementation of a work-stealing queue and a single producer, single consumer queue implementation.",
      "Key": 812,
      "URL": "http://demsky.eecs.uci.edu/publications/c11modelcheck.pdf",
      "Title": "CDSChecker: Checking Concurrent Data Structures Written with C/C++ Atomics"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1441,
        1440,
        1439
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nLike shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug.  Race detection for such programs is hampered by their pervasive use of ad hoc synchronization, which can lead to a prohibitive number of false positives.  Race detection also faces a scalability challenge, as a large number of short-running event handlers can quickly overwhelm standard vector-clock-based techniques.\r\n\r\nThis paper presents several novel contributions that address both of these challenges. First, we introduce race coverage, a systematic method for exposing ad hoc synchronization and other (potentially harmful) races to the user, significantly reducing false positives. Second, we present an efficient connectivity algorithm for computing race coverage. The algorithm is based on chain decomposition and leverages the structure of event-driven programs to dramatically decrease the overhead of vector clocks.\r\n\r\nWe implemented our techniques in a tool called EventRacer and evaluated it on a number of public web sites. The results indicate substantial performance and precision improvements of our approach over the state-of-the-art. Using EventRacer, we found many harmful races, most of which are beyond the reach of current techniques.",
      "Key": 836,
      "URL": "http://researcher.watson.ibm.com/researcher/files/us-msridhar/OOPSLA13EventRacer.pdf",
      "Title": "Effective Race Detection for Event-Driven Programs"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1414,
        1416,
        1415
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nDynamically typed language implementations often use more memory and execute\r\nslower than their statically typed cousins, in part because operations on\r\ncollections of elements are unoptimised. This paper describes storage\r\nstrategies, which dynamically optimise collections whose elements are\r\ninstances of the same primitive type. We implement storage strategies in the\r\nPyPy virtual machine, giving a performance increase of 18% on wide-ranging\r\nbenchmarks of real Python programs. We show that storage strategies are\r\nsimple to implement, needing only 1500LoC in PyPy, and have applicability to\r\na wide range of virtual machines.",
      "Key": 829,
      "URL": "http://tratt.net/laurie/research/pubs/html/bolz_diekmann_tratt__storage_strategies_for_collections_in_dynamically_typed_languages/",
      "Title": "Storage Strategies for Collections in Dynamically Typed Languages"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1605
      ],
      "Abstract": "Programming today involves code editing mixed with bouts of debugging to get feedback on code execution. For programming to be more fluid, editing and debugging should occur not only at the same time, but also in the same space to quickly make use of the resulting live execution feedback. This paper describes how live feedback can be woven into the editor by making places in code execution, not just in code, navigable so evaluation results can be probed directly within the code editor. A pane aside the editor also traces execution with entries that are similarly navigable, enabling quick problem diagnosis. Both probes and traces are refreshed continuously during editing, and are easily configured based on debugging needs. We demonstrate the usefulness of this live programming experience with a prototype.",
      "Key": 922,
      "URL": null,
      "Title": "Usable Live Programming"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1617
      ],
      "Abstract": "Our powerful computers help very little in debugging the program we have so we can change it into the program we want. We introduce Conversational Programming as a way to harness our computing power to inspect program meaning through a combination of partial program execution and semantic program annotation. A programmer in our approach interactively selects highly autonomous \u201cagents\u201d in a program world as conversation topics and then changes the world to explore the potential behaviors of a selected agent in different scenarios. In this way, the programmer proactively knows how their code affects program execution as they explore various contexts. This paper describes conversational programming through design principles and use cases.",
      "Key": 928,
      "URL": null,
      "Title": "Conversational Programming"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1602,
        1492
      ],
      "Abstract": "The increasing adoption of smartphones and tablets has provided tens of millions of users with substantial resources for computation, communication, and sensing. The availability of these resources has a huge potential to positively transform our society and empower the individuals.  The potential for this transformation is limited by a new instance of software crisis, where the number of developers becomes bottleneck more than ever.  We claim that programming by demonstration is the technology that can help us address this bottleneck.  As a concrete step in helping end-users develop software, we present Pong Designer, an environment for developing 2D physics games through direct manipulation of object behaviors.  Pong Designer runs on Android tablets with the multi-touch finger as the main input. It is Turing-complete, yet can intuitively describe many game behaviors. We show that Pong Designer makes it remarkably easy to create games such as (multi-player and multi-screen) Pong, Brick Breaker, Pacman, Tilting maze and many others.",
      "Key": 920,
      "URL": null,
      "Title": "Game Programming by Demonstration"
    },
    {
      "Type": "Panels",
      "Authors": [
        1581,
        1580,
        1224,
        1578,
        1577,
        1579
      ],
      "Abstract": "The term \"Technical Debt\" was coined over 20 years ago by Ward Cunningham in a 1992 OOPSLA experience report. Ward used \"Technical debt\" to describe the trade-offs between delivering the most appropriate &mdash; albeit likely immature &mdash; product, in the shortest time possible. Since then, the repercussions of \"technical debt\" have become more visible, though not necessarily more widely understood. This SPLASH panel will bring together practitioners to discuss and debate \"Technical Debt\".",
      "Key": 907,
      "URL": null,
      "Title": "Panelists"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1305
      ],
      "Abstract": "The last decade has seen concurrency and scale-out programming move from being a niche concern of the High Performance Computing programmer to being one of the central challenges facing mainstream programmers.  During the same decade, the X10 Project at IBM Research has developed the X10 system: a programming model, complete new programming language and tool chain, and a supporting programming environment all designed from the ground up to enable \"Performance and Productivity at Scale.\"  In this talk I will attempt to distill the key insights from the X10 experience, describe how those insights are now being applied in both HPC and commercial contexts, and speculate on how these ideas will continue to influence the development of future programming systems.",
      "Key": 759,
      "URL": null,
      "Title": "Reflections on X10: Towards Performance and Productivity at Scale"
    },
    {
      "Type": "SPLASH Steering Committee",
      "Authors": [
        1308,
        1309,
        1262,
        1544,
        1456,
        1625,
        1626,
        1627,
        1628,
        1629,
        1236,
        1529,
        1622
      ],
      "Abstract": "",
      "Key": 943,
      "URL": null,
      "Title": "SPLASH Steering Committee Meeting"
    },
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 866,
      "URL": null,
      "Title": "Wednesday"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1252
      ],
      "Abstract": "I have spent much of the last fifteen years trying to build bridges \r\nbetween the two solitudes of computing: academic researchers on the one \r\nside, and working developers on the other. These efforts have largely \r\nfailed, but have done so in interesting ways. This talk will explore why \r\nthe wide gulf between research and practice persists, and outline a new \r\nplan for trying to narrow it based on scurvy, smoking, and statistics.\r\n\r\n",
      "Key": 721,
      "URL": null,
      "Title": "OOPSLA — Two Solitudes"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1544,
        1543,
        1545
      ],
      "Abstract": "",
      "Key": 889,
      "URL": null,
      "Title": "Client-Aware Checking and Information Hiding in Interface Specifications with JML/ajmlc"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1591
      ],
      "Abstract": "In a world of devices and the cloud, users want their apps and their data everywhere, all the time. Maintaining responsiveness when connections are slow or temporarily unavailable can be quite difficult, since it requires developers to work with weaker consistency. How to write such programs, and in particular, how to effectively reason about data consistency and conflict resolution, is a key challenge for the next generation of developers. To simplify their task, we propose \"Cloud Sessions\", a programming abstraction that makes it easy to work with eventually consistent structured shared data. Cloud Sessions are available as a feature in TouchDevelop, a cross-platform app development environment by Microsoft Research.",
      "Key": 913,
      "URL": null,
      "Title": "Cloud Sessions: A Simple Face for Eventual Consistency"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1263,
        1264
      ],
      "Abstract": "At any instant when you are programming, some details rise to the foreground and others recede into the background *context*. The manner in which the programming language supports context profoundly affects the ease of evolution and reuse. We propose a language paradigm that amplifies the power of object-oriented programming by explicitly supporting multi-dimensional context, and using it for dispatch and for program organization. It can directly express, in a unified and simple fashion, many situations that are awkward with object-oriented programming or that usually require ad hoc mechanisms. Although it adds complexity to the object-oriented model, an environment can employ subjectivity with progressive disclosure to hide dimensions and present developer-specific views, thereby smoothing the learning curve. In this talk we will introduce and illustrate the paradigm, give some details of context-based dispatch, and show a glimpse of our early prototype.",
      "Key": 739,
      "URL": null,
      "Title": "Dancing with Symmetry to Harness the Power of Complexity: Subjective Programming in Context"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1465,
        1464,
        1438,
        1268
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nSerialization or pickling, i.e., persisting runtime objects by converting them into a binary or text representation is ubiquitous in distributed programming. Pickler combinators are a popular approach from functional programming designed to alleviate some of the tedium of writing pickling code by hand, but they don't translate well to object-oriented programming due to qualities like open class hierarchies and subtyping polymorphism. Furthermore, both functional pickler combinators and Java-based serialization frameworks tend to be tied to a specific pickle format, leaving programmers no choice of how their data is persisted. In this paper, we present object-oriented pickler combinators and a framework for generating them at compile-time, designed to be the default serialization mechanism of the Scala programming language. Our framework is extensible; (1) using Scala's implicit parameters, users can add their own easily-swappable pickle format, (2) using the type class pattern, users can provide their own custom picklers to override the default behavior of the Scala pickling framework. In addition to extensibility and need for little to no boilerplate, the static generation of our OO picklers achieves a factor 6 speedup over Java Serialization, and performs on par or up to 3 times faster than popular \"fast\" Java serialization frameworks like Kryo.",
      "Key": 845,
      "URL": "http://lampwww.epfl.ch/~hmiller/files/oopsla-pickling.pdf",
      "Title": "Instant Pickles: Generating Object-Oriented Pickler Combinators for Fast and Extensible Serialization"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1458,
        1457
      ],
      "Abstract": "Debugging and analyzing a snapshot of a crashed program's memory is far more difficult than working with a live program, because debuggers can no longer execute code to help make sense of the program state. We present an architecture that supports the restricted execution of ordinary code starting from the snapshot, as if the dead objects within it had been restored, but without access to their original external environment. We demonstrate the feasibility of this approach via an implementation for Java that does not require a custom virtual machine, show that it performs competitively with live execution, and use it to diagnose an unresolved memory leak in a mature mainstream application.\r\n\r\nKeywords: programming languages, meta-programming, reflection, runtime analysis",
      "Key": 841,
      "URL": "https://www.cs.ubc.ca/~rsalkeld/publications/oopsla2013.pdf",
      "Title": "Interacting with Dead Objects"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1430,
        1435,
        1433,
        1429,
        1434,
        1431,
        1306,
        1432
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nWe present a small-step operational semantics for the Python programming language.  We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core.  We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.",
      "Key": 834,
      "URL": "http://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/",
      "Title": "Python: The Full Monty;  A Tested Semantics for the Python Programming Language"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1428,
        1427,
        1397
      ],
      "Abstract": "We propose DelphJ: a Java-based OO language that eschews inheritance completely, in favor of a combination of class morphing and (deep) delegation. Compared to past delegation approaches, the novel aspect of our design is the ability to emulate the best aspects of inheritance while retaining maximum flexibility: using morphing, a class can select any of the methods of its delegatee and export them (if desired) or transform them (e.g., to add extra arguments or modify\\ type signatures), yet without needing to name these methods explicitly and handle them one-by-one. Compared to past work on morphing, our approach adopts and adapts advanced delegation mechanisms, in order to add late binding capabilities and, thus, provide a full substitute of inheritance. Additionally, we explore complex semantic issues in the interaction of delegation with late binding. We present our language design both informally, with numerous examples, and\\ formally in a core calculus.",
      "Key": 833,
      "URL": "http://cgi.di.uoa.gr/~smaragd/delphj-oopsla13.pdf",
      "Title": "Forsaking Inheritance: Supercharged Delegation in DelphJ"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1206,
        1260
      ],
      "Abstract": "Mining software repositories provides developers and researchers a chance to learn from previous development activities and apply that knowledge to the future. Ultra-large-scale open source repositories (e.g., SourceForge with 350k+ projects) provide an extremely large corpus to perform such mining tasks on. This large corpus allows researchers the opportunity to test new mining techniques and empirically validate new approaches on real-world data. However, the barrier to entry is often extremely high. Researchers interested in mining must know a large number of techniques, languages, tools, etc, each of which is often complex. Additionally, performing mining at the scale proposed above adds additional complexity and often is difficult.\r\n\r\nThe Boa language and infrastructure was developed to solve these problems. Boa provides a web-based interface for mining ultra-large-scale software repositories. Users use a domain-specific language tailored for software repository mining and submit queries to the website. These queries are then automatically parallelized and executed on a cluster.\r\n\r\nThis tutorial teaches users how to efficiently perform mining tasks on over 600k open-source software projects. We introduce the language and supporting infrastructure and then perform several mining tasks. Users need not be experts in mining: Boa is simple enough for even novices, yet still powerful enough for experts.",
      "Key": 736,
      "URL": "http://boa.cs.iastate.edu/",
      "Title": "Mining Ultra-Large-Scale Software Repositories with Boa"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1278,
        1259
      ],
      "Abstract": "Charm++ is a C++-based parallel programming framework with a 20-year track record of delivering high performance on systems ranging from single workstations to the largest supercomputers in the world. It supports parallel execution across shared and distributed memory systems with no technological discontinuity between the two regimes.\r\n\r\nUsing objects as the units of parallelism, Charm++ allows parallel application logic to be expressed via collections of asynchronously interacting objects. This yields composable parallel software without compromising on the efficient utilization of available hardware. During execution, the runtime system in Charm++ observes application behavior and system conditions, and adapts the mapping of objects to processors accordingly. By doing so, the runtime system can automate many of the domain-independent necessities for good performance, like load balancing, exploiting accelerators, and energy management. Thus, application developers can focus on the requirements of their applications and users.\r\n\r\nThis presentation will introduce attendees to the principles of parallel application development in Charm++. We will explain the advantages of expressing parallel algorithms using this paradigm. Attendees will see several examples of how Charm++ has been applied to create fast, scalable software. They will learn how to express parallel logic to construct their own parallel programs using Charm++.",
      "Key": 735,
      "URL": "",
      "Title": "Parallel Programming with Charm++"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1398,
        1399,
        1397
      ],
      "Abstract": "We present set-based pre-analysis: a virtually universal optimization technique for flow-insensitive points-to analysis. Points-to analysis computes a static abstraction of how object values flow through a program's variables. Set-based pre-analysis relies on the observation that much of this reasoning can take place at the set level rather than the value level. Computing constraints at the set level results in significant optimization opportunities: we can rewrite the input program into a simplified form with the same essential points-to properties. This rewrite results in removing both local variables and instructions, thus simplifying the subsequent value-based points-to computation. Effectively, set-based pre-analysis puts the program in a normal form optimized for points-to analysis.\r\n\r\nCompared to other techniques for off-line optimization of points-to analyses in the literature, the new elements of our approach are the ability to eliminate statements, and not just variables, as well as its modularity: set-based pre-analysis can be performed on the input just once, e.g., allowing the pre-optimization of libraries that are subsequently reused many times and for different analyses. In experiments with Java programs, set-based pre-analysis eliminates 30% of the program's local variables and 30% or more of computed context-sensitive points-to facts, over a wide set of benchmarks and analyses, resulting in a ~20% average speedup (max: 110%, median: 18%).",
      "Key": 822,
      "URL": "http://cgi.di.uoa.gr/~gkast/oopsla2013-set-based.pdf",
      "Title": "Set-Based Pre-Processing for Points-To Analysis"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1488,
        1489,
        1487,
        1490
      ],
      "Abstract": "In a common use case for cloud computing, clients upload data and computation to servers that are managed by a third-party infrastructure provider. We describe MrCrypt, a system that provides data confidentiality in this setting by executing client computations on encrypted data. MrCrypt statically analyzes a program to identify the set of operations on each input data column, in order to select an appropriate homomorphic encryption scheme for that column, and then transforms the program to operate over encrypted data. The encrypted data and transformed program are uploaded to the server and executed as usual, and the result of the computation is decrypted on the client side. We have implemented MrCrypt for Hadoop MapReduce programs in Java and illustrate its practicality on two standard benchmark suites. We have also formalized the approach and proven several soundness and security guarantees.",
      "Key": 852,
      "URL": "",
      "Title": "MrCrypt: Static Analysis for Secure Cloud Computations"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1471,
        1475,
        1474,
        1472,
        1473,
        1476
      ],
      "Abstract": "C++ remains a widely used programming language, despite retaining many unsafe features from C.  These unsafe features often lead to violations of type and memory safety, which manifest as buffer overflows, use-after-free vulnerabilities, or abstraction violations.  Malicious attackers are able to exploit such violations to compromise application and system security.  This paper introduces Ironclad C++, an approach to bringing the benefits of type and memory safety to C++.  Ironclad C++ is, in essence, a library-augmented type-safe subset of C++.  All Ironclad C++ programs are valid, standard C++ programs, and thus Ironclad C++ programs can be compiled using standard, off-the-shelf C++ compilers.  However, not all valid C++ programs are valid Ironclad C++ programs.  To determine whether or not a C++ program is a valid Ironclad C++ program, Ironclad C++ uses a syntactic source code validator that statically prevents the use of unsafe C++ features.  For properties that are difficult to check statically Ironclad C++ applies low cost dynamic checking to enforce memory safety using templated smart pointer classes.  Drawing from the collective wisdom of years of research on enforcing memory safety, Ironclad C++ utilizes and improves upon prior techniques to significantly reduce the overhead of enforcing memory safety in C++ programs.\r\n\r\nTo demonstrate the effectiveness of this approach, we translate (with the assistance of a semi-automatic refactoring tool) and test a set of performance benchmarks, multiple bug-detection suites, and the open-source database leveldb. These benchmarks incur a performance overhead of 16% as compared to the unsafe original C++ code, which is small compared to prior approaches to providing comprehensive memory safety in C and C++.  This low performance overhead is achieved without the use of extensive static analysis or special compiler optimizations.",
      "Key": 848,
      "URL": "",
      "Title": "Ironclad C++:  A Library-Augmented Type-Safe Subset of C++"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1453,
        1455,
        1246,
        1456,
        1454
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nProviding security guarantees for software systems built out of untrusted components requires the ability to enforce fine-grained access control policies. This is evident in Web 2.0 applications where JavaScript code from different origins is often combined on a single page, leading to well-known vulnerabilities.  We present a security infrastructure which allows users and content providers to specify access control policies over subsets of JavaScript execution traces and reversion to a safe state if a violation is detected. The proposal is evaluated in the context of a production browser where security principals are based on the browser's same origin policy.  Simple security policies can be shown to prevent real attacks without imposing drastic restrictions on legacy applications. We have evaluated our infrastructure with two non-trivial policies on 50 of the Alexa top websites with no changes to the legacy JavaScript code and measured the performance overheads of our instrumentation.",
      "Key": 840,
      "URL": "",
      "Title": "Flexible Access Control Policies with Delimited Histories and Revocation"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1618,
        1619,
        1620,
        1621
      ],
      "Abstract": "Software system can be viewed from both internal and external perspectives. They are represented by the system model and user model respectively. In this paper, we employ the yin-yang principle as an analytical tool in reviewing the relationship between the user model and system model. In the traditional system-centered approach, the engineer is more concerned with the system model and does not pay much attention to the user model. However, as user-centered approach has gained increasing acceptance in a number of projects, we claim that the user model and system model are the yin and yang in user-centered software development and, following the yin-yang principle, call for equal emphasis on both models. Particularly we propose using video-based scenario as the representation of user models and reveal the benefits of the use of video in software development. As a case study, we describe how we have employed the scenario video in a project course and share the best practices that we have identified about the creation of demo scenario videos.",
      "Key": 940,
      "URL": null,
      "Title": "User Model and System Model:  The Yin and Yang in User-Centered Software Development"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1221
      ],
      "Abstract": "Three years ago in this venue, Cook argued that the essence of objects is procedural data abstraction.  His observation raises a natural question: if procedural data abstraction is the essence of objects, has it contributed to the empirical success of objects, and if so, how?\r\n\r\nThis essay attempts to answer that question.  It begins by reviewing Cook's definition and then, following Kay, broadens the scope of inquiry to consider objects that abstract not just data, but higher-level goals.  Using examples taken from object-oriented frameworks, I illustrate the unique design leverage that objects provide: the ability to define abstractions that can be extended, and whose extensions are interoperable.  The essay argues that the form of interoperable extension supported by objects is essential to modern software: many modern frameworks and ecosystems could not have been built without objects or their equivalent.  In this sense, the success of objects was not a coincidence: it was inevitable.",
      "Key": 941,
      "URL": null,
      "Title": "The Power of Interoperability: Why Objects Are Inevitable"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1282,
        1261,
        1283
      ],
      "Abstract": "Virtual machines are a key technology for object oriented lan-guages, and thus an important context for research and teaching.  Unfortunately, they also have a reputation as being intimidating and unapproachable. The purpose of this tutorial is to show researchers and educators how a large, widely used virtual machine can be used as an effective platform for research and teaching of the virtual machine technology. The tutorial is centered on a running exam-ple that involves designing, implementing and debugging a real-istic research-motivated extension to a virtual machine. We guide the audience through the process and demonstrate how to use the available tools to make sense of the VM\u2019s sophisticated compo-nents and we show how to debug the machine when things don\u2019t go as planned. We do this using Jikes RVM, a very widely used research Java virtual machine.\r\n\r\nAt the end of the tutorial, participants who had never heard of Jikes RVM will have enough information to start using it for their teaching and research. The participants already familiar with the platform will have better understanding of the system and will learn about recent development targeted to make Jikes RVM more approachable to the broader circle of researchers and students.",
      "Key": 737,
      "URL": "http://sape.inf.usi.ch/rdb",
      "Title": "Using a VM For Effective Research and Teaching: Learn to hack a VM in 90 minutes"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1552,
        1553
      ],
      "Abstract": "",
      "Key": 892,
      "URL": null,
      "Title": "ZipPy on Truffle: A Fast and Simple Implementation of Python"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1265
      ],
      "Abstract": "The duopoly of computing has up until now been delimited by drawing a line in the sand that defines the instruction set architecture as the hard division between software and hardware. On one side of this contract Intel improved the design of processors and on the other side of this line Microsoft developed ever more sophisticated software. This cozy relationship is now over as the distinction between hardware and software is blurred due to relentless pressure for performance and reduction in latency and energy consumption. Increasingly we will be forced to compute with architectures and machines which do not resemble regular processors with a fixed memory hierarchy based on heuristic caching schemes. Other ways to bake all that sand will include the evolution of GPUs and FPGAs to form heterogeneous computing resources which are much better suited to meeting our computing needs than racks of multicore processors.\r\n\r\n",
      "Key": 740,
      "URL": null,
      "Title": "Computing without Processors"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1291
      ],
      "Abstract": "Profile-driven JIT compilers like those in most JVMs are usually good, but they  can be unpredictable. Achieving top performance consistently is hard. Lancet, a JIT compiler written in Scala, allows applications to take full control of the JIT process. This includes the ability to compile multiple specialized versions of code paths at runtime. Lancet provides JIT macros that allow for user code to execute in the JIT and thus open the door for \"smart libraries\" that come with domain-specific optimizations and checks.  As opposed to most macro systems, JIT macros are not a front-end source processor, but tightly integrated with regular compiler optimizations and VM functionality like speculative optimization and re-optimization.\r\n",
      "Key": 751,
      "URL": null,
      "Title": "Surgical Precision JIT Compilers"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1287,
        1274,
        1275,
        1277
      ],
      "Abstract": "\u201cDalvik\u201d is the name of the virtual machine that runs programs on Android devices. The architecture of Dalvik is designed to match the energy consumption and performance requirements of devices with limited energy and hardware capabilities. Therefore, the study of the architectural decisions behind Dalvik is relevant for researchers and practitioners interested in the capabilities and limitations of the machine executing mobile programs and the specific programming styles required for battery-powered devices.\r\n\r\nTo understand how Dalvik works, we compare it with the Java Virtual Machine running on desktop computers using the following criteria: the objectives, the compilation process, and the format of Dalvik executables.\r\n\r\nThis talk points out the strengths of Dalvik, and how these strengths are achieved. Researchers and practitioners involved in mobile programming or Green Computing will learn how programs are executed and which strategies Dalvik adopts to retain battery power. This knowledge can be used to optimize program execution or to adopt similar strategies in similar projects.\r\n\r\n**Prerequisite:** some experience in Java programming, and a basic understanding of computer architecture",
      "Key": 747,
      "URL": "",
      "Title": "Diving into Dalvik"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1266
      ],
      "Abstract": "I will present the LogicBlox database and describe business applications that use it. The LogicBlox database marries declarative programming (logic-based specifications) with cloud deployment over large datasets. The database is programmed with a variant of the Datalog programming language. The flexibility of declarative programming allows us to integrate both traditional business application development and \"probabilistic\" applications: machine-learning or search-based solutions, as required by the domain. Our approach aims to eliminate the distance between prototyping and deployed, high-performance implementations. I will discuss real customer applications and actual deployment instances that elastically adapt to several thousands of machines.\r\n",
      "Key": 741,
      "URL": null,
      "Title": "Wavefront — Declarative Programming for the Cloud"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1325
      ],
      "Abstract": "",
      "Key": 960,
      "URL": null,
      "Title": "The Poor Man's Proof Assistant: Using Prolog to Develop Formal Language Theoretic Proofs"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1326
      ],
      "Abstract": "",
      "Key": 961,
      "URL": null,
      "Title": "Dictionary-Base Query Recommendation for Local Code Search"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1639
      ],
      "Abstract": "",
      "Key": 962,
      "URL": null,
      "Title": "Security Tool Adoption in Open-Source"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1239
      ],
      "Abstract": "",
      "Key": 963,
      "URL": null,
      "Title": "Documenting Software Using Adaptive Software Artifacts"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1640
      ],
      "Abstract": "",
      "Key": 964,
      "URL": null,
      "Title": "Development of Automatically Verifiable Systems using Data Representation Synthesis"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1641
      ],
      "Abstract": "",
      "Key": 965,
      "URL": null,
      "Title": "HJ-Hadoop: An Optimized MapReduce Runtime for Multi-core Systems"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1642
      ],
      "Abstract": "",
      "Key": 966,
      "URL": null,
      "Title": "Structured Statistical Syntax Tree Prediction"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1543
      ],
      "Abstract": "",
      "Key": 967,
      "URL": null,
      "Title": "Identifying and Specifying Crosscutting Contracts with AspectJML"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1260
      ],
      "Abstract": "",
      "Key": 968,
      "URL": null,
      "Title": "Task Fusion: Improving Utilization of Multi-user Clusters"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1643
      ],
      "Abstract": "",
      "Key": 969,
      "URL": null,
      "Title": "Cloud Twin: Interactive Cross-Platform Replay for Mobile Applications"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1320
      ],
      "Abstract": "",
      "Key": 970,
      "URL": null,
      "Title": "Do Language Constructs for Parallel Execution Have Impact on Energy Efficiency?"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1644
      ],
      "Abstract": "",
      "Key": 971,
      "URL": null,
      "Title": "CSI: Crash Scene Investigation"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1323
      ],
      "Abstract": "",
      "Key": 972,
      "URL": null,
      "Title": "Orchestrating Mobile Application Execution for Performance and Energy Efficiency"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1645
      ],
      "Abstract": "",
      "Key": 973,
      "URL": null,
      "Title": "Investigation of Error Notifications Through Categorization"
    },
    {
      "Type": "ACM SRC",
      "Authors": [
        1517
      ],
      "Abstract": "",
      "Key": 974,
      "URL": null,
      "Title": "Tackling the Efficiency Problem of Gradual Typing"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1271,
        1253
      ],
      "Abstract": "The tutorial surveys developers' tasks in agile, iterative, and evolutionary software development. Among these, a particularly important task is software change where developers add a new feature, correct a bug, or add a new property to software.  The tutorial then surveys recent research  results and explores how the results translate into the practice and teaching of software development.  Examples of developer practices include \u201cfeature location\u201d that locates in the existing code the place where a new feature is to be implemented, \u201cimpact analysis\u201d that assesses how much the old code is going to be impacted if a new feature is added to it, refactoring that either prepares the code for the change or cleans up the aftermath, change propagation that traces where the secondary changes are to be made, verification that confirms both the new and the old code, and so forth. These practices are summarized in a \u201cphased model of software change.\u201d  \r\n  \r\n\r\n**Prerequisite:** medium knowledge of object-oriented programming (e.g. C++, Java, or C#)",
      "Key": 728,
      "URL": "",
      "Title": "Fundamental Practices of Software Developers"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1256
      ],
      "Abstract": "Have you ever been confused by an arrow in a box-and-line design diagram? Do you use UML in your software architecture? Have you ever wondered where is the line between architecture and detailed design? If your answer is yes to any of these questions, then this tutorial has practical and valuable information for you. The goal is to show you what information about an architecture should be captured, so that others can successfully use it, maintain it, and build a software system from it. Important takeaways from this tutorial include: architecture consists of multiple views; how can we use UML in each view and when other notations work better; what views can we use to evaluate performance, availability, modifiability and other qualities; how to complement structural diagrams with sequence diagrams, statecharts and other behavior diagrams;  how to document software interfaces; guidelines and templates to make your architecture documentation more effective. To benefit the most from this tutorial, attendees should have familiarity with basic UML and an interest in software architecture.\r\n\r\n**Prerequisite:** intermediate level of knowledge/experience in software development in general, and familiarity with basic UML.",
      "Key": 731,
      "URL": "",
      "Title": "How to Document the Architecture of Your Application Using UML and More"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1254
      ],
      "Abstract": "This tutorial will introduce attendees to the various paradigms for creating algorithms that take advantage of the growing number of multicore processors, while avoiding the overhead of excessive synchronization overhead.  Many of these approaches build upon the basic divide-and-conquer approach, while others might be said to use a multiply-and-conquer paradigm.  Attendees will also learn the theory and practice of \"work stealing,\" a multicore scheduling approach which is being adopted in numerous multicore languages and frameworks, and how classic work-list algorithms can be restructured to take best advantage of the load balancing inherent in work stealing.  Finally, the tutorial will investigate some of the tradeoffs associated with different multicore storage management approaches, including task-local garbage collection and region-based storage management.\r\n\r\n**Prerequisite:** Intermediate to advanced knowledge of programming, with some understanding of multi-threaded/multi-tasking issues, including race conditions and synchronization.",
      "Key": 729,
      "URL": "",
      "Title": "Multicore Programming using Divide-and-Conquer and Work Stealing"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1556,
        1555
      ],
      "Abstract": "",
      "Key": 894,
      "URL": null,
      "Title": "Finding Architectural Flaws in Android Apps Is Easy"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1269
      ],
      "Abstract": "PHP is as often maligned as it is widely used. Conventional wisdom is that PHP is an inferior language, whose popularity is due solely to legacy effects. The success of projects written in PHP, according to this view, proves only that with enough thrust, even pigs can fly.\r\nThis story ignores some critical details. This talk examines the strengths that, whether by design or accident, have made PHP a dominant language in its niche. Even if you never use PHP, its success holds lessons for other environments. We will also highlight Facebook's attempts at remedying the inconsistencies and misfeatures in the core language, while maintaining PHP's strengths.\r\n\r\n\r\n",
      "Key": 744,
      "URL": null,
      "Title": "PHP, Seriously!"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1389,
        1388
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nModern IDEs support automated refactoring for many programming languages, but support for JavaScript is still primitive. To perform renaming, which is one of the fundamental refactorings, there is often no practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives have been developed, they are limited by whole-program assumptions and poor scalability.\r\n\r\nWe propose a technique for semi-automatic refactoring for JavaScript, with a focus on renaming. Unlike traditional refactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction with the programmer. With this pragmatic approach, we can provide scalable and effective refactoring support for real-world code, including libraries and incomplete applications. Through a series of experiments that estimate how much manual effort our technique demands from the programmer, we show that our approach is a useful improvement compared to search-and-replace tools.\r\n\r\nKeywords: refactoring, static analysis, JavaScript",
      "Key": 818,
      "URL": "http://cs.au.dk/~amoeller/papers/renaming/",
      "Title": "Semi-Automatic Rename Refactoring for JavaScript"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1441,
        1440,
        1232,
        1439
      ],
      "Abstract": "Refactoring has become an integral part of modern software development, with wide support in popular integrated development environments (IDEs). Modern IDEs provide a fixed set of supported refactorings, listed in a refactoring menu. But with IDEs supporting more and more refactorings, it is becoming increasingly difficult for programmers to discover and memorize all their names and meanings. Also, since the set of refactorings is hard-coded, if a programmer wants to achieve a slightly different code transformation, she has to either apply a (possibly non-obvious) sequence of several built-in refactorings, or just perform the transformation by hand.\r\n\r\nWe propose a novel approach to refactoring, based on synthesis from examples, which addresses these limitations. With our system, the programmer need not worry how to invoke individual refactorings or the order in which to apply them. Instead, a transformation is achieved via three simple steps: the programmer first indicates the start of a code refactoring phase; then she performs some of the desired code changes manually; and finally, she asks the tool to complete the refactoring.\r\n\r\nOur system completes the refactoring by first extracting the difference between the starting program and the modified version, and then synthesizing a sequence of refactorings that achieves (at least) the desired changes.\r\n\r\nTo enable scalable synthesis, we introduce local refactorings, which allow for first computing a refactoring sequence on small program fragments and then extrapolating it to a full refactoring sequence.\r\n\r\nWe implemented our approach as an Eclipse plug-in, with an architecture that is easily extendable with new refactorings. The experimental results are encouraging: with only minimal user input, the synthesizer was able to quickly discover complex refactoring sequences for several challenging realistic examples.",
      "Key": 842,
      "URL": "http://www.srl.inf.ethz.ch/papers/oopsla13-refactoring.pdf",
      "Title": "Refactoring with Synthesis"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1410,
        1409,
        1412,
        1411
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nUnderstanding and analyzing multi-threaded program performance and scalability is far from trivial, which severely complicates parallel software development and optimization.  In this paper, we present bottle graphs, a powerful analysis tool that visualizes multi-threaded program performance, in regards to both per-thread parallelism and execution time.  Each thread is represented as a box, with its height equal to the share of that thread in the total program execution time, its width equal to its parallelism, and its area equal to its total running time. The boxes of all threads are stacked upon each other, leading to a stack with height equal to the total program execution time.  Bottle graphs show exactly how scalable each thread is, and thus guide optimization towards those threads that have a smaller parallel component (narrower), and a larger share of the total execution time (taller).\r\n\r\nUsing light-weight OS modules, we calculate bottle graphs for unmodified multi-threaded programs running on real processors with an average overhead of 0.68%.  To demonstrate their utility, we do extensive analysis of 12 Java benchmarks running on top of the Jikes JVM, which introduces many JVM service threads.  We not only reveal and explain scalability limitations of several well-known Java benchmarks; we also analyze the reasons why the garbage collector itself does not scale, and in fact performs optimally with two collector threads for all benchmarks, regardless of the number of application threads. Finally, we compare the scalability of Jikes versus the OpenJDK JVM.  We demonstrate how useful and intuitive bottle graphs are as a tool to analyze scalability and help optimize multi-threaded applications.",
      "Key": 827,
      "URL": "",
      "Title": "Bottle Graphs: Visualizing Scalability Bottlenecks in Multi-Threaded Applications"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1391,
        1390
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nIdentifying the hottest paths in the control flow graph of a routine can direct optimizations to portions of the code where most resources are consumed. This powerful methodology, called path profiling, was introduced by Ball and Larus in the mid 90's and has received considerable attention in the last 15 years for its practical relevance. A shortcoming of the Ball-Larus technique was the inability to profile cyclic paths, making it difficult to mine execution patterns that span multiple loop iterations. Previous results, based on rather complex algorithms, have attempted to circumvent this limitation at the price of significant performance losses even for a small number of iterations. In this paper, we present a new approach to multi-iteration path profiling, based on data structures built on top of the original Ball-Larus numbering technique. Our approach allows the profiling of all executed paths obtained as a concatenation of up to k Ball-Larus acyclic paths, where k is a user-defined parameter. We provide examples showing that this method can reveal optimization opportunities that acyclic-path profiling would miss. An extensive experimental investigation on a large variety of Java benchmarks on the Jikes RVM shows that our approach can be even faster than Ball-Larus due to fewer operations on smaller hash tables, producing compact representations of cyclic paths even for large values of k.",
      "Key": 819,
      "URL": "http://www.dis.uniroma1.it/~demetres/kstream/kblpp-preprint.pdf",
      "Title": "Ball-Larus Path Profiling Across Multiple Loop Iterations"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1615,
        1719,
        1616,
        1312
      ],
      "Abstract": "We report on a language called KScript and a GUI framework called KSWorld.  The goal of KScript and KSWorld is to try to reduce the accidental complexity in GUI framework writing and application building.  We aim for an understandable, concise way to specify an application's behavior and appearance, minimizing extra details that arise only because of the medium being used.\r\n\r\nKScript is a dynamic language based on the declarative and time-aware dataflow-style execution model of Functional Reactive Programming (FRP), extended with support for loose coupling among program elements and a high degree of program reconfigurability.\r\n\r\nKSWorld is built using KScript.  The fields, or slots, of graphical widgets in KSWorld are reactive variables.  Definitions of such variables can be added or modified in a localized manner, allowing on-the-fly customization of the visual and behavioral aspects of widgets and entire applications.  Thus the KSWorld environment supports highly exploratory application building: a user constructs the appearance interactively with direct manipulation, then attaches and refines reactive variable definitions to achieve the desired overall behavior.\r\n\r\nWe illustrate our use of KSWorld to build an editor for general graphical documents, including dynamic documents that serve as active essays. The graphical building blocks for documents are the same as those used for building the editor itself, enabling a bootstrapping process in which the earliest working version of the editor can be used to create further components for its own interface.\r\n\r\nAs one way of measuring progress on our complexity goal, we provide an overview of the number of lines of code in KSWorld.  The total for the KScript compiler, the FRP evaluator, the framework, document model and document editor is currently around 10,000 lines.",
      "Key": 927,
      "URL": null,
      "Title": "KScript and KSWorld: A Time-Aware and Mostly Declarative Language and Interactive GUI Framework"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1606,
        1607
      ],
      "Abstract": "SAT and SMT solvers have automated a spectrum of programming tasks, including program synthesis, code checking, bug localization, program repair, and programming with oracles.   In principle, we obtain all these benefits by translating the program (once) to a constraint system understood by the solver.  In practice, however, compiling a language to logical formulas is a tricky process, complicated by having to map the solution back to the program level and extend the language with new solver-aided constructs, such as symbolic holes used in synthesis.\r\n\r\nThis paper introduces Rosette, a framework for designing solver-aided languages.  Rosette is realized as a solver-aided language embedded in Racket, from which it inherits extensive support for meta-programming.  Our framework frees designers from having to compile their languages to constraints:  new languages, and their solver-aided constructs, are defined by shallow (library-based) or deep (interpreter-based) embedding in Rosette itself.\r\n\r\nWe describe three case studies, by ourselves and others, of using Rosette to implement languages and synthesizers for web scraping, spatial programming, and superoptimization of bitvector programs.",
      "Key": 923,
      "URL": null,
      "Title": "Growing Solver-Aided Languages with Rosette"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1608
      ],
      "Abstract": "The theory and semantics of programming languages are typically formulated using abstract mathematical models that have no obvious connection to any physical theory.  While this approach has a number of advantages, it does not generalize to complex non-discrete systems, and it obscures the underlying mathematical connections between computational and physical theory.  Moreover, it can lead to inaccurate models of more complex phenomena such as concurrency.  In this paper, we describe the current directions and initial results of our efforts to build connections between programming language theory and semantics and physical theory.  The first and most mature of these efforts aims to develop a denotational semantic model that expands upon the mathematical formulation of quantum systems to provide a denotational foundation for concurrent languages.  The second effort aims to generalize the notion of type systems to a probability inference system based on Bayesian probability.  The third and final effort aims to develop an understanding of the dynamics of concurrent processes, with the goal of reasoning about the real behavior of processes in greater detail.  In each of these efforts, we aim to draw connections between computing and other scientific disciplines.",
      "Key": 924,
      "URL": null,
      "Title": "Building Connections between the Theories of Programming Languages and Physical Systems"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1356,
        1355,
        1354,
        1353
      ],
      "Abstract": "We present a data driven algorithm for equivalence checking of two loops. The algorithm infers simulation relations using data from test runs. Once a candidate simulation relation has been obtained, off-the-shelf SMT solvers are used to check whether the simulation relation actually holds. The algorithm is sound: insufficient data will cause the proof to fail.  We demonstrate a prototype implementation, called DDEC, of our algorithm, which is the first sound equivalence checker for loops written in x86 assembly.",
      "Key": 807,
      "URL": "",
      "Title": "Data-Driven Equivalence Checking"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1491,
        1493,
        1494,
        1492
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nWe describe techniques for synthesis and verification of recursive functional programs over unbounded domains. Our techniques build on top of an algorithm for satisfiability modulo recursive functions, a framework for deductive synthesis, and complete synthesis procedures for algebraic data types. We present new counterexample-guided algorithms for constructing verified programs. We have implemented these algorithms in an integrated environment for interactive verification and synthesis from relational specifications. Our system was able to synthesize a number of useful recursive functions that manipulate unbounded numbers and data structures.",
      "Key": 853,
      "URL": "",
      "Title": "Synthesis Modulo Recursive Functions"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1365,
        1366,
        1364
      ],
      "Abstract": "Formal program verification offers strong assurances of correctness, backed by the strength of mathematical proof. Constructing these proofs requires humans to identify program invariants, and show that they are always maintained. These invariants are then used to prove that the code adheres to its specification.\r\n\r\nIn this paper, we explore the overlap between formal verification and code optimization. We propose two novel approaches to reuse the invariants derived in formal proofs and integrate them into compilation.  The first applies invariants extracted from the proof, while the second leverages the property of program safety (i.e., the absence of bugs).  We reuse this information to improve the performance of generated object code.\r\n\r\nWe evaluated these methods on a real-world formally-verified microkernel and obtained improvements in runtime performance (up to 28%) and in worst-case execution time (25.5%). In macro-benchmarks, we found the performance of para-virtualized Linux running on the microkernel improved by 6%--16%.",
      "Key": 811,
      "URL": "",
      "Title": "Code Optimizations Using Formally Verified Properties"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1361,
        1359,
        1362,
        1360
      ],
      "Abstract": "This paper presents a new method for generating inductive  loop invariants that are expressible as boolean combinations of linear integer constraints. The key idea underlying our technique is to perform a backtracking search that combines Hoare-style verification condition generation with a logical abduction procedure based on quantifier elimination to speculate candidate invariants. Starting with true, our method iteratively strengthens loop invariants until they are inductive and strong enough to verify the program. A key feature of our technique is that it is lazy: It only infers those invariants that are necessary for verifying program correctness. Furthermore, our technique can infer arbitrary boolean combinations (including disjunctions) of linear invariants. We have implemented the proposed approach in a tool called HOLA. Our experiments demonstrate that HOLA can infer interesting invariants that are beyond the reach of existing state-of-the-art invariant generation tools.",
      "Key": 809,
      "URL": "http://www.cs.wm.edu/~idillig/oopsla13.pdf",
      "Title": "Inductive Invariant Generation via Abductive Inference"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1554,
        1206
      ],
      "Abstract": "",
      "Key": 893,
      "URL": null,
      "Title": "Panini: a Capsule-oriented Programming Language for Implicitly Concurrent Program Design"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1482
      ],
      "Abstract": "JavaScript is widely used for client-side web application and increasingly for mobile applications. Unlike for C, C++ and Java, there are few tools for analysis and testing of JavaScript applications.  I will present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses.  Our framework incorporates two key techniques: selective record-replay, a technique which enables to record and to faithfully replay a part of a program, and shadow execution, which enables easy implementation of heavy-weight dynamic analyses.  Our implementation is applicable to real-world JavaScript programs running on multiple platforms.  We have implemented concolic testing, an analysis to track origins of nulls and undefined, a simple form of taint analysis, an analysis to detect likely type inconsistencies, and an object allocation profiler in Jalangi.\r\n",
      "Key": 869,
      "URL": null,
      "Title": "Test and Cure your JavaScript Blues "
    },
    {
      "Type": "Social Events",
      "Authors": [

      ],
      "Abstract": "The SPLASH banquet reception will be held at the historic and beautiful [Indiana Roof Ballroom](http://www.indianaroof.com).",
      "Key": 932,
      "URL": null,
      "Title": "Banquet Reception"
    },
    {
      "Type": "Registration",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 867,
      "URL": null,
      "Title": "Thursday"
    },
    {
      "Type": "Announcements",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 935,
      "URL": null,
      "Title": "OOPSLA 2003 Most-Influential Paper Award"
    },
    {
      "Type": "Announcements",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 936,
      "URL": null,
      "Title": "Vlissides Award"
    },
    {
      "Type": "Announcements",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 937,
      "URL": null,
      "Title": "ACM Student Research Competition"
    },
    {
      "Type": "Keynotes",
      "Authors": [
        1249
      ],
      "Abstract": "George Orwell wrote: \r\n> 'Who controls the past controls the future;\r\n> who controls the present controls the past'\r\n\r\nOnward! is dedicated to the spirit of radical innovation, so I will examine the past, present and future of radical innovation in programming languages. How did Lisp, Simula, Actors, Beta, Smalltalk and Self give us the world of C++, Java, Javascript, Perl, Python and PHP?  We'll ponder such questions and speculate what new wonders await us down the road.\r\n",
      "Key": 719,
      "URL": null,
      "Title": "Onward! — Does Thought Crime Pay?"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1557,
        1556
      ],
      "Abstract": "",
      "Key": 895,
      "URL": null,
      "Title": "Finding the Missing Eclipse Perspective: the Runtime Perspective"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1268
      ],
      "Abstract": "Reactive programming will subsume the next 700 asynchronous programming models! Each of these will be invented to support composition of  asynchronous programs. This talks starts with, C#'s Async model and the Rx model. Async enables direct-style programming with futures. Rx is based on observable asynchronous event streams which can be composed and queried using LINQ-style operators. In this talk, we're going to show how to make Rx programming more natural and intuitive. For this, we're going to generalize Scala's Async feature which, so far, has been used to program with non-blocking futures in a familiar direct style.\r\n",
      "Key": 743,
      "URL": null,
      "Title": "The Next 700 Asynchronous Programming Models"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1507
      ],
      "Abstract": "Over the last ten years, Agile Methods have been adopted for many software development projects.  In this talk, I'll describe the research method - Grounded Theory - that we have adopted to study Agile projects and teams, and present some of the results of that research.  In particular, I'll talk about the history of Grounded Theory in the social sciences, the major stages of a Grounded Theory research project, and describe the major techniques: data gathering, coding, constant comparison. I'll describe how Grounded Theory relies upon the kind of feedback loops that are characteristic Agile methods, in particular   theoretical sampling and selective coding.  I'll talk about how to know when you're done: theoretical saturation, theoretical coding, and completing literature reviews. Finally I'll talk about the kind of research results discovered by Grounded Theory, their relationships to other kinds of research and publications, and hints on how to convince programme committees that they should accept your research.",
      "Key": 915,
      "URL": "",
      "Title": "Agile Studies of Agile Methods"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1400,
        1401
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nAlgorithmic speculation or high-level speculation is a promising programming paradigm which allows programmers to speculatively branch an execution into multiple independent parallel sections and then choose the best (perhaps fastest) amongst them. The continuing execution after the speculatively branched section sees only the modifications made by the best one. This programming paradigm allows programmers to harness parallelism and can provide dramatic performance improvements.\r\n\r\nIn this paper we present the Multiverse speculative programming model. Multiverse allows programmers to exploit parallelism through high-level speculation. It can effectively harness large amounts of parallelism by speculating across an entire cluster and is not bound by the parallelism available in a single machine. We present abstractions and a runtime which allow programmers to introduce large scale high-level speculative parallelism into applications with minimal effort. We introduce a novel on-demand address space sharing mechanism which provide speculations efficient transparent access to the original address space of the application (including the use of pointers) across machine boundaries. Multiverse provides single commit semantics across speculations while guaranteeing isolation between them. We also introduce novel mechanisms to deal with scalability bottlenecks when there are a large number of speculations.\r\n\r\nWe demonstrate that for several benchmarks, Multiverse achieves impressive speedups and good scalability across an entire cluster. We study the overheads of the runtime and demonstrate how our special scalability mechanisms are crucial in scaling cluster wide.",
      "Key": 823,
      "URL": "",
      "Title": "Multiverse: Efficiently supporting distributed high-level speculation"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1498,
        1497
      ],
      "Abstract": "Disposal of dead actors in actor-model languages is as important as disposal of unreachable objects in object-oriented languages. In current practice, programmers are required to either manually terminate actors, or they have to rely on garbage collection systems that monitor actor mutation through write barriers, thread coordination through locks etc. These techniques, however, prevent the collector from being fully concurrent.\r\n\r\nWe developed a protocol that allows garbage collection to run fully concurrently  with all actors. The main challenges in concurrent garbage collection is the detection of cycles of sleeping actors in the actors graph, in the presence of concurrent mutation of this graph. Our protocol is solely built on message passing: it uses deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph).\r\n\r\nWe present our ideas informally through an example, and then present a formal model, prove soundness and argue completeness.  We have implemented the protocol as part of a runtime library. We present two benchmarks which indicate that the overhead is small.",
      "Key": 855,
      "URL": "",
      "Title": "Fully Concurrent Garbage Collection of Actors in Many-Core Machines"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1422,
        1423,
        1425,
        1426,
        1424
      ],
      "Abstract": "Isolation---the property that a task can access shared data without interference from other tasks---is one of the most basic concerns in parallel programming.  While there is a large literature on isolated task-parallelism, the integration of isolation, task-parallelism, and nesting of tasks is a difficult and unresolved challenge. In this paper, we present a programming and execution model called Otello where isolation is extended to arbitrarily nested parallel tasks that make irregular heap accesses.  At the same time, no additional burden is imposed on the programmer, who only exposes parallelism by creating and synchronizing parallel tasks, leaving the underlying compiler and runtime system to ensure isolation.\r\n\r\nOtello extends Lublinerman et al's delegated isolation mechanism to the setting of nested parallelism. The basic runtime construct here is an *assembly*: a task equipped with a region in the shared heap that it owns.  When an assembly A conflicts with an assembly B, A transfers---or *delegates*---its code and owned region to a specifically selected assembly C in a way that will ensure isolation with B, leaving the responsibility of re-executing task A to C. The choice of C depends on the nesting relationship between A and B.\r\n\r\nWe have implemented Otello on top of the Habanero Java (HJ) parallel programming language, and used this implementation to evaluate Otello on collections of nested-parallel benchmarks and transactional benchmarks (without nested tasks).  On the nested-parallel benchmarks, Otello achieves scalability comparable to HJ programs without built-in isolation, and the relative overhead of Otello is lower than that of many published data-race detection algorithms.  For the transactional benchmarks, Otello incurs lower overhead than a state-of-the-art software transactional memory system (Deuce).",
      "Key": 832,
      "URL": "",
      "Title": "Isolation for Nested Task-Parallelism"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1420,
        1421,
        1419
      ],
      "Abstract": "Nondeterminism is a useful and prevalent concept in the design and implementation of software systems. An important property of nondeterminism is its latent parallelism: A nondeterministic action can evaluate to multiple behaviors. If at least one of these behaviors does not conflict with concurrent tasks, then there is an admissible execution of the action in parallel with these tasks. Unfortunately, existing implementations of the atomic paradigm --- optimistic as well as pessimistic --- are unable to fully exhaust the parallelism potential of nondeterministic actions, lacking the means to guide concurrent tasks toward nondeterministic choices that minimize interference.\r\n\r\nThis paper investigates the problem of utilizing parallelism due to nondeterminism. We observe that nondeterminism occurs in many real-world codes. We motivate the need for devising coordination mechanisms that can utilize available nondeterminism. We have developed a system featuring such mechanisms, which leverages nondeterminism in a wide class of query operations, allowing a task to look into the future of concurrent tasks that mutate the shared state during query evaluation and reduce conflict accordingly. We evaluate our system on a suite of 12 algorithmic benchmarks of wide applicability, as well as an industrial application. The results are encouraging.",
      "Key": 831,
      "URL": "",
      "Title": "Turning Nondeterminism into Parallelism"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1254
      ],
      "Abstract": "The heavy use of pointers in modern object-oriented programming languages interferes with the ability to adapt computations to the new distributed and/or multicore architectures.  This tech talk will introduce an alternative pointer-free approach to object-oriented programming, which dramatically simplifies adapting computations to the new hardware architectures.  This tech talk will illustrate the pointer-free approach by demonstrating the transformation of two popular object-oriented languages, one compiled, and one scripting, into pointer-free languages, gaining easier adaptability to distributed and/or multicore architectures, while retaining power and ease of use.",
      "Key": 734,
      "URL": "",
      "Title": "Living without Pointers: Bringing Value Semantics to Object-Oriented Parallel Programming"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1596,
        1599,
        1552,
        1600,
        1598,
        1246,
        1597,
        1267,
        1595
      ],
      "Abstract": "Building high-performance virtual machines is a complex and expensive undertaking; many popular languages still have low-performance implementations. We describe a new approach to virtual machine (VM) construction that amortizes much of the effort in initial construction by allowing new languages to be implemented with modest additional effort. The approach relies on tree-rewriting abstract syntax tree (AST) interpretation, together with an optimizing compiler that exploits the structure of the interpreter. The compiler uses speculative assumptions and deoptimization in order to produce efficient machine code. Our initial experience suggests that high performance is attainable while preserving a modular and layered architecture, and that new high-performance language implementations can be obtained by writing little more than a stylized interpreter.",
      "Key": 918,
      "URL": null,
      "Title": "One VM to Rule Them All"
    },
    {
      "Type": "Onward!",
      "Authors": [
        1601
      ],
      "Abstract": "In object-oriented programs, the relationship of an object to many objects is usually implemented using a collection. This is in contrast to a relationship to one object, which is usually implemented using a direct pointer. However, using collections for relationships to many objects does not only mean that accessing the related objects always requires accessing the collection first, it also presents a lurking maintenance problem that manifests itself when a relationship needs to be changed from to-one to to-many (or vice versa). To address these issues, we suggest how object-oriented programming can be extended with multiplicities, that is, with expressions that evaluate to an arbitrary number of objects not wrapped in a container, and demonstrate some properties of the extension that are useful with regard to software maintenance.",
      "Key": 919,
      "URL": null,
      "Title": "Content over Container: Object-Oriented Programming with Multiplicities"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1407,
        1408
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nType systems that permit developers to express themselves more precisely are one of the primary topics in programming language research, as well as in industrial software development. While it seems plausible that an expressive static type system increases developer productivity, there is little empirical evidence for or against this hypothesis. Generic types in Java are an example: as an extension of Java's original type system, some claim that Java 1.5 improves the type system's expressiveness. Even if this claim is true, there exists little empirical evidence that claimed expressiveness leads to a measurable increase in developer productivity. This paper introduces an experiment where generic types (in comparison to raw types) have been evaluated in three different directions: (1) the documentation impact on undocumented APIs, (2) the time required for fixing type errors, and (3) the extensibility of a generic type hierarchy. The results of the experiment suggest that generic types improve documentation and reduce extensibility -- without revealing a difference in the time required for fixing type errors.",
      "Key": 826,
      "URL": "",
      "Title": "Do Developers Benefit from Generic Types? An Empirical Comparison of Generic and Raw Types in Java"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1466,
        1468,
        1467
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nMany languages support behavioral software contracts so that programmers can describe a component's obligations and promises via logical assertions in its interface. The contract system monitors program execution, checks whether the assertions hold, and, if not, blames the guilty component. Pinning down the violator gets the debugging process started in the right direction.  Quality contracts impose a serious run-time cost, however, and programmers therefore compromise in many ways. Some turn off contracts for deployment, but then, contracts quickly get out of sync with code during maintenance. Others test contracts randomly or probabilistically. In all cases, programmers have to cope with lack of blame information when the program eventually fails.\r\n\r\nIn response, we propose option contracts as an addition to the contract tool box. Our key insight is that in ordinary contract systems, server components impose their contract on client components, giving them no choice whether they wish to check the server's promises or trust it. With option contracts, server components can offer an option for a contract and clients may choose to exercise the option or to accept it and share responsibility for the contract. We show that option contracts permit programmers to specify flexible checking policies, that their cost is reasonable, and that they satisfy a complete monitoring theorem.",
      "Key": 846,
      "URL": "",
      "Title": "Option Contracts"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1356,
        1460,
        1459
      ],
      "Abstract": "Applications written for distributed-memory architectures must partition their data to enable parallel execution.  As memory hierarchies become deeper, it is increasingly necessary that the data partitioning also be hierarchical to match.  Current language proposals perform this hierarchical partitioning statically, which excludes many important applications where the appropriate partitioning is itself data dependent and so must be computed dynamically.  We describe Legion, a region-based programming system, where each region may be partitioned into subregions.  Partitions are computed dynamically and are fully programmable; in particular, the division of data need not be disjoint and subregions of a region may overlap, or alias one another.  Computations use regions with certain privileges (e.g., expressing that a computation uses a region read-only) and data coherence (e.g., expressing that the computation need only be atomic with respect to other operations on the region), which can be controlled on a per-region (or subregion) basis.\r\n\r\nWe present the novel aspects of the Legion design, in particular the combination of static and dynamic checks used to enforce soundness. We give an extended example illustrating how Legion can express computations with dynamically determined relationships between computations and data partitions.  We prove the soundness of Legion's type system, and show Legion type checking improves performance by up to 71% by eliding provably safe memory checks.  We show that the dynamic checks, in particular to detect aliasing at runtime at the region granularity, have negligible overhead.  We report results for three real-world applications running on distributed memory machines, achieving up to 62.5X speedup on 96 GPUs on the Keeneland supercomputer.",
      "Key": 843,
      "URL": "http://theory.stanford.edu/~aiken/publications/papers/oopsla13b.pdf",
      "Title": "Language Support for Dynamic, Hierarchical Data Partitioning"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1398,
        1397
      ],
      "Abstract": "We present the problem of class hierarchy complementation: given a partially known hierarchy of classes together with subtyping constraints ('A has to be a transitive subtype of B') complete the hierarchy so that it satisfies all constraints. The problem has immediate practical application to the analysis of partial programs\u00e2\u20ac\u201de.g., it arises in the process of providing a sound handling of 'phantom classes' in the Soot program analysis framework. We provide algorithms to solve the hierarchy complementation problem in the single inheritance and multiple inheritance settings. We also show that the problem in a language such as Java, with single inheritance but multiple subtyping and distinguished class vs. interface types, can be decomposed into separate single- and multiple-subtyping instances. We implement our algorithms in a tool, JPhantom, which complements partial Java bytecode programs so that the result is guaranteed to satisfy the Java verifier requirements. JPhantom is highly scalable and runs in mere seconds even for large input applications and complex constraints (with a maximum of 14s for a 19MB binary).",
      "Key": 828,
      "URL": "http://cgi.di.uoa.gr/~smaragd/jphantom-oopsla13.pdf",
      "Title": "Class Hierarchy Complementation: Soundly Completing a Partial Type Graph"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1287,
        1277,
        1285,
        1289,
        1286
      ],
      "Abstract": "API\u00a0Economy\u00a0is\u00a0economy\u00a0where\u00a0companies\u00a0expose\u00a0their\u00a0(internal)\u00a0business assets\u00a0or\u00a0services\u00a0in\u00a0the\u00a0form\u00a0of\u00a0(web)\u00a0APIs\u00a0to\u00a0third\u00a0parties\u00a0with\u00a0the\u00a0goal\u00a0of unlocking\u00a0additional\u00a0business\u00a0value.\u00a0Triggered\u00a0by\u00a0the\u00a0explosion\u00a0of\u00a0the\u00a0growth of\u00a0Internet\u00adenabled\u00a0devices,\u00a0evolution\u00a0of\u00a0social\u00a0interactions\u00a0(i.e.,\u00a0social networking,\u00a0social\u00a0commerce),\u00a0and\u00a0appearance\u00a0of\u00a0new\u00a0software\u00a0markets\u00a0in the\u00a0form\u00a0of\u00a0Apps,\u00a0API\u00a0Economy\u00a0brings\u00a0a\u00a0different\u00a0philosophy\u00a0to\u00a0how companies\u00a0do\u00a0business\u00a0and\u00a0how\u00a0they\u00a0interact\u00a0with\u00a0their\u00a0customers\u00a0and competition.\u00a0The\u00a0aim\u00a0of\u00a0this\u00a0talk\u00a0is\u00a0to\u00a0give\u00a0a\u00a0clear\u00a0view\u00a0on\u00a0what\u00a0API\u00a0Economy is,\u00a0what\u00a0opportunities\u00a0it\u00a0offers\u00a0to\u00a0API\u00a0producers\u00a0and\u00a0API\u00a0consumers,\u00a0and what\u00a0are\u00a0the\u00a0general\u00a0steps\u00a0(methodology)\u00a0to\u00a0unlock\u00a0those\u00a0benefits.",
      "Key": 749,
      "URL": "",
      "Title": "Unlocking the benefits of the API Economy"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1546,
        1206,
        1260,
        1547
      ],
      "Abstract": "",
      "Key": 890,
      "URL": null,
      "Title": "Mining Source Code Repositories with Boa"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1304
      ],
      "Abstract": "TypeScript is a language and toolset that makes it easier to write cross-platform, application-scale JavaScript. TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Types are introduced to support tooling, including static analysis, completion lists, refactoring and other rich modern IDE capabilities.  The TypeScript type system is designed to capture the runtime semantics of JavaScript faithfully, and to enable modelling the practical design elements of JavaScript APIs.  These motivations have led to a non-traditional type system, favoring qualities like easy escape hatches, inference, structural typing and full erasability.  I will discuss the TypeScript language, and its broader implications.\r\n",
      "Key": 758,
      "URL": null,
      "Title": "TypeScript: a Type System for Toolability"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1227,
        1548,
        1550,
        1551,
        1229,
        1549
      ],
      "Abstract": "",
      "Key": 891,
      "URL": null,
      "Title": "NitroGen: Rapid Development of Mobile Applications"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1376,
        1378,
        1375,
        1377,
        1379
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nData-dependent GPU kernels, whose data or control flow are dependent on the input of the program, are difficult to verify because they require reasoning about shared state manipulated by many parallel threads. Existing verification techniques for GPU kernels achieve soundness and scalability by using a two-thread reduction and making the contents of the shared state nondeterministic each time threads synchronise at a barrier, to account for all possible thread interactions. This coarse abstraction prohibits verification of data-dependent kernels. We present barrier invariants, a novel abstraction technique which allows key properties about the shared state of a kernel to be preserved across barriers during formal reasoning. We have integrated barrier invariants with the GPUVerify tool, and present a detailed case study showing how they can be used to verify three prefix sum algorithms, allowing efficient modular verification of a stream compaction kernel, a key building block for GPU programming. This analysis goes significantly beyond what is possible using existing verification techniques for GPU kernels.",
      "Key": 815,
      "URL": "http://www.doc.ic.ac.uk/~nyc04/papers/barrier.pdf",
      "Title": "Barrier Invariants: A Shared State Abstraction for the Analysis of Data-Dependent GPU Kernels"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1481,
        1482,
        1480
      ],
      "Abstract": "Smartphones and tablets with rich graphical user interfaces (GUI) are becoming increasingly popular.  Hundreds of thousands of specialized applications, called apps, are available for such mobile platforms.  Manual testing is the most popular technique for testing graphical user interfaces of such apps.  Manual testing is often tedious and error-prone.  In this paper, we propose an automated technique, called SwiftHand, for generating sequences of test inputs for Android apps.  The technique uses machine learning to learn a model of the app during testing, uses the learned model to generate user inputs that visit unexplored states of the app, and uses the execution of the app on the generated inputs to refine the model.  A key feature of the testing algorithm is that it avoids restarting the app, which is a significantly more expensive operation than executing the app on a sequence of inputs.  An important insight behind our testing algorithm is that we do not need to learn a precise model of an app, which is often computationally intensive, if our goal is to simply guide test execution into unexplored parts of the state space.  We have implemented our testing algorithm in a publicly available tool for Android apps written in Java.  Our experimental results show that we can achieve significantly better coverage than traditional random testing and L*-based testing in a given time budget.  Our algorithm also reaches peak coverage faster than both random and L*-based testing.",
      "Key": 850,
      "URL": "",
      "Title": "Guided GUI Testing of Android Applications with Minimal Restart and Approximate Learning"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1470,
        1469
      ],
      "Abstract": "Systematic exploration of Android apps is an enabler for a variety of app analysis and testing tasks. Performing the exploration while apps run on actual phones is essential for exploring the full range of app capabilities. However, exploring real-world apps on real phones is challenging due to non-determinism, non-standard control flow, scalability and overhead constraints.  Relying on end-users to conduct the exploration might not be very effective: we performed a 7-user study on popular Android apps, and found that the combined 7-user coverage was 30.08% of the app screens and 6.46% of the app methods.  Prior approaches for automated exploration of Android apps have run apps in an emulator or focused on small apps whose source code was available.  To address these problems, we present an approach that allows substantial Android apps to be explored systematically while running on actual phones, yet without requiring access to the app's source code.  The key insight of our approach is to use a static, taint-style, dataflow analysis on the app bytecode in a novel way, to construct a high-level control flow graph that captures legal transitions among activities (app screens). We then use this graph to develop an exploration strategy named Targeted Exploration that permits fast, direct exploration of activities, including activities that would be difficult to reach during normal use. We also developed a strategy named Depth-first Exploration that mimics user actions for exploring activities and their constituents in a slower, but more systematic way.  To measure the effectiveness of our techniques, we use two metrics: activity coverage (number of screens explored) and method coverage.  Experiments with using our approach on 25 popular Android apps including BBC News, Gas Buddy, Amazon Mobile, Shazam Encore, CNN, YouTube show that our exploration techniques achieve 59.39--64.11% activity coverage and 29.53--36.46% method coverage.",
      "Key": 847,
      "URL": "http://www.cs.ucr.edu/~neamtiu/pubs/oopsla13azim.pdf",
      "Title": "Targeted and Depth-first Exploration for Systematic Testing of Android Apps"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1449,
        1447,
        1501,
        1504,
        1448,
        1503
      ],
      "Abstract": "Emerging mobile applications that sense context are poised to delight and entertain us with timely news and events, health tracking, and social connections. Unfortunately, sensing algorithms quickly drain the phone's battery. Developers can overcome battery drain by carefully optimizing context sensing but that makes programming with context arduous and ties applications to current sensing hardware. These types of applications embody a twist on the classic tension between programmer productivity and performance due to this combination of requirements.\r\n\r\nThis paper identifies the latency, accuracy, battery (LAB) abstraction to resolve this tension. We implement and evaluate LAB in a system called Senergy. Developers specify their LAB requirements independent of inference algorithms and sensors. Senergy delivers energy efficient context while meeting the requirements and adapts as hardware changes. To demonstrate programmer productivity, we show LAB captures the key constraints of 22 context sensing algorithms that implement four types of context (location, driving, walking, and stationary). To demonstrate LAB's energy optimizations, we implement six applications and show an order of magnitude improvement in energy efficiency compared to prior approaches. More generally, the proposed API may serve as a blueprint for future API design in an increasingly complex design space that must satisfy portability, latency, accuracy, and efficiency application needs across evolving, sensor-rich, heterogeneous, and power constrained hardware.",
      "Key": 839,
      "URL": "",
      "Title": "The Latency, Accuracy, and Battery (LAB) Abstraction: Programmer Productivity and Energy Efficiency for Continuous Mobile Context Sensing"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1352,
        1351,
        1350
      ],
      "Abstract": "We propose constraining multithreaded execution to small sets of input-covering schedules, which we de?ne as follows: given a program P, we say that a set of schedules ? covers all inputs of program P if, when given any valid input, P\u2019s execution can be constrained to some schedule in ? and still produce a semantically valid result.\r\n\r\nOur approach is to ?rst compute a small ? for a given program P, and then, at runtime, constrain P\u2019s execution to always follow some schedule in ?, and never deviate. We have designed an algorithm that uses symbolic execution to systematically enumerate a set of input-covering schedules, ?. To deal with programs that run for an unbounded length of time, we partition execution into bounded epochs, ?nd input-covering schedules for each epoch in isolation, and then piece the schedules together at runtime. We have implemented this algorithm along with a constrained execution runtime for pthreads programs, and we report results.\r\n\r\nOur approach has the following advantage: because all possible runtime schedules are known a priori, we can seek to validate the program by thoroughly verifying each schedule in ?, in isolation, without needing to reason about the huge space of thread interleavings that arises due to conventional nondeterministic execution.",
      "Key": 806,
      "URL": "http://homes.cs.washington.edu/~tbergan/papers/oopsla13-ics.pdf",
      "Title": "Input-Covering Schedules for Multithreaded Programs"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1387,
        1357,
        1383,
        1385,
        1358,
        1382,
        1384,
        1386
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nParallel programming is essential for reaping the benefits of parallel hardware, but it is notoriously difficult to develop and debug reliable, scalable software systems. One key challenge is that modern languages and systems provide poor support for ensuring concurrency correctness properties -- atomicity, sequential consistency, and multithreaded determinism -- because all existing approaches are impractical. Dynamic, software-based approaches slow programs by up to an order of magnitude because capturing and controlling cross-thread dependences (i.e., conflicting accesses to shared memory) requires synchronization at virtually every access to potentially shared memory.\r\n\r\nThis paper introduces a new software-based concurrency control mechanism called Octet that soundly captures cross-thread dependences and can be used to build dynamic analyses for concurrency correctness.  Octet achieves low overheads by tracking the locality state of each potentially shared object. Non-conflicting accesses conform to the locality state and require no synchronization; only conflicting accesses require a state change and heavyweight synchronization. This optimistic tradeoff leads to significant efficiency gains in capturing cross-thread dependences: a prototype implementation of Octet in a high-performance Java virtual machine slows real-world concurrent programs by only 26% on average. These results suggest that Octet can provide a foundation for developing low-overhead analyses that check and enforce concurrency correctness properties.",
      "Key": 817,
      "URL": "http://www.cse.ohio-state.edu/~mikebond/octet-oopsla-2013.pdf",
      "Title": "Octet: Capturing and Controlling Cross-Thread Dependences Efficiently"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1380,
        1381
      ],
      "Abstract": "The performance of parallel code significantly depends on the parallel task granularity (PTG). If the PTG is too coarse, performance suffers due to load imbalance; if the PTG is too fine, performance suffers from the overhead that is induced by parallel task generation and scheduling.\r\n\r\nThis paper presents a software platform that automatically determines the PTG at run-time. Automatic PTG selection is enabled by concurrent calls, which are special source language construct that provide a late decision (at runtime) of whether concurrent calls are executed sequentially or concurrently as a parallel task. Furthermore, the execution semantics of concurrent calls permits the runtime system to merge two (or more) concurrent calls into a single concurrent call. I.e,. concurrent call merging coarsens the PTG. We present an integration of concurrent calls into the Java programming language, the Java Memory Model, and show how the Java Virtual Machine can adapt the PTG based on dynamic profiling. The performance evaluation shows that our runtime system performs competitively to Java programs for which the PTGis tuned manually. If, however, the PTG is chosen unlucky, our approach performs up to 3X faster than standard Java code.",
      "Key": 816,
      "URL": "",
      "Title": "Online-Feedback-Directed Optimizations for Parallel Java Code"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1374,
        1372,
        1371,
        1373
      ],
      "Abstract": "![Artifact Evaluated](http://splashcon.org/2013/images/aec-badge.png)\r\n\r\nJavaScript is the most popular language on the web and is a crucial component of HTML5 applications and services that run on consumer platforms ranging from desktops to phones. However, despite ample amount of hardware parallelism available to web applications on such platforms, JavaScript web applications remain predominantly sequential. Common parallel programming solutions accepted by other programming languages failed to transfer themselves to JavaScript due to differences in programming models, the additional requirements of the web and different developer expectations. In this paper we present River Trail - a parallel programming model and API for JavaScript that provides safe, portable, programmer-friendly, deterministic parallelism to JavaScript applications. River Trail allows web applications to effectively utilize multiple cores, vector instructions, and GPUs on client platforms while allowing the web developer to remain within the environment of JavaScript.We describe the implementation of the River Trail compiler and runtime and present experimental results that show the impact of River Trail on performance and scalability for a variety of realistic HTML5 applications. Our experiments show that River Trail has a dramatic positive impact on overall performance and responsiveness of compute intensive JavaScript based applications achieving up to 33.6 times speedup for kernels and up to 11.8 times speedup for realistic web applications compared to sequential JavaScript. Moreover, River Trail enables new interactive web usages that are simply not even possible with standard sequential JavaScript.",
      "Key": 814,
      "URL": "http://herhut.eu/files/herhut-oopsla-2013-preprint.pdf",
      "Title": "River Trail: A Path to Parallelism in JavaScript"
    },
    {
      "Type": "Wavefront Experience",
      "Authors": [
        1586,
        1589,
        1587,
        1588,
        1585
      ],
      "Abstract": "Efficient multicore programming demands fundamental data structures that support a high degree of concurrency. Existing research on non-blocking data structures promises to satisfy such demands by providing progress guarantees that allow a significant increase in parallelism while avoiding the safety hazards of lock-based synchronizations.  It is well-acknowledged that the use of non-blocking containers can bring significant performance benefits to applications where the shared data experience heavy contention.  However, the practical implications of integrating these data structures in real-world applications are not well-understood.  In this paper, we study the effective use of non-blocking data structures in a data deduplication application which performs a large number of concurrent compression operations on a data stream using the pipeline parallel processing model. We present our experience of manually refactoring the application from using conventional lock-based synchronization mechanisms to using a wait-free hash map and a set of lock-free queues to boost the degree of concurrency of the application.  Our experimental study explores the performance trade-offs of parallelization mechanisms that rely on a) traditional blocking techniques, b) fine-grained mutual exclusion, and c) lock-free and wait-free synchronization.",
      "Key": 910,
      "URL": null,
      "Title": "Effective Use of Non-blocking Data Structures in a Deduplication Application "
    },
    {
      "Type": "Wavefront Experience",
      "Authors": [
        1590
      ],
      "Abstract": "Scaling a web applications can be easy for simple CRUD software running when you use Platform as a Service Clouds (PaaS).  But if you need to deploy a complex software, with many components and a lot users, you will need have a mix of cloud services in PaaS, SaaS and IaaS layers.  You will also need knowledge in architecture patterns to make all these software components communicate accordingly.  In this article, we share our experience of using cloud services to scale a web application.  We show usage examples of load balancing, session sharing, e-mail delivery, asynchronous processing, logs processing, monitoring, continuous deployment, realtime user monitoring (RUM).  These are a mixture of development and system operations (DevOps) that improved our application availability, scalability and performance.",
      "Key": 911,
      "URL": null,
      "Title": "DevOps patterns to scale web applications using cloud services"
    },
    {
      "Type": "Wavefront Experience",
      "Authors": [
        1256
      ],
      "Abstract": "Creating a software architecture is a critical task in the development of software systems.  However, often the architecture discussed and created with extreme care is not entirely followed in the implementation.  Unless the architecture is communicated effectively to all developers, divergence between the intended architecture (created by the software architect) and the actual architecture (found in the source code) tends to gradually increase. Static analysis tools, which are often used to check naming conventions and coding best practices, can help.  However, the common use of static analysis tools for architecture enforcement has two limitations.  One is the fact that design rules specific to a software architecture are not known and hence not enforced by the tool.  The other limitation is more of a practical issue: static analysis tools are often integrated to the IDE or to a continuous integration environment; they report violations but the developers may choose to ignore them.  This paper reports a successful experience where we addressed these two limitations for a large codebase comprising over 50 Java applications.  Using a free open source tool called checkstyle and its Java API, we implemented custom checks for design constraints specified by the architecture of our software systems.  In addition, we created a script that executes automatically on the Subversion software configuration management server prior to any code commit operation.  This script runs the custom checks and denies the commit operation in case a violation is found.  When that happens, the developer gets a clear error message explaining the problem.  The architecture team is also notified and can proactively contact the developer to address any lack of understanding of the architecture.  This experience report provides technical details of our architecture enforcement approach and recommendations to employ this or similar solutions more effectively.",
      "Key": 912,
      "URL": null,
      "Title": "Ultimate Architecture Enforcement &mdash; Custom checks enforced at code-commit time "
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1257
      ],
      "Abstract": "Reasoning about programs is a fundamental skill that every software engineer needs. This tutorial provides participants an opportunity to get hands-on experience with Dafny, a tool that can help develop this skill. Dafny is a programming language and state-of-the-art program verifier. The language is type-safe and sequential, and it includes common imperative features, dynamic object allocation, and datatypes. It also includes specification constructs like pre- and postconditions, which let a programmer record the intended behavior of the program along with the executable code that is supposed to cause that behavior. What sets Dafny apart from other programming systems is that it runs its verifier continuously in the background, and thus the consistency of a program and its specifications is always enforced. This tutorial gives a taste of how to use Dafny in program development. This includes an overview of Dafny, basics of writing specifications, how to debug verification attempts, and how to formulate and prove lemmas. The tutorial is geared toward programmers who want to get their programs right, students, educators, as well as researchers in formal methods.",
      "Key": 732,
      "URL": "http://research.microsoft.com/dafny",
      "Title": "Developing Verified Programs with Dafny"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1592,
        1507,
        1569
      ],
      "Abstract": "With increasing frustration with Java and its ilk, instructors\r\nare searching for an alternative language for introducing students to\r\nobject-oriented programming.  This alternative should have\r\nsimple and clear syntax and semantics, provide good support for\r\nobject-oriented programming, and yet give instructors the flexibility to\r\nintroduce the material in a variety of ways, including objects-first,\r\nobjects-late, and functional-first.  It should also support both dynamic and\r\nstatic typing.\r\n\r\nGrace is a new language that meets these needs.  Grace allows the definition of both objects\r\nand classes, provides encapsulation and inheritance, and is gradually\r\ntyped, allowing instructors to start with either dynamic or\r\nstatic typing and to move from one to the other.  Moreover, Grace provides a concise syntax\r\nfor first-class functions providing great flexibility in building\r\nnew language constructs from the primitive notions of the language.\r\n\r\nIn order to support good pedagogy, Grace, like Racket, supports\r\ndialects, so that students can be introduced first to limited versions\r\nof the language,  which can then be grown, in a variety of\r\nways, to the full version.  A simple, object-based module system\r\nsupports the use of libraries that can be used as scaffolding for\r\nteaching.  For example, a Grace version of the Java objectdraw library\r\nfor graphics is available for use in teaching event-based graphical programming using Grace.\r\n\r\nThe first 90 minutes of this tutorial will introduce participants to the features\r\nof Grace, the motivations that led to the design, and discuss how Grace\r\nmight be used in introductory courses.  Those wanting to experience\r\nGrace immediately may stay for a second 90-minute lab in which\r\nthey can try their hand at Grace programming.",
      "Key": 914,
      "URL": "http://gracelang.org/",
      "Title": "Grace:  A new object-oriented language for novices"
    },
    {
      "Type": "Tutorials",
      "Authors": [
        1273
      ],
      "Abstract": "Attendees of this tutorial will gain hands-on experience using functional programming for solving financial engineering problems. In this tutorial, we will acquaint ourselves with Kx\u2019s KDB/Q language, a dynamically-typed vector-oriented language with roots in APL, while comparing and contrasting some of the programming concepts with equivalent ones in Scala. The tutorial consists of three parts:\r\n\r\n1.  Overview of KDB/Q, its data types and functional constructs.\r\n\r\n2.  Financial engineering concepts, returns, volatility, discount factors, binomial lattice models, and term structures, the basic building blocks of many financial engineering problems.\r\n\r\n3.  Building a real-time mock market tick by tick  system  that feeds real-time calculation engine based on some of the concepts introduced in Section 2.\r\n\r\nThe goal of this tutorial is two-fold.  First, it is to introduce both financial engineering concepts and the computational resources required to model and solve problems in this discipline. Second, it is to explore the use of a functional programming language to build solutions for problems in this area.\r\n\r\n**Prerequisites:** This tutorial will be presenting KDB/Q from the ground up. So while there are no prerequisites for this tutorial, some prior experience with Scheme/Lisp, Scala, Clojure would make it easier to grasp some of the concepts presented.",
      "Key": 746,
      "URL": "",
      "Title": "Using Functional Programming Concepts in Financial Engineering"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1292
      ],
      "Abstract": "Recent advances in cloud platforms have simplified cloud use by providing developers with complete software/runtime stacks for execution of their web-accessible applications and services.  PaaS systems offer programmatic access to scalable, distributed, and fault tolerant cloud services which eliminates the need for developers to write or deploy their own and enabling them to focus on their innovation. I present AppScale, a PaaS platform that emulates: Google App Engine. API-compatibility with App Engine means that any of the three million active App Engine apps today execute over AppScale without modification.  This, in combination with the fact that AppScale executes  anywhere a virtual machine can be instantiated (a laptop, an on-premise cluster, a local data center, Amazon EC2 or other IaaS), means that AppScale gives developers choice across all of the most popular deployment options available today, with no code rewrite &mdash; bringing \"write-once, run-anywhere\" to cloud applications.\r\n",
      "Key": 752,
      "URL": null,
      "Title": "Write-Once, Run-Anywhere for the Cloud"
    },
    {
      "Type": "Demonstrations",
      "Authors": [
        1558,
        1559
      ],
      "Abstract": "",
      "Key": 896,
      "URL": null,
      "Title": "Objektgraph: Why Code When MVC Apps Can Be Generated Solely With UML-based Diagrams?"
    },
    {
      "Type": "SPLASH-I",
      "Authors": [
        1541
      ],
      "Abstract": "Dynamic languages are notoriously difficult to optimize.  JavaScript is particularly hard: all values are untyped, most numeric operations are defined to have floating-point-like semantics, and all objects, including arrays, semantically behave like linked lists of dictionaries.  The problems are not new: inferring the shapes of dictionaries and the run-time behavior of untyped values has been attempted before in languages like Scheme, Self and Smalltalk.  But those languages were never used at the same scale.  A typical webpage can exceed 1MB of compressed source code, exhibit high degrees of polymorphism, and offer few opportunities for the VM to \"warm up\".  I describe the engineering behind the WebKit JavaScript engine, a three-tier code caching JSVM with parallel mostly-copying garbage collection.  Specific attention will be given to how the VM architecture balances the need to execute large, run-once, and polymorphic functions, while enabling the steady-state performance of frequently-executed computational functions to approach the speed of C.  The code caching, garbage collection, type inference, compilation, and speculation/deoptimization strategies will be described in detail along with examples of how the VM can turn programs written using idioms that are intractable from a static analysis standpoint into tightly optimized  code.\r\n",
      "Key": 887,
      "URL": null,
      "Title": "A Comprehensive JavaScript VM"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1402,
        1403
      ],
      "Abstract": "The machine representation of floating point values has limited precision such that errors may be introduced during execution. These errors may get propagated and magnified by the following operations, leading to instability problems, e.g., control flow path may be undesirably altered and faulty output may be emitted. In this paper, we develop an on-the-fly efficient monitoring technique that can predict if an execution is stable. The technique does not explicitly compute errors as doing so incurs high overhead. Instead, it detects possible places where an error becomes substantially inflated regarding the corresponding value, and then tags the value with one bit to denote that it has an inflated error. It then tracks inflation bit propagation, taking care of operations that may cut off such propagation. It reports instability if any inflation bit reaches a critical execution point, such as a predicate, where the inflated error may induce substantial execution difference, such as different execution paths. Our experiment shows that with appropriate thresholds, the technique can correctly detect that over 99.999996% of the inputs of all the programs we studied are stable while a traditional technique relying solely on inflation detection mistakenly classifies majority of the inputs as unstable for some of the programs. Compared to the state of the art technique that is based on high precision computation and causes several hundred times slowdown, our technique only causes 7.91 times slowdown on average and can report all the true unstable executions with the appropriate thresholds.",
      "Key": 824,
      "URL": "http://www.cs.purdue.edu/homes/tbao/files/oopsla13.pdf",
      "Title": "On-the-fly Detection of Instability Problems in Floating-Point Program Execution"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1495,
        1501,
        1496
      ],
      "Abstract": "Eliminating concurrency errors is increasingly important as systems rely more on parallelism for performance.  Exhaustively exploring the state-space of a program's thread interleavings finds concurrency errors and provides coverage guarantees, but suffers from exponential state-space explosion.  Two prior approaches alleviate state-space explosion: (1) Partial-order reduction provides full coverage and explores only one interleaving of independent transitions.  (2) Bounded search provides bounded coverage by enumerating interleavings without exceeding a bound. Combining them had remained an open problem.\r\n\r\nWe show that bounded search explores the same partial orders repeatedly and consequently the DPOR state space is often smaller, even for small bounds.  We further show that if DPOR simply uses the bound to prune the state space as it explores new partial orders, it misses parts of the state space reachable in the bound and is therefore unsound.  The bound essentially induces dependences between otherwise independent transitions in the state space.  We introduce Bounded Partial Order Reduction (BPOR), a modification of the Dynamic Partial Order Reduction (DPOR) that compensates for bound dependences. We identify properties that determine how well bounds combine with partial-order reduction.  We prove sound coverage and empirically evaluate BPOR with preemption and fairness bounds.  We show that by eliminating redundancies, BPOR significantly reduces testing time compared to bounded search. BPOR's faster incremental guarantees will help testers verify larger concurrent programs.",
      "Key": 854,
      "URL": "",
      "Title": "Bounded Partial-Order Reduction"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1445,
        1446
      ],
      "Abstract": "When resolving performance problems, a simple histogram of hot call stacks does not cut it, especially given the highly fluid nature of modern deployments. Why bother tuning, when adding a few CPUs via the management console will quickly resolve the problem? The findings of these tools are also presented without any sense of context: e.g. string conversion may be expensive, but only matters if it contributes greatly to the response time of user logins.\r\n\r\nHistorically, these concerns have been the purview of capacity planning. The power of planners lies in their ability to weigh demand versus capacity, and to do so in terms of the important units of work in the application (such as user logins). Unfortunately, they rely on measurements of rates and latencies, and both quantities are difficult to obtain. Even if possible, when all is said and done, these planners only relate to the code as a black-box: but, why bother adding CPUs, when easy code changes will fix the problem?\r\n\r\nWe present a way to do planning on-the-fly: with a few call stack samples taken from an already-running system, we predict the benefit of a proposed tuning plan. We accomplish this by simulating the effect of a tuning action upon execution speed and the way it shifts resource demand. To identify existing problems, we show how to generate tuning actions automatically, guided by the desire to maximize speedup without needless expense, and that these generated plans may span resource and code changes. We show that it is possible to infer everything needed from these samples alone: levels of resource demand and the units of work in the application. We evaluate our planner on a suite of microbenchmarks and a suite of 15,000 data sets that come from real applications running in the wild.",
      "Key": 838,
      "URL": "http://researcher.watson.ibm.com/researcher/files/us-nickm/marbles.pdf",
      "Title": "On-the-fly Capacity Planning"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1418,
        1417
      ],
      "Abstract": "We introduce the first program logic for reasoning about concurrent programs running under the C11 relaxed memory model. From a user's perspective, our program logic, which we call relaxed separation logic (RSL), is an extension of concurrent separation logic (CSL) with proof rules for the various kinds of C11 atomic accesses. As in CSL, individual threads are allowed to access non-atomically only the memory that they own, thus preventing data races. Ownership can, however, be transfered via certain atomic accesses. For SC-atomic accesses, we permit arbitrary ownership transfer; for acquire/release atomic accesses, only unidirectional ownership transfer is allowed; whereas for relaxed atomic accesses, no ownership transfer is allowed. We illustrate RSL with a few simple examples and prove its soundness directly over the axiomatic C11 weak memory model.",
      "Key": 830,
      "URL": "http://www.mpi-sws.org/~viktor/rsl/",
      "Title": "Relaxed Separation Logic: A Program Logic for C11 Concurrency"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1393,
        1394,
        1392
      ],
      "Abstract": "Framework based software tends to get bloated by accumulating optional features or concerns just-in-case they are needed. The good news is that such feature bloat need not always cause runtime execution bloat. The bad news is that often enough, only a few statements from an optional concern may cause execution bloat that may result in as much as 50% runtime overhead.\r\n\r\nWe present a novel technique to analyze the connection between optional concerns and the potential sources of execution bloat induced by them. Our analysis automatically answers questions such as (1) whether a given set of optional concerns could lead to execution bloat and (2) which particular statements are the likely sources of bloat when those concerns are not required.The technique combines coarse grain concern input with a fine-grained static analysis. Our experimental evaluation highlights the effectiveness of such concern augmented program analysis in execution bloat assessment of ten programs.",
      "Key": 820,
      "URL": "",
      "Title": "Combining Concern Input with Program Analysis for Bloat Detection"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1477,
        1478,
        1479
      ],
      "Abstract": "This paper presents a novel methodology for localizing faults in code as it evolves. Our insight is that the essence of failure-inducing edits made by the developer can be captured using mechanical program transformations. Specifically, transformations of the old program version, which have similar test execution results as the new version, are likely to share the same locations with some failure-inducing edits. We present the FIFL framework that embodies our insight. We evaluate FIFL on real-world repositories of nine Java projects ranging from 5.7KLoC to 88.8KLoC. The experimental results show that FIFL is able to outperform the state-of-the-art FAULTTRACER technique for localizing failure-inducing program edits significantly. For example, FIFL (using its default setting) outperforms FAULTTRACER by 2.33% to 86.26% on 16 of 26 studied version pairs, and is only inferior than FAULTTRACER on one version pair.",
      "Key": 849,
      "URL": "",
      "Title": "Injecting Mechanical Faults to Localize Developer Faults for Evolving Software"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1442,
        1444,
        1443
      ],
      "Abstract": "In the multi-core era, it is critical to efficiently test multi-threaded software and expose concurrency bugs before software release. Previous work has made significant progress in detecting and validating concurrency bugs under a given input. Unfortunately, software testing always faces large sets of test inputs, and existing techniques are still too expensive to be applied to every test input in practice.\r\n\r\nIn this paper, we use open-source software to study how existing concurrency-bug detection tools work for a set of inputs. The study shows that an interleaving pattern, such as a data race or an atomicity violation, can often be exposed by many inputs. Consequently, existing bug detectors would inevitably waste their bug detection effort to generate duplicate bug reports, when applied to a set of inputs.\r\n\r\nGuided by the above study, we propose a coverage metric, Concurrent Function Pairs (CFP), to efficiently approximate how interleavings overlap across inputs. Using CFP, we have designed a new approach to detecting data races and atomicity-violation bugs for a set of inputs.\r\n\r\nOur evaluation on open-source C/C++ applications shows that our CFP-guided approach can effectively accelerate concurrency-bug detection for a set of inputs by reducing redundant detection effort across inputs.",
      "Key": 837,
      "URL": "http://pages.cs.wisc.edu/~shanlu/paper/deng-oopsla13.pdf",
      "Title": "Efficient Concurrency-Bug Detection Across Inputs"
    },
    {
      "Type": "OOPSLA",
      "Authors": [
        1395,
        1396
      ],
      "Abstract": "When programmers encounter an unfamiliar API library, they often need to refer to its documentations, tutorials, or existing discussion/development forums to learn its proper usage. These API documents contain valuable information, but may also mislead programmers as they may contain errors (e.g., broken code references and obsolete code samples). Although most API documents are actively maintained and updated, studies show that many new and latent errors do exist. It is tedious and error-prone to find such errors manually as API documents can be enormous with thousands of pages. Existing tools are ineffective in locating documentation errors because traditional natural language (NL) tools do not understand code references and code samples, and traditional code analysis tools do not understand NL sentences. In this paper, we propose the first approach, DOCREF, specifically designed and developed to detect API documentation errors. We formulate a class of inconsistencies to indicate potential documentation errors, and combine NL and code analysis techniques to detect and report such inconsistencies. We have implemented DOCREF and evaluated its effectiveness on the latest documentations of five widely-used API libraries. DOCREF has detected more than 1,000 new documentation errors, which we have reported to the authors. Many of the errors have already been confirmed and fixed, after we reported them.",
      "Key": 821,
      "URL": "",
      "Title": "Detecting API Documentation Errors"
    },
    {
      "Type": "Social Events",
      "Authors": [

      ],
      "Abstract": "",
      "Key": 933,
      "URL": null,
      "Title": "Ice Cream Social"
    }
  ],
  "Event": 10,
  "VenueInfo": {
    "GPS": {
      "Latitude": 39.7665307,
      "Longitude": -86.1609597
    },
    "Name": "Hyatt Regency"
  },
  "URL": "http://splashcon.org/2013"
}